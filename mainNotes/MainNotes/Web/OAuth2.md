Рассмотрим, какие еще варианты есть проведение аутентификации и авторизации пользователей в системе.
![[Pasted image 20240916224400.png]]
Смысл OAuth2 в том, что у нас есть сторонний AuthorizationServer, к которому будет обращаться пользователь. Т.е. у нас дополнительно появляется возможность авторизоваться не через username+password, а через какой-то сервер, которому вы доверяете. Гугл, например, или Facebook, GitHub. Т.е. когда на страничке логина мы видим возможность зайти, используя google аккаунт, то это оно и есть.
Плюсом такого подхода является то, что пароль хранится в одном месте, т.е. из-за того, что пользователи часто используют один и тот же пароль, то какое-то из приложений может оказаться небезопасным, его взломают и пароли утекут. А раз пароль использовался еще и в других приложениях, то злоумышленник может получить доступ к аккаунту. А также плюсом является то, что не нужно создавать новый аккаунт для каждого приложения, для аутентификации в другие приложения достаточно одного аккаунта.

### Как внедрить OAuth2?
![[Pasted image 20240916224917.png]]
1. Нам нужно создать аккаунт(именно серверу нужно создать аккаунт, а не пользователю) на Auth Server, чтобы наш сервер мог общаться с AuthServer. После создания аккаунта Auth Server возвращает cliend_id и cliend_secret.
2. Подключить 2 зависимость. client - содержит классы для взаимодействия Auth Client и Auth Server. jose - для работы с Security и JWT. Для того, чтобы валидировать эти токены, извлекать информацию.

### Разберемся, как все-таки это все работает вместе
![[Pasted image 20240916225217.png]]
На backend чаще всего используется Authorization Code Flow, который мы и разберем, а дальше станет понятно, что за другие Flow. Hybrid Flow - содержит внутри себя и Authorization Code Flow и Implicit Flow.
![[Pasted image 20240916225359.png]]
![[Pasted image 20240916225734.png]]
![[Pasted image 20240916225858.png]]
User попадает на страничку Login нашего приложения. Там он решает залогиниться, например, через Google(для этого у него должен быть google аккаунт). Наше приложение понимает, что пользователь хочет залогиниться через google и отправляет 302 код(редирект) на страничку аутентификации через гугл. И вместе с этим редиректом передается еще некоторые параметры, самые интересные на слайде:
1. client_id - 
2. redirect_uri - это тот URI, на который должен редиректнуть пользователя Authentication Server
3. scope
4. response_type=code - это как раз определяет, что мы используем Authorization Code Flow. 
Дальше клиент идет по тому запросу из 302 статуса и за одно передает параметры, которые указаны выше. Дальше Auth Server занимается аутентификацией пользователя(у пользователя уже должен быть аккаунт, поэтому с этим проблем быть не должно). И после успешного прохождения Auth Server перенаправляет на redirect_uri, который мы указывали ранее при запросе. А также code - это тоже следствие того, что мы работаем по Authorization Code Flow. Т.е. результатом работы Auth Server является code.
Дальше клиент переходит по этому URI, мы на сервере получили code. 
Затем происходит работа, которую клиент не видит. Мы начинаем общаться с Auth Server из нашего Servera. Для этого мы проходит авторизацию, используя client_id:client_secret(их мы получаем еще раньше, когда создаем аккаунт нашего AuthClient), а также передаем code, который нам передал клиент. И если все это оказалось валидным, то авторизация произошла успешна и нам возвращаются access и refresh token от Auth Server.
Access Token - это строка, которая хранится в определенном виде и хранит в себе все Authorities пользователя, но никакой личной информации о пользователе нет. Просто набор ролей. И этот токен можно использовать, чтобы обращаться к любым ресурсам, т.е. провести авторизацию. И только после этого пользователь увидит welcome page нашего приложения.

В чем отличие от implicit flow?
![[Pasted image 20240916231627.png]]
Т.е. теперь авторизация происходит на стороне клиента, когда используется JS.

В целом, недостатком OAuth2 является то, что у нас на сервере нет никакой информации о пользователе. Т.е. у нас только есть его authorities, но больше ничего. Поэтому есть еще один протокол, который построен поверх OAuth2 и он называется OIDC(Open ID Connect). И он работает по той же логике, что и OAuth2, но на моменте получения токенов мы получаем еще и JWT токен.
![[Pasted image 20240916231952.png]]
И в это токене есть вся необходимая информация о нашем пользователе. Например, email, имя пользователя, его локаль.
Т.е. OAuth2 - это авторизация, а OIDC - это и авторизация и аутентификация за счет JWT.
Чтобы Auth Server понял, что мы используем именно OIDC мы в scope добавляем эту информацию:
![[Pasted image 20240916232332.png]]

### OAuth2 практика
1. НА Google Cloud Platform создается Project:
![[Pasted image 20240916232650.png]]
Чтобы создать нового клиента нужно нажать CREATE CREDENTIALS:
![[Pasted image 20240916232735.png]]