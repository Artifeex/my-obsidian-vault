Это интерфейс, который содержит всего один абстрактный метод(т.е. не реализованный). 
Может быть помечен аннотацией @FunctionalInterface - с помощью нее мы явно сообщаем компилятору о наших намерениях, чтобы он проверил, что интерфейс является функциональным. 
Примером функционального интерфейса является [[Runnable]].

Важно, что для того, чтобы интерфейс был функциональным, нужно, чтобы только 1 метод был абстрактным. При этом никто не запрещает писать другие методы с реализациями, тогда они будут не абстрактными. Такое поведение у функционального интерфейса [[Function]].

Есть еще одна интересная оговорочка, что в счетчик абстрактных методов не включаются методы, которые идут от класса [[Object]]. Поэтому интерфейс [[Comparator]], является функциональным, несмотря на то, что в нем есть 2 абстрактных метода, но метод equals является методом из Object.

Схожим образом работает IntSupplier. Хоть в нем 2 метода, но при этом абстрактным является один, поэтому он также является функциональным интерфейсом.
![[Pasted image 20240926112407.png]]

В местах, где ожидается функциональный интерфейс мы можем использовать [[Функциональные выражения]].