Это интерфейс, который содержит всего один абстрактный метод(т.е. не реализованный). 
Может быть помечен аннотацией @FunctionalInterface - с помощью нее мы явно сообщаем компилятору о наших намерениях, чтобы он проверил, что интерфейс является функциональным. 
Примером функционального интерфейса является [[Runnable]].

Важно, что для того, чтобы интерфейс был функциональным, нужно, чтобы только 1 метод был абстрактным. При этом никто не запрещает писать другие методы с реализациями, тогда они будут не абстрактными. Такое поведение у функционального интерфейса [[Function]].

Есть еще одна интересная оговорочка, что в счетчик абстрактных методов не включаются методы, которые идут от класса [[Object]]. Поэтому интерфейс [[Comparator]], является функциональным, несмотря на то, что в нем есть 2 абстрактных метода, но метод equals является методом из Object.

Схожим образом работает IntSupplier. Хоть в нем 2 метода, но при этом абстрактным является один, поэтому он также является функциональным интерфейсом.
![[Pasted image 20240926112407.png]]

В местах, где ожидается функциональный интерфейс мы можем использовать [[Функциональные выражения]].

### Интересные функциональные интерфейсы

#### [[Comparable]] и [[Comparator]]
Используются в местах, где требуется сортировка. Например, в коллекциях, которые хранят данные в отсортированном виде: [[TreeMap. К-Ч деревья]] и TreeSet. 
Или при вызове Collections.sort().

Comparable - данный интерфейс должен реализовывать класс, который мы хотим поместить в коллекцию. Т.е. это именно класс должен уметь сравниваться. 

Comparator - часто используется, когда класс не реализует интерфейс Comparable или же, если мы хотим задать какую-то кастомную сортировку. Это функциональный интерфейс, т.е. мы можем передать lambda в то место, где ожидается Comparator.

В Java все коллекции, поддерживающие автоматическую сортировку, используют методы сравнения для того чтобы правильно рассортировать элементы. В качестве примера таких классов мы можем указать TreeSet, TreeMap и т.д.

Для того чтобы рассортировать элементы, класс должен реализовать интерфейсы Comparator или Comparable. Именно поэтому классы-обертки как Integer, Double и String реализуют интерфейс Comparable.

Интерфейс Comparable помогает сохранять естественную сортировку, тогда как Comparator позволяет сортировать элементы по разным особым шаблонам. Экземпляр компаратора обычно передается конструктору коллекции, если коллекция это поддерживает. Следует отметить, что интерфейс Comparable может быть реализован именно элементами коллекции или ключами Map, а Comparator реализуется отдельным объектом (это удобно, так как можно заготовить несколько реализаций для разных правил сортировок, не меняя при этом код элементов коллекции/ключей Map).

#### Cloneable и [[Serializable]]
Cloneable - интерфейс метка, который нужен для того, чтобы наш объект мог вызывать super.clone() метода Object, поскольку внутри он проверяет с помощью instanceof реализует ли клонируемый интерфейс данный интерфейс. И если нет, то выбросит Exception. 

[[Predicate]]