Метод в классе-наследнике, совпадающий по сигнатуре с методом из родительского класса называется переопределенным методом. При этом снова следует уточнить, что возвращаемый тип не входит в сигнатуру метода. Поэтому, если мы попытаемся в наследнике написать метод с сигнатурой, как у родителя, но изменим возвращаемый тип, то получим ошибку компиляции, поскольку мы просто определили рядом такой же метод, но с другим возвращаемым значением. Т.е. ситуация схожая с тем, что происходило в [[Перегрузка метода]]. Переопределить базовый статический метод нельзя. 

### Переопределять статические методы нельзя

### При переопределении метода мы НЕ можем сузить уровень доступа метода, а расширить можем!
```java
public class TestImpl {  
    protected void test2(String b, Integer a) {  
        System.out.println("Non static");  
    }  
}

//изменили protected на public для метода test2
public class TestImpl2 extends TestImpl {  
    @Override  
    public void test2(String b, Integer a) {  
        super.test2(b, a);  
    }  
}
```

### При переопределении метода мы можем сузить возвращаемый тип, если этот более узкий тип находится в одной иерархии, т.е. вместо, например, некоторого родительского типа возвращать объект потомка
```java
// class B extends A
public class TestImpl {  
    protected A test2(String b, Integer a) {  
        return new A();  
    }  
}
//возвращаем теперь класс B, а не A как в родителе
public class TestImpl2 extends TestImpl {  
    @Override  
    public B test2(String b, Integer a) {  
        return new B();  
    }  
}
```
