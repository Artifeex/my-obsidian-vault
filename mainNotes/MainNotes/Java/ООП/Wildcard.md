Для Wildcard используется знак "?". Сам wildcard используется, когда точный тип не важен, а мы должны просто ограничить этот тип сверху и снизу, используя ковариантность и контравариантность.

**Неограниченный wildcard**: `<?>`
- Это означает, что тип может быть любым объектом, и мы не ограничиваемся каким-то конкретным классом или интерфейсом.
- Используется, когда нам важен сам объект, но не важен его конкретный тип.
Пример:
```java
public void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}

```
В данном примере метод `printList` принимает список с элементами любого типа.

**Ограниченный сверху wildcard**: `<? extends T>`
- Это означает, что допустимы любые типы, которые **наследуются от класса `T`** или являются самим классом `T`.
- Используется, когда нужно работать с объектами, которые могут быть типами, **производными от какого-то базового класса**.
Пример:
```java
public void processList(List<? extends Number> list) {
    for (Number num : list) {
        System.out.println(num.doubleValue());
    }
}

```
Здесь метод может принимать список объектов типа `Number` и его подклассов, таких как `Integer`, `Double`, и т.д.

**Ограниченный снизу wildcard**: `<? super T>`
- Это означает, что допустимы любые типы, которые являются **базовыми классами** для `T`, включая сам `T`.
- Используется, когда необходимо указать, что тип должен быть **родительским** по отношению к `T`.
Пример:
```java
public void addNumbers(List<? super Integer> list) { list.add(10); list.add(20); }
```
тип списка должен быть либо `Integer`, либо его супертипом (например, `Number`, `Object`).

### Зачем нужен механизм wildcard

Механизм wildcard нужен для:

1. **Гибкости кода**: Джокеры позволяют писать более универсальные методы, которые могут работать с коллекциями разных типов.
    
    Пример:

    `public static void printNumbers(List<? extends Number> list) {     for (Number num : list) {         System.out.println(num);     } }`
    
    Этот метод может принимать любой список, содержащий числа (`Integer`, `Double`, и т.д.).
    
2. **Безопасности типов**: Wildcard помогают ограничивать типы, с которыми можно работать, и предотвращать ошибки типов на этапе компиляции.
    
    `public static void addNumbers(List<? super Integer> list) {     list.add(10); }`
    
    Этот метод гарантирует, что в список будут добавлены только объекты типа `Integer` или его подтипов, что защищает от ошибок приведения типов.
    
3. **Обеспечения ковариантности и контравариантности**: Джокеры помогают контролировать, какие типы можно использовать в коллекциях, гарантируя безопасное извлечение и добавление элементов.

### Ковариантность
В Java это выражается через wildcard `<? extends T>`, что означает "любой тип, который является подтипом или самим `T`". Т.е. мы ожидаем Generic, который параметризован некоторым типом должен быть параметризован либо типом T, либо каким-нибудь его наследником.

При этом при ковариантности мы МОЖЕМ ПОЛУЧАТЬ элемент из коллекции, но не можем туда добавлять. Получать можем, потому что мы знаем, что в коллекции лежит что-то, что является либо T, либо наследуется от него, поэтому при получении мы получим объект типа T(верхнего типа, которым мы и ограничили). 

Основная причина, по которой **нельзя добавлять элементы** в ковариантные коллекции (`<? extends T>`), заключается в том, что **тип коллекции на этапе выполнения** точно неизвестен. Компилятор знает, что это какой-то подтип `T`, но **не знает точно, какой именно**.

### Контравариантность 
В Java это выражается через wildcard `<? super T>`, что означает "любой тип, который является суперклассом `T` или самим `T`".
```java
List<? super Integer> numbers = new ArrayList<Number>();

```

Здесь переменная `numbers` может хранить список, который параметризован типом `Integer` или его суперклассом (например, `Number` или `Object`).

Контравариантные списки позволяют **добавлять элементы** типа `T` или его подтипов. Однако, при извлечении элементов, компилятор рассматривает их как объекты самого общего типа — `Object`, так как мы не знаем точный параметр типа списка.

### extends - для producer
Не можем сделать set для Sword(), т.к. hero мог быть патаметризован чем-то, что находиться ниже по иерархии, чем Sword, а мы не можем в наследника передать родителя.
![[Pasted image 20241112095845.png]]
Но получать значения мы можем, т.к. даже если hero параметризован чем-то, что является наследником от sword, то это все еще sword, поэтому благодаря upcast мы можем получить это значение, поэтому extends - производитель
![[Pasted image 20241112100046.png]]
### super - consumer
Не можем получить weapon, рассчитывая, что это будет sword, т.к. это мог быть родитель sword, а мы знаем, что потомка мы не можем инициализировать родителем.
![[Pasted image 20241112100150.png]]
А вот установить: hero.setWeapon(new Sword()) - мы смогли бы, поскольку даже если в hero на самом деле параметризован родительским классом, то просто произойдет upcast sword до родительского класса.