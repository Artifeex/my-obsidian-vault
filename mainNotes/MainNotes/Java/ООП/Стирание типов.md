Стирание типов - это механизм, который используется Java для совместимости с кодом, который был написан до введение Generic в Java 5. Дженерики позволяют создавать классы, интерфейсы и методы с параметрами типов, но во время компиляции эта информация о типах удаляется (стирается). Таким образом, программа с дженериками становится совместимой с байт-кодом Java, который использовался до введения этой функции.
### Как работает стирание типов

1. **Стирание параметризованных типов**: Во время компиляции все параметры типов заменяются их верхней границей (если она указана) или `Object`, если граница не указана.
2. **Удаление информации о типах**: После компиляции в байт-коде нет информации о типах, которые были использованы в параметризации.
3. **Добавление кастов**: Поскольку информация о типах стирается, компилятор автоматически добавляет приведения типов (касты), чтобы поддерживать правильную типизацию данных во время выполнения.
```java
public class Box<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}

```
После компиляции код превращается в что-то, вроде, этого:
```java
public class Box {
    private Object item;

    public void setItem(Object item) {
        this.item = item;
    }

    public Object getItem() {
        return item;
    }
}

```
### Подробности работы механизма стирания типов

1. **Стирание типовых параметров**:
    - Когда дженерик-класс компилируется, типовые параметры заменяются их фактическими границами.
    - Если тип не имеет явно заданной границы (например, `<T>`), то параметр типа заменяется на `Object`.
    - Если задана верхняя граница, например `<T extends Number>`, то тип заменяется на `Number`.
2. Касты для возврата значений**:

- Когда стирается параметр типа, компилятор добавляет приведения типов в местах, где объект извлекается из дженерического класса.
- Например, если мы используем `Box<String>`, при вызове метода `getItem()` компилятор добавит приведение к `String`.
Пример:
```java
Box<String> stringBox = new Box<>();
stringBox.setItem("Hello");

String item = stringBox.getItem();  // приведение типа (cast) к String

```
При компиляции Java автоматически добавит приведение:
```java
String item = (String) stringBox.getItem();

```


### Ограничения, связанные со стиранием типов

Из-за стирания типов существуют некоторые ограничения на использование дженериков в Java:

1. **Нельзя использовать примитивные типы в дженериках**:
    
    - Дженерики работают только с объектами, а не с примитивами (например, `int`, `double`). Это связано с тем, что во время стирания типов все параметры типов заменяются на объекты (`Object` или другой класс), а примитивные типы не могут быть объектами.
    
    Пример:
    `Box<int> intBox = new Box<>();  // ошибка, нельзя использовать примитивы`
    Вместо этого нужно использовать их объектные эквиваленты, такие как `Integer`, `Double`.
    
2. **Нельзя создать экземпляр дженерик-типа**:
    
    - Поскольку информация о типах стирается во время выполнения, нельзя создать объект параметризованного типа с помощью оператора `new`. Например, следующий код вызовет ошибку компиляции:

    `public class Box<T> {     private T item = new T();  // ошибка, нельзя создать объект параметризированного типа }`
    
    Это связано с тем, что после стирания типов `T` заменяется на `Object`, а создание экземпляра `Object` без дополнительной информации невозможно.
    
3. **Нельзя использовать дженерики с массивами**:
    
    - Массивы в Java "ковариантны", что означает, что если `Box[]` — это массив, он может содержать объекты `Box<String>`, `Box<Integer>` и т.д. Однако из-за стирания типов при компиляции массивы дженериков не могут быть безопасно созданы.
    
    Пример:
    
    `Box<String>[] boxArray = new Box<String>[10];  // ошибка`
    
    Решение — использование коллекций вместо массивов.
    
4. **Нельзя использовать операции `instanceof` с параметризованными типами**:
    
    - Из-за стирания типов нельзя проверять объект на принадлежность к параметризованному типу с помощью `instanceof`.
    
    Пример:
    
    java
    
    Копировать код
    
    `if (obj instanceof Box<String>) {  // ошибка     // код }`
    
    Однако проверка `Box<?>` допустима, поскольку информация о параметре типа не требуется.
    
5. **Нельзя использовать статические члены с параметризованными типами**:
    
    - Параметры типов недоступны для статических членов класса, потому что статические элементы относятся ко всему классу, а не к его экземплярам, где дженерики могут иметь разные значения.

На этапе компиляции, пока известна информация о типах, компилятор вызывает instanceof и добавляет каст из Object в параметризированный тип, чтобы после стирания типов код мог работать.