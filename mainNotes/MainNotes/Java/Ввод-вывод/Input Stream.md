Более абстрактный класс для работы с InputStream. Обычно для работы используются другие, которые наследуются от InputStream, т.е. пишется обертка над ним.
![[Pasted image 20240926191434.png]]
- read - читает 1 байт. т.е. мы либо получаем значение этого байта, либо -1, если поток байт закончился. Это блокирующая операция, т.е. с файлами такой проблемы не будет, т.к. файл всегда мы можем читать без каких-либо задержек, а вот в случае с интернет соединением поток, который вызвал чтения заблокируется, пока в InputStream кто-нибудь не передаст данные.
- read(byte[] b) - здесь мы передаем массив, в который при чтении будут записываться байты. 
- read(byte[] b, offset, length) - если хотим выбрать кусочек массива, в который писать

![[Pasted image 20240926191721.png]]

![[Pasted image 20240926191925.png]]
- FileInputStream - обычно используется для чтения байтов из файла. Именно байтов! Если нужны символы, то нужно использовать ридеры. Но на практике рекомендуют использовать BufferedInputStream.
- ByteArrayInputStream - если у нас есть код, который ожидает InputStream из которого он будет хотеть считывать данные, а у нас в оперативной памяти есть массив байт, то мы можем обернуть этот массив байт ByteArrayInputStream-ом и передать его в этот код. И тогда код будет работать как будто с InputStream. Это прикольно, потому что становится без разницы откуда пришли данные.
- BufferedInputStream - оборачивает FileInputStream(т.е. new BufferedINputStream(new FileInputStream())). Лучше FileInputStream тем, что он на уровне Java создает некоторый буфер. Т.е. когда мы просим прочитать 1 байт, то он на самом деле читает больше байт. И потом, когда мы продолжаем читать он нам из этого буфера отдает данные. Размер буфера можно задать. Это может быть намного быстрее, так как обычный метод read при каждом вызове обращался бы к ОС для того, чтобы сделать системнйы вызов и считать байт. Но если мы читаем readAllBytes, то особой разницы не будет.
- DataInputStream - имеет вспомогательные методы. Такие как прочитать Int, String, Double и т.д. Есть его аналог DataOutputStream, который наоборот записывает различные типы данных в файл в бинарном виде. И если мы в одном порядке записали данные различныз типов с помощью DataOutputStream, то при чтении этого файла, используя DataInputStream мы получим значения этих переменных, которые записали.

### Работа с внешними ресурсами
При работе с файлами мы пользуемся внешними ресурсами - ресурсами операционной системы. Эти ресурсы у ОС не бесконечные. Поэтому файлы надо закрывать.
![[Pasted image 20240926193827.png]]

Так делать неправильно, т.к. read мог вызвать исключение и тогда f.close не вызвался бы.
![[Pasted image 20240926194243.png]]
Лучше использовать try with resource.