ThreadPool - пул потоков представляет собой список потоков, которые уже созданы и готовы к использованию. Это обеспечивает увеличение производительности, поскольку не нужно создавать потоки, а они созданы в начале. 

ThreadPools можно разделить на 2 вида по логике выполнения задач. Первый - это ThreadPoolExecutor, а второй - это ForkJoinPool. Если кратко, то разницами между ними в том, что в случае ForkJoinPool у каждого threada своя очередь задач и если thread выполнил все задачи в своей очереди, то он может украсть задачу из очередь другого потока. А в ThreadPoolExecutor есть общая очередь задач и планировщик сам выбирает поток, который будет выполнять задачу, т.е. нет такого, что поток сам решил выбрать себе задачу. Более подробно можно почитать в [[WorkStealingPool vs ThreadPoolExecutor]]

### ThreadPoolExecutor

![[Pasted image 20240925235901.png]]
ThreadPoolExecutor - класс, который реализует интерфейс ExecutorService. ExecutorService - механизм для управления потоками и выполнения каких-то задач асинхронно. Он упрощает за нас создание потоков и их установку. Под капотом ExecutorService хранит набор потоков - ThreadPool. И эти потоки переиспользуются внутри для выполнения поступаемых задач. Т.е. внутри ExecutorService есть еще очередь задач. Задачи поступают в очередь. Когда какой-то поток освободился, то он проверяет, нет ли задачи в очереди задач. Если нет, то продолжает ожидать, а если есть, то берет на выполнение. Если нет свободного потока, то задача продолжает лежать в очереди задач, пока не появится свободный поток в пуле потоков.

 Можно задавать размер тредпула(максимум потоков, минимум или чтобы было ровно столько-то потоков, можно задавать timeout жизни, например, если поток не был активен 30 сек, то уничтожить поток, чтобы не использовать ресурсы системы). Пул - это на самом деле паттерн! Он активно используется в том случае, если создание объекта - какая-то дорогостоящая операция и проще его сохранить, чтобы другие переиспользовали, а не создавали новый объект. Это часто используется для хранения соединения с БД. Например, в Spring используется HikariPool, и когда мы делаем запрос к БД, то не создается новое соединение, а используется соединение из HikariPool.

### Виды ExecutorService
Для создания различных ExecutorServic-ов используется Executors. Например, можем создать Executors.newFixedThreadPool(size).
- newFixedThreadPool - тред пул с ограниченным числом потоков, которое мы передали при его создании.
- cachedThreadPool - подходит для задач, когда есть неравномерная загрузка. Он может увеличивать количество потоков, которое есть в пуле. Если пришла задача, а потоков свободных нет, то создается новый поток.
- singleThreadExecutor - тред пул из одного потока. Полезно, когда задачи нужно выполнять в том порядке, в котором они пришли. Когда мы используем другие виды пулов, то мы не можем гарантировать, что задачи выполнятся в том порядке, в котором пришли, поскольку одна задача могла отправиться на 1 поток, другая на другой и какая-то из них могла выполниться быстрее другой.
- scheduledThreadPoolExecutor - особенностью является то, что когда мы отправляем какую-то задачу в ExecutorService, то она не сразу выполняется, а через какую-то временную задержку, которую мы сами указываем.
- workStealingPool - под капотом работает не на ThreadPoolExecutor, а на ForkJoinPool-е. У него другой механизм. У каждого потока есть своя очередь задач. И каждый поток выполняет свои задачи. НО, если поток закончил выполнять все свои задачи из очереди, то он может украсть задачу у другого потока и выполнить ее вместо него. Но не так часто используется в разработке.


### Иерархия 
Есть интерфейс Executor. У него есть метод execute, которые по сути и будет заниматься тем, чтобы выполнить ту команду, которую нам передали в Runnable. 
![[Pasted image 20241024173205.png]]
ExecutorService - интерфейс, который наследуется от интерфейса Executor.
Добавляем метода submit для добавления задачи и возвращения Future и другие методы.

И у ExecutorService есть множество реализаций, которые мы можем получить, используя статические методы Executors(фабричные). Но под капотом фабричные методы используют 3 реализации ExecutorService и создают их через new. 
Три основные реализации - ThreadPoolExecutor, ScheduledThreadPoolExecutor, ForkJoinPool(work-stealing стратегия)

Для запоминания Fork - разделили и выполняем задачи, а потом JOIN соединили задачи.

### [[ForkJoinPool]] - важный Pool, который используется в [[CompletableFuture]] и в Stream.parallel()