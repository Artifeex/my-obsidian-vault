### Проблемы обычных потоков
Проблема обычных потоков - они дорогостоящие. Базовый Java Thread - это обертка над потоком операционной системы. Каждый такой поток - это достаточно тяжелый ресурс, который в среднем занимает 1мб памяти. Поэтому мы сильно ограничены в создании большого количества нативных потоков. 
Но зачем нам большое количество потоков? Большое количество потоков полезно, когда мы разрабатываем серверное приложение, где каждый запрос обрабатывается своим потоком. И чтобы увеличить пропускную способность нашего приложения(количество запросов в секунду) мы должны увеличивать количество потоков нашего приложения. И вот создать даже 100000 нативных потоков и не получить OutOfMemory - это нужно хорошее железно.

Но это еще не все. Зачастую в наших серверных приложениях потоки мало нагружены и по большей части они просто ожидают различные блокирующие операции(обращение к другому веб-серверу или запись/чтение в БД). И таким образом, создавать тяжеловесный поток, который по факту все свое рабочее время простаивал - также расточительная трата ресурсов.
### Какие есть решения ? 
Писать асинхронный код. Когда к нам приходит запрос, то мы его начинает обрабатывать, а потом блокирующие операции уже выполняем асинхронно(используя инструменты CompletableFuture, RxJava, WebFlux). И пока эти операции выполняются, наш поток не блокируется и может обработать другие запросы и обрабатывать их также асинхронно. А когда блокирующая операция завершила свое выполнение(это можно понять, например, когда в socket пришли байты), то наш поток уже может выполнить действие, которое использует данные, полученные из асинхронной операции(тут мы часто пишем callback функции, которые исполнятся, когда асинхронный код выполнится). 
Но у этого подхода есть проблема:
Асинхронный код сложнее писать, тестировать и дебажить. 
### Виртуальные потоки приходят на помощь
Виртуальная потоки собрали в себе мощь асинхронного подхода, при этом код мы пишем в стандартном(синхронном) стиле! 
Мы можем создавать огромное количество виртуальных потоков для наших задач. За счет чего достигается? Это достигается благодаря тому, что виртуальный поток != поток операционной системы. Виртуальные потоки во время исполнения привязываются к реальному потоку операционной системы и выполняются на нем. 
Виртуальный поток можно считать кодом, который будет выполнен потоком ОС. 

Благодаря их легковесности(т.к. это не поток ОС, который тяжеловесный) мы можем создавать огромное количество виртуальных потоков. 

Для виртуальных потоков поверх Java написан свой sheduler, который маппит виртуальный поток на поток ОС во время его работы. И самое крутое то, что, когда виртуальный поток начинает выполнять блокирующую операцию, то он НЕ блокирует поток ОС на котором исполняется, а вместо этого sheduler сохраняет контекст(thread stack переменные) виртуального потока в heap memory! А тот поток ОС, на котором исполнялся виртуальный поток - освобождается и теперь sheduler может передать ему в исполнение уже другой виртуальный поток, который готов выполняться и не заблокирован! А когда заблокированный виртуальны поток разблокируется, то sheduler восстановит его состояние на момент блокировку, используя контекст из heap memory и передаст его на выполнение потоку ОС.

Таким образом, мы в серверных приложениях можем для каждого нового пользовательского запроса создавать виртуальный поток, который начнет его обрабатывать и в момент, когда произойдет блокирующая операция(а таких, наверное, большинство в серверных приложениях), то наш поток ОС, теперь готов обрабатывать новый запрос от пользователя. Этим мы можем увеличить производительность приложения во много раз, потому что, например, если обработка 1 пользовательского запроса занимает 1 сек(из которых 90% времени - это блокирующая операция) и мы для каждого пользовательского запроса используем свой поток, то мы сильно ограничены количеством потоков ОС, которые может поддерживать машина, на которой крутится сервер. Например, мы можем позволить себе 1000 потоков и поэтому в 1 секунду мы максимум сможем обработать 1000 запросов. Но, если мы можем использовать виртуальные потоки для запросов, а виртуальных потоков можно создать на порядки больше, чем потоков ОС, то мы можем получить возможность обрабатывать, например, 100к запросов в секунду, создав 100к виртуальных потоков.

Виртуальные потоки Java позволяют разработчикам достичь две цели: значительно увеличить количество потоков, при этом сохранив преимущества синхронного программирования (понятный код, удобная отладка и профилирование). Виртуальные потоки не привязаны к потокам ОС на протяжение всего жизненного цикла кода. Они занимают поток ОС только на время выполнения определенных вычислений, т.е. сразу несколько виртуальных потоков могут одновременно работать с одним потоком ОС.

Количество виртуальных потоков практически не ограничено. В условиях, когда программе нужно выполнить одновременно 10 000 задач, можно создать только 200 потоков ОС, что дает пропускную способность 200 запросов/с. При этом можно создать 10 000 виртуальных потоков, и тогда пропускная способность увеличится до 10 000 запросов/с. С увеличением количества задач можно увеличивать и количество виртуальных потоков, что позволяет эффективно масштабировать приложение без увеличения нагрузки на аппаратное обеспечение.

Пример создания виртуальных потоков:
```java
void handle(Request request, Response response) {
    var url1 = ...
    var url2 = ...
 
    try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
        var future1 = executor.submit(() -> fetchURL(url1));
        var future2 = executor.submit(() -> fetchURL(url2));
        response.send(future1.get() + future2.get());
    } catch (ExecutionException | InterruptedException e) {
        response.fail(e);
    }
}
```

### Некоторые дополнительные факты
Не нужно создавать pool виртуальных потоков! Они специально были сделаны легковесными, чтобы их было быстро создавать и удалять. Pool-ы нужны для тяжеловесных ресурсов - таких как потоки ОС.

Ситуации, в которых виртуальный поток, который начал выполнять блокирующую операцию не сможет открепиться от потока ОС, на котором он исполняется(и тем самым заблокируется как виртуальный поток, так и поток ОС):
1. Когда блокирующий код находится внутри synhcronized блока
2. Когда вызывается нативный метод.

Виртуальный потоки - не быстрее потоков ОС. Они сделаны не для того, чтобы ускорить исполнение программы, а для увеличения пропускной способности программы! Например: если у нас при обработке запросов нет никакой блокирующей операции, где поток просто простаивает и ждет, а где поток сам выполняет какое-то действие, например, вычисляет что-нибудь математическое, то тут плюсов от виртуальных потоков не будет, т.к. в любом случае поток ОС должен будет выполнять этот код и нет никакого простаивания и ожидания. 

В виртуальных потоках доступны TheadLocal переменные, но не стоит класть в них какие-то тяжеловесные объекты, поскольку виртуальные потоки за время своей жизни будут постоянно привязываться и отвязываться от потока ОС, на котором они исполняются и будет происходить сохранение ThreadLocal переменных в heap и их восстановление из heap. А также мы собираемся создавать их тысячами, поэтому сохранение тяжелые объектов в ThreadLocal переменных, скорее всего, приведет к плохой производительности. 

Виртуальные потоки не привязываются к какому-то конкретному потоку ОС. Т.е. когда поток создался, он может исполняться на потоке "А", потом ушел в блокировку, отвязался от потока "А". Когда блокировка закончилась, то sheduler его распределил на какой-то из доступных потоков ОС и это может быть поток "Б".

Разработчики виртуальных потоков создали по сути Virtual Sheduler, который занимается распределением виртуальных потоков по потокам ОС, а потоки ОС уже выполняется и распределяются по ядрам процессора, используя sheduler операционной системы. Т.е. у нас во время работы программы работают два шедулера.

Project Loom — это **инициатива для улучшения многопоточности и асинхронного программирования в Java**. Основная цель — упрощение работы с потоками, что позволит создавать более эффективные и понятные приложения. Их детищем стали виртуальные потоки, добавленные с Java 21(точнее они в 19 в пре ревью были, где можно было ими воспользоваться и разработчики получили обратную связь, а потом уже на основе нее полноценно выкатили вирт. потоки в 21 java).