### Race Condition
![[Pasted image 20240925214909.png]]
Проблема заключается в том, что если потоки выполнятся в одном порядке(так их распределит алгоритм в ОС), то мы получим 1 результат, а если в каком-то другом порядке, то другой результат. Результат не должен зависеть от порядке выполнения потоков.
![[Pasted image 20240925215223.png]]
В таком случае получим х=11, но это неправильно, должно было получиться 12.

Если же поток 1 прочитал значение х после того, как поток 2 записал в х значение 11, то результат бы изменился и уже получилось бы х=12.
![[Pasted image 20240925215643.png]]
Таким образом, от порядке выполнения потоков зависит результат операции.

Способы борьбы - любые виды синхронизации. [[Synchronized]], использование [[Atomic Types]], [[MainNotes/Java/Многопоточность/Оптимистические и пессимистические блокировки]], использование коллекций из java.util.concurent. 

### Deadlock
![[Pasted image 20240925232745.png]]
Есть два потока: Thread A и Thread B и они друг от друга зависят. Т.е. они ожидают ресурс, который захвачен другим потоком. Thread A захватил ресурс, но ему нужен еще один, он пытается его получить, а этот другой ресурс захватил Thread B, таким образом, Thread A заблокировался. И аналогично Thread B захватил ресурс, но ему нужен ресурс, который захватил Thread A.
![[Pasted image 20240925233011.png]]
Для возникновения такой ситуации нужно именно пессимистическая блокировка! 

Как избежать ? 
1. Не использовать вложенных блокировок. Если поток всегда захватывает 1 ресурс, то такой проблемы не будет. 
2. Отсортировать блокировки и брать их в отсортированном порядке. Тогда бы в нашем случае оба потока пытались бы захватить res1, один из них бы захватил, второй бы заблокировался и ждал, пока освободится res1. Тогда первый поток взял бы res2, который уже никто не захватывает, т.к. блокировки по порядку у всех потоков и все, кто хотели res2, сначала должны получить res1.
3. Использовать timeout на то, сколько поток ждет, чтобы захватить блокировку. И если по истечение этого времени данную блокировку захватить не удалось, то поток отказывается от всех блокировок, которые он получил и пытается по новой захватить все ресурсы. Тогда другой поток, который пытается захватить ресурс наконец-то сможет захватить ресурс и выполнить то, что задумал. Например, для этого используется [[ReentrantLock]].