Пессимистические блокировки в PostgreSQL позволяют контролировать доступ к данным при выполнении транзакций, чтобы избежать конфликтов при параллельной работе. Они обеспечивают гарантию, что данные не будут изменены другими транзакциями до завершения текущей транзакции.

В PostgreSQL можно блокировать различные объекты (строки, таблицы и т.д.) с использованием различных типов блокировок. Разберём основные механизмы пессимистических блокировок в PostgreSQL, типы блокировок, и для каких операций они используются.

### Типы блокировок в PostgreSQL

В PostgreSQL используется несколько видов блокировок для управления доступом к данным. Основные типы, которые могут применяться в пессимистических блокировках:

1. **Row-level locks (строчные блокировки)**
   - Эти блокировки накладываются на отдельные строки в таблице. Они используются для предотвращения конфликтов при изменении или чтении данных на уровне строк.
   
   **Типы строчных блокировок:**
   - `FOR UPDATE`: эксклюзивная блокировка на строку. Она блокирует строку от любых изменений и чтения другими транзакциями, пока текущая транзакция не завершена.
   - `FOR NO KEY UPDATE`: эксклюзивная блокировка, аналогичная `FOR UPDATE`, но не блокирует ключи (например, индексные поля), а только остальные колонки.
   - `FOR SHARE`: блокирует строку для изменений, но разрешает другим транзакциям читать данные. Она позволяет другим транзакциям захватывать только разделяемые блокировки.
   - `FOR KEY SHARE`: более мягкая блокировка по сравнению с `FOR SHARE`. Она разрешает изменения строки, если ключи (индексируемые поля) остаются неизменными.

2. **Table-level locks (табличные блокировки)**
   - Эти блокировки накладываются на всю таблицу. В зависимости от типа блокировки, другие транзакции могут быть ограничены в чтении или записи в таблицу.
   
   **Типы табличных блокировок:**
   - `ACCESS SHARE`: самая слабая блокировка, которая позволяет другим транзакциям читать таблицу, но блокирует изменения (используется при операциях SELECT).
   - `ROW SHARE`: блокирует другие транзакции от выполнения операций, изменяющих структуру таблицы (например, `ALTER TABLE`), но разрешает обычные операции записи.
   - `EXCLUSIVE`: блокирует любые изменения таблицы, но разрешает чтение.
   - `ACCESS EXCLUSIVE`: самая строгая блокировка, блокирующая любые операции — как чтение, так и запись в таблицу. Применяется для изменения структуры таблицы, например, при выполнении `ALTER TABLE`.

### Пессимистические блокировки на уровне строк

В большинстве случаев, в реальных приложениях чаще всего используются пессимистические блокировки на уровне строк, так как они более тонкие и не блокируют всю таблицу целиком. Эти блокировки применяются в SQL-запросах с модификатором `SELECT ... FOR <LOCK MODE>`.

#### Основные типы строчных блокировок и их примеры:

1. **`FOR UPDATE`** — эксклюзивная блокировка строки. Она используется для сценариев, когда нужно гарантировать, что строка не будет изменена другими транзакциями, пока не завершена текущая транзакция.

   Пример:
   ```sql
   BEGIN;
   SELECT * FROM employees WHERE id = 1 FOR UPDATE;
   -- Теперь строка с id=1 заблокирована от изменений другими транзакциями
   UPDATE employees SET salary = salary + 1000 WHERE id = 1;
   COMMIT;
   ```
   В этом примере строка с `id = 1` блокируется для других транзакций. Другие транзакции не смогут изменить или заблокировать эту строку, пока текущая транзакция не завершится.

2. **`FOR NO KEY UPDATE`** — эксклюзивная блокировка, которая блокирует строку от изменений, но разрешает изменение индексируемых полей.

   Пример:
   ```sql
   BEGIN;
   SELECT * FROM orders WHERE order_id = 123 FOR NO KEY UPDATE;
   -- Другие транзакции могут менять ключевые поля, но не основные данные строки
   COMMIT;
   ```

3. **`FOR SHARE`** — разделяемая блокировка строки. Позволяет другим транзакциям также захватывать разделяемую блокировку, но блокирует изменения строки.

   Пример:
   ```sql
   BEGIN;
   SELECT * FROM projects WHERE project_id = 10 FOR SHARE;
   -- Другие транзакции могут также выполнять FOR SHARE, но не могут изменить строку
   COMMIT;
   ```
   Это полезно, когда несколько транзакций хотят читать одни и те же данные, но нужно предотвратить их изменение.

4. **`FOR KEY SHARE`** — более мягкая блокировка, чем `FOR SHARE`. Разрешает другим транзакциям изменять поля, не являющиеся ключами.

   Пример:
   ```sql
   BEGIN;
   SELECT * FROM employees WHERE department_id = 10 FOR KEY SHARE;
   -- Можно изменять неключевые поля в строке
   COMMIT;
   ```

### Пессимистические блокировки на уровне таблиц

Иногда может потребоваться блокировка всей таблицы, чтобы обеспечить согласованность данных на более высоком уровне, например, при изменении структуры таблицы или массовом обновлении данных. Табличные блокировки обеспечиваются через команду `LOCK TABLE`.

#### Пример:

```sql
BEGIN;
LOCK TABLE employees IN ACCESS EXCLUSIVE MODE;
-- Любая операция на таблице employees будет заблокирована
ALTER TABLE employees ADD COLUMN department_id INT;
COMMIT;
```

Этот пример накладывает блокировку `ACCESS EXCLUSIVE`, которая блокирует любые операции с таблицей `employees` до завершения транзакции. Этот тип блокировки используется при изменении структуры таблицы (например, `ALTER TABLE`).

### Когда и какие блокировки использовать?

1. **`FOR UPDATE` и `FOR NO KEY UPDATE`**:
   - Используйте, когда нужно защитить строку от изменений другими транзакциями. Подходит для сценариев, когда вы собираетесь обновить строку в дальнейшем.
   - Пример: вы загружаете данные о сотруднике для последующего обновления зарплаты.

2. **`FOR SHARE` и `FOR KEY SHARE`**:
   - Используйте, когда нужно защитить строку от изменений, но не требуется её обновлять. Подходит для сценариев, когда требуется прочитать данные для справки, но важно, чтобы они не изменялись в процессе.
   - Пример: вы загружаете информацию о проекте для генерации отчёта.

3. **Табличные блокировки (`LOCK TABLE`)**:
   - Применяются в редких случаях, когда необходимо заблокировать всю таблицу, чтобы избежать конфликтов при изменении её структуры или при массовом обновлении данных.
   - Пример: изменение структуры таблицы (добавление, удаление столбцов).

### Возможные проблемы с пессимистическими блокировками

1. **Блокировка ресурсов**: При долгих транзакциях блокировки могут удерживаться на протяжении длительного времени, что может снижать производительность системы, особенно если другие транзакции пытаются получить доступ к тем же данным.
   
2. **Взаимоблокировки (Deadlocks)**: Могут возникнуть ситуации, когда две транзакции ждут друг друга, пытаясь захватить блокировки на различные строки или таблицы. PostgreSQL умеет обнаруживать взаимоблокировки и завершать одну из транзакций.

3. **Задержки и блокировки запросов**: Если одна транзакция удерживает блокировку на данные, другие транзакции, которые хотят получить доступ к тем же данным, будут ожидать завершения первой транзакции. Это может привести к задержкам или даже тайм-аутам.

### Итог

Пессимистические блокировки в PostgreSQL используются для защиты данных от изменений другими транзакциями и могут быть наложены как на строки, так и на таблицы. При правильном использовании они обеспечивают согласованность данных, но требуют осторожного подхода, так как могут снизить производительность и вызвать взаимоблокировки.