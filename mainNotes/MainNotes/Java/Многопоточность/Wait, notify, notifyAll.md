Методы, которые мы получаем из класса Object. 
Вызываем эти методы на объекте, монитор которого мы захватили, т.е. внутри synchronized секции. 
Если мы вызовем вне synchonized блока, то получим исключение.
```java
public class WaitExample {
    public static void main(String[] args) {
        Object data = new Object();
        
        // Неправильный вызов
        data.wait();  // IllegalMonitorStateException
    }
}

```
Методы `wait()`, `notify()`, и `notifyAll()` — это методы класса `Object` в Java, которые используются для управления синхронизацией между потоками. Эти методы реализуют механизм **межпотоковой коммуникации** (inter-thread communication), позволяя потокам взаимодействовать друг с другом, например, чтобы один поток мог ожидать, пока другой поток не завершит какую-то работу.

### Основные моменты

- Эти методы **могут быть вызваны только из синхронизированного блока** или метода. Это гарантирует, что они будут использовать монитор объекта, на котором вызываются.
- Каждый объект в Java имеет монитор, и эти методы работают с монитором объекта, чтобы координировать потоки.

### 1. **Метод `wait()`**
Метод `wait()` приостанавливает выполнение текущего потока и освобождает монитор объекта, на котором был вызван этот метод, позволяя другим потокам захватывать его. Поток будет **ожидать уведомления**, чтобы продолжить выполнение.

#### Синтаксис:
```java
public final void wait() throws InterruptedException
```

- Когда поток вызывает `wait()`, он **приостанавливает выполнение** до тех пор, пока другой поток не вызовет `notify()` или `notifyAll()` на том же объекте.
- После вызова `wait()` поток **освобождает монитор** объекта, что позволяет другим потокам захватывать монитор и работать с объектом.
- Поток может быть **пробужден** другими потоками, либо когда он получает уведомление через `notify()`, либо при завершении операции ожидания по тайм-ауту (если используется `wait(long timeout)`).

#### Пример использования:
```java
public class WaitExample {
    private static final Object lock = new Object();
    
    public static void main(String[] args) {
        Thread waiter = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("Поток ожидает...");
                    lock.wait(); // Поток ждет уведомления
                    System.out.println("Поток пробужден!");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        Thread notifier = new Thread(() -> {
            synchronized (lock) {
                try {
                    Thread.sleep(2000); // Ждем 2 секунды перед уведомлением
                    lock.notify(); // Уведомляем поток
                    System.out.println("Уведомление отправлено!");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        waiter.start();
        notifier.start();
    }
}
```

### Как это работает:

1. Поток захватывает монитор через синхронизацию (например, в `synchronized` блоке).
2. Поток вызывает `wait(long timeout)` и приостанавливается. Монитор объекта в это время освобождается, и другие потоки могут захватить его.
3. Поток либо пробуждается через уведомление (`notify()` или `notifyAll()`), либо выходит из `wait()` после истечения времени ожидания.
4. После выхода из `wait()`, поток снова **пытается захватить монитор** объекта для продолжения работы в критической секции. Если монитор занят, поток будет ждать, пока он не станет доступным.

### 2. **Метод `notify()`**
Метод `notify()` пробуждает **один поток**, который находится в ожидании на этом объекте. Если несколько потоков ждут на одном объекте, только **один** из них будет пробужден.

#### Синтаксис:
```java
public final void notify()
```

- Поток, вызвавший `notify()`, не освобождает монитор сразу, а только после того, как выходит из синхронизированного блока или метода.
- Поток, который будет пробужден, будет продолжать выполнение, как только получит монитор, если другие потоки продолжают использовать объект.

#### Пример:
```java
public class NotifyExample {
    private static final Object lock = new Object();
    
    public static void main(String[] args) {
        Thread waiter = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("Поток ожидает...");
                    lock.wait(); // Поток ждет уведомления
                    System.out.println("Поток пробужден!");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        Thread notifier = new Thread(() -> {
            synchronized (lock) {
                try {
                    Thread.sleep(2000); // Ждем 2 секунды перед уведомлением
                    lock.notify(); // Уведомляем один поток
                    System.out.println("Уведомление отправлено!");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        waiter.start();
        notifier.start();
    }
}
```

### 3. **Метод `notifyAll()`**
Метод `notifyAll()` пробуждает **все потоки**, которые находятся в ожидании на объекте. Все потоки, ожидающие на объекте, становятся доступными для исполнения, но они будут ожидать, пока не получат монитор объекта.

#### Синтаксис:
```java
public final void notifyAll()
```

- В отличие от `notify()`, который пробуждает только один поток, `notifyAll()` пробуждает все потоки, ожидающие на объекте.
- После пробуждения, потоки будут соревноваться за получение монитора объекта.

#### Пример:
```java
public class NotifyAllExample {
    private static final Object lock = new Object();
    
    public static void main(String[] args) {
        Thread waiter1 = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("Поток 1 ожидает...");
                    lock.wait(); // Поток 1 ждет уведомления
                    System.out.println("Поток 1 пробужден!");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        Thread waiter2 = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("Поток 2 ожидает...");
                    lock.wait(); // Поток 2 ждет уведомления
                    System.out.println("Поток 2 пробужден!");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        Thread notifier = new Thread(() -> {
            synchronized (lock) {
                try {
                    Thread.sleep(2000); // Ждем 2 секунды перед уведомлением
                    lock.notifyAll(); // Уведомляем все потоки
                    System.out.println("Уведомления отправлены!");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        waiter1.start();
        waiter2.start();
        notifier.start();
    }
}
```

### Важные моменты:

1. **Монитор объекта**: Все эти методы (и `wait()`, и `notify()`, и `notifyAll()`) должны быть вызваны внутри синхронизированного блока (`synchronized`), потому что они работают с монитором объекта. Это важно для того, чтобы гарантировать, что два потока не будут одновременно пытаться изменить состояние объекта.
   
2. **Состояние ожидания**: Потоки, вызвавшие `wait()`, переходят в **состояние ожидания** и остаются в этом состоянии до тех пор, пока не будут пробуждены другим потоком. Когда поток пробуждается, он должен снова захватить монитор, прежде чем продолжить выполнение.

3. **Использование с `InterruptedException`**: Метод `wait()` может выбросить исключение `InterruptedException`, если поток был прерван во время ожидания, поэтому вызов `wait()` всегда должен быть окружен обработкой этого исключения.

4. **Сигналы и уведомления**: Взаимодействие между потоками с использованием `wait()`, `notify()` и `notifyAll()` может быть довольно сложным, так как порядок пробуждения потоков и синхронизация требуют осторожности. Например, важно удостовериться, что потоки правильно уведомляются, и не будет ситуации, когда поток продолжит выполнение без выполнения необходимой работы.

### Заключение
Методы `wait()`, `notify()` и `notifyAll()` предоставляют средства для синхронизации потоков и позволяют им обмениваться информацией о состоянии. Эти методы особенно полезны при реализации **производитель-потребитель** или других многопоточных паттернов, где потоки должны работать в тесной координации.