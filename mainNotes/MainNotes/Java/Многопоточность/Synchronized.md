![[Pasted image 20240925205907.png]]
Только один поток может войти в критическую секцию!
3 способа использования synchronized:
1. synchronized блок. Когда потом дойдет до этого блока, то он захватит монитор объекта, который был передан внутрь synchronized(object). Пока потом не выйдет из критической секции ни один другой поток не сможет выйти в эту же критическую секцию по этому же объекту(из-за того, что захвачен монитор). Потоки будут ожидать, пока не будет отпущен монитор объекта. Если же в другом потоке в synchonized(object2) был передан другой какой-то объект object2, то никаких проблем не будет, поток спокойно зайдет, поскольку мы проверяем захвачен ли монитор уже у другого объекта.
2. synchronized указан в методе. Тогда в качестве монитора будет использоваться this. Т.е. сам объект, на котором был вызван данный synchroinized метод. И если два потока вызовут этот метод на одном и том же объекте, то первый, кто успеет захватить монитор - будет выполняться, а второй будет ждать. 
   И важно то, что если даже вызовется другой метод этого объекта, который также помечен synchronized, то если монитор захвачен другим потоком(даже в другом методе), то мы заблокируемся и будем ожидать.
3. synchronized указан в статическом методе. В таком случае в качестве монитора будет использован .class нашего объекта, т.к. нет никакого объекта(static метод). И таким образом, нельзя будет вызвать два статических синхронизированных метода одного и того же класса в разных потоках, т.к. один из потоков захватит монитор .class объекта.

