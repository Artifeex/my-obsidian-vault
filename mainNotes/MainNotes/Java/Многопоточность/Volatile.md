Данное ключевое слово отключает все оптимизации.
![[Pasted image 20240925211022.png]]
Volatile указывается у переменной. Без volatile у нас есть значение х = 10. Затем мы в потоке 1 изменяем это значение на 15. Второй поток читает значение х и не видит изменения, которые сделал поток 1. Это связанно с различными оптимизациями, которые выполняются. Например, поток 1 мог записать значения не в оперативную память, а себе в кэш ядра процессора. Или наоборот поток 2 мог читать не из оперативной памяти, а прочитать значение из своего кэша ядра.

Таким образом, volatile дает гарантию, что изменения, которые мы выполнили над переменной будут видны.

volatile не дает гарантии атомарности. Например, операция инкремента - не является атомарной. Она состоит из 3-х операций: чтение из памяти, инкремент, запись в память. И в любой момент может вклиниться другой поток, который также возьмет значение переменной, а наш поток еще не успел загрузить в память обновленное значение и получается, что другой поток также сделает инкремент, но при этом значение переменной увеличится только на 1, а не на два, несмотря на то, что было вызвано два инкремента. С этим нам помогают [[Atomic Types]].