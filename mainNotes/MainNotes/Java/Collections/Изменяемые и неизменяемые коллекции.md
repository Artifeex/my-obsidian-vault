В Java коллекции могут быть как изменяемыми (mutable), так и неизменяемыми (immutable). **Изменяемая коллекция** позволяет добавлять, удалять или изменять элементы после её создания. **Неизменяемая коллекция** — это такая коллекция, которая не может быть изменена после создания: любые попытки изменить её структуру приводят к ошибке.

### Изменяемые коллекции

Изменяемые коллекции позволяют выполнять такие операции, как добавление (`add`), удаление (`remove`) и изменение (`set`) элементов. 

Примеры изменяемых коллекций:
- **`ArrayList`**, **`LinkedList`**, **`HashSet`**, **`HashMap`** и т. д.
- Коллекции, созданные с помощью методов `Collections.synchronizedList` или `Collections.synchronizedSet`, также изменяемы, хотя и синхронизированы для многопоточного доступа.

#### Пример создания изменяемой коллекции:
```java
List<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
list.set(1, "C++"); // Можно изменить элемент
```

### Неизменяемые коллекции

Неизменяемые коллекции не позволяют изменять свой состав после создания. Все методы изменения структуры коллекции (например, `add`, `remove`, `clear`) либо недоступны, либо выбрасывают исключения (`UnsupportedOperationException`). 

#### Варианты создания неизменяемых коллекций

1. **С помощью `Collections.unmodifiable*` методов**

   Метод `Collections.unmodifiableList`, `Collections.unmodifiableSet`, и т. д., возвращает неизменяемый "вид" исходной коллекции. Такой вид позволяет безопасно передать коллекцию в код, которому не должно быть разрешено её изменять.

   ```java
   List<String> mutableList = new ArrayList<>();
   mutableList.add("Java");
   List<String> immutableList = Collections.unmodifiableList(mutableList);

   // immutableList.add("Python"); // Выбросит UnsupportedOperationException
   ```

   > **Замечание**: если исходная коллекция (`mutableList`) изменится, эти изменения отразятся и в `immutableList`, поскольку `unmodifiableList` лишь создаёт обёртку, но не копирует коллекцию.

2. **Методы `List.of`, `Set.of`, `Map.of` (Java 9+)**

   В Java 9 были добавлены методы `List.of`, `Set.of`, и `Map.of`, которые позволяют создать неизменяемую коллекцию. В отличие от `Collections.unmodifiableList`, эти методы создают настоящие копии и не позволяют изменять базовую коллекцию.

   ```java
   List<String> immutableList = List.of("Java", "Python", "C++");
   // immutableList.add("JavaScript"); // UnsupportedOperationException
   ```

3. **Stream API и `Collectors.toUnmodifiableList` (Java 10+)**

   В Java 10 также добавлены методы `Collectors.toUnmodifiableList`, `toUnmodifiableSet`, `toUnmodifiableMap`, которые позволяют создать неизменяемые коллекции из стрима.

   ```java
   List<String> immutableList = List.of("Java", "Python", "C++")
           .stream()
           .filter(s -> s.startsWith("J"))
           .collect(Collectors.toUnmodifiableList());
   ```

4. **`Immutable`-коллекции из сторонних библиотек**

   Например, Guava предлагает свои реализации неизменяемых коллекций (`ImmutableList`, `ImmutableSet`, и `ImmutableMap`). Они создаются с помощью методов, аналогичных фабричным методам из Java 9+, и также являются настоящими неизменяемыми коллекциями.

   ```java
   List<String> immutableList = ImmutableList.of("Java", "Python", "C++");
   ```

### Случаи, когда коллекция получается изменяемой или неизменяемой

- **Изменяемая коллекция** получается при использовании стандартных коллекций (например, `ArrayList`, `HashSet`), при добавлении новых элементов и доступе к ним через методы изменения (`add`, `remove` и др.). Она удобна, когда требуется добавлять или удалять элементы в процессе работы.

- **Неизменяемая коллекция** полезна в следующих случаях:
  - **Безопасность многопоточного доступа**. Неизменяемые коллекции не требуют дополнительной синхронизации.
  - **Сохранение целостности данных**. Если данные не должны изменяться после создания, неизменяемая коллекция защищает их от случайного изменения.
  - **Оптимизация памяти и производительности**. Неизменяемые коллекции могут потреблять меньше памяти, так как они не требуют поддержки структур для изменений, и иногда компилятор или JVM могут оптимизировать доступ к таким коллекциям.

### Сравнение изменяемых и неизменяемых коллекций

| Тип коллекции    | Примеры                     | Изменяемость  | Способ создания                                           |
|------------------|-----------------------------|---------------|-----------------------------------------------------------|
| **Изменяемая**   | `ArrayList`, `HashSet`      | Да           | Прямое создание объекта через конструктор                 |
| **Неизменяемая** | `Collections.unmodifiable*` | Нет          | Обертка `Collections.unmodifiable*` над изменяемой коллекцией |
| **Неизменяемая** | `List.of`, `Set.of`         | Нет          | С помощью фабричных методов Java 9+                       |
| **Неизменяемая** | `Collectors.toUnmodifiable*`| Нет          | Коллекторы в Stream API (Java 10+)                        |

### Заключение

Использование изменяемых или неизменяемых коллекций зависит от конкретных требований программы. Если коллекция должна изменяться в ходе выполнения, подходят изменяемые коллекции. Если же коллекция должна быть неизменяемой для защиты данных или для многопоточного доступа, лучше использовать неизменяемую коллекцию.

Методы `copyOf`, добавленные в Java 10 для интерфейсов коллекций, таких как `List`, `Set` и `Map`, возвращают **неизменяемую копию** исходной коллекции. Это означает, что тип коллекции, который возвращается, соответствует интерфейсу, у которого вызван `copyOf`, но сама коллекция будет неизменяемой и не позволит изменять её структуру.

### Примеры использования `copyOf`

#### 1. **Список** (`List.copyOf`)

```java
List<String> originalList = new ArrayList<>(List.of("Java", "Python", "C++"));
List<String> copyList = List.copyOf(originalList);

// copyList.add("JavaScript"); // UnsupportedOperationException
```

Метод `List.copyOf` возвращает неизменяемую копию `originalList`, которая реализует интерфейс `List`. Любая попытка изменить `copyList`, например, добавить или удалить элементы, приведёт к исключению `UnsupportedOperationException`.

#### 2. **Множество** (`Set.copyOf`)

```java
Set<String> originalSet = new HashSet<>(Set.of("Apple", "Banana", "Orange"));
Set<String> copySet = Set.copyOf(originalSet);

// copySet.remove("Apple"); // UnsupportedOperationException
```

Здесь `Set.copyOf` возвращает неизменяемое множество, содержащее элементы из `originalSet`. Коллекция `copySet` также не допускает добавления или удаления элементов.

#### 3. **Карта** (`Map.copyOf`)

```java
Map<String, Integer> originalMap = new HashMap<>();
originalMap.put("one", 1);
originalMap.put("two", 2);

Map<String, Integer> copyMap = Map.copyOf(originalMap);

// copyMap.put("three", 3); // UnsupportedOperationException
```

Метод `Map.copyOf` создаёт неизменяемую карту, содержащую все элементы из `originalMap`. 

### Особенности и типы коллекций, возвращаемых `copyOf`

1. **Тип, соответствующий интерфейсу** — `copyOf` всегда возвращает коллекцию типа, соответствующего вызываемому интерфейсу (`List`, `Set` или `Map`).
2. **Неизменяемая коллекция** — результат вызова `copyOf` всегда неизменяемый.
3. **Отсутствие копирования при передаче неизменяемой коллекции** — если исходная коллекция уже неизменяема, `copyOf` вернёт её напрямую (без создания новой коллекции).
4. **Отсутствие `null`-элементов** — если коллекция или её элементы содержат `null`, метод `copyOf` выбросит `NullPointerException`.

### Заключение

Методы `copyOf` для `List`, `Set` и `Map` возвращают неизменяемые версии коллекций соответствующего интерфейса. Они полезны, когда требуется защитить исходную коллекцию от изменений или передать её для безопасного многопоточного доступа.


### Кратко
Неизменяемые в случае:
1. copyOf
2. of методов
Изменяемые когда создаем ручками через new.