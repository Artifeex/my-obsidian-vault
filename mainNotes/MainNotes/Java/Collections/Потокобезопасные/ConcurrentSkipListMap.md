Работает поверх [[SkipList]]
Чтение не блокирующее - работаем с копией данных на тот момент, когда начали читать.
Вставка - также не блокирующая, производится с помощью CAS.
Механизм **CAS (Compare-And-Swap)** в `ConcurrentSkipListMap` и `ConcurrentSkipListSet` используется для безопасного добавления элементов в многопоточной среде, избегая полной блокировки. В основе CAS лежит атомарная операция, которая сравнивает текущее значение ячейки с ожидаемым и, если они совпадают, заменяет его новым значением. В `ConcurrentSkipListMap` это используется для управления узлами, добавляя или изменяя ссылки между ними.

### Механизм добавления с помощью CAS

1. **Поиск позиции для вставки**:
   - Когда элемент добавляется в `ConcurrentSkipListMap`, сначала ищется позиция, на которую он должен быть помещен. Skip List состоит из нескольких уровней связанных списков, и добавляемый элемент должен быть вставлен в каждый уровень на свою позицию.
   - На каждом уровне коллекция проходит по узлам, начиная с "головы" (начального узла), пока не будет найден узел, в который элемент должен быть вставлен, сохраняя отсортированный порядок.

2. **Подготовка узла для вставки**:
   - После нахождения правильной позиции создается новый узел с добавляемым элементом. Узел формируется так, чтобы он мог быть встроен в каждый уровень списка Skip List, от самого нижнего до самого верхнего уровня, с возможностью "пропускать" уровни.
   
3. **CAS для вставки узла**:
   - Вставка узла происходит поэтапно. На каждом уровне CAS применяется к операциям на указателях (ссылках) узлов, которые указывают на следующую и предыдущую позицию.
   - Например, если новый узел `N` нужно вставить между узлами `A` и `B`, то сначала выполняется CAS, чтобы установить `A.next` на `N` вместо `B`, а затем CAS для ссылки `N.next`, указывающей на `B`.
   - Если параллельный поток за это время модифицировал ссылку (например, добавил другой узел), CAS обнаружит это, поскольку текущее значение ссылки будет уже другим, и операция вставки перезапустится.

4. **Повторная попытка при неудаче CAS**:
   - Если сравнение и замена не удаются (из-за того, что другой поток изменил структуру), то операция вставки перезапускается. Алгоритм возвращается к пункту поиска позиции, и процесс продолжается, пока вставка не пройдет успешно.
   - Это позволяет нескольким потокам одновременно безопасно модифицировать структуру, так как каждый поток проверяет актуальность ссылки перед изменением.

### Преимущества использования CAS для добавления

- **Отсутствие блокировок**: CAS позволяет добавлять элементы без полной блокировки коллекции, избегая так называемых "global locks" и делая добавление более масштабируемым.
  
- **Меньшее количество конфликтов**: CAS выполняется на уровне отдельных ссылок, что значительно снижает вероятность конфликтов между потоками и уменьшает время ожидания при параллельной вставке.
  
- **Автоматическое устранение гонок**: Если один поток видит, что другой поток успел изменить ссылку до него, CAS возвращает неудачный результат, и поток просто повторяет попытку. Это гарантирует, что только один поток завершит операцию вставки.

Таким образом, использование CAS позволяет `ConcurrentSkipListMap` и `ConcurrentSkipListSet` обрабатывать параллельные добавления эффективно, поддерживая консистентность структуры данных и обеспечивая потокобезопасность.

При чтении данных из `ConcurrentSkipListMap` **не создается копия данных** — используется прямая ссылка на элемент. Это важно для производительности и минимизации задержек: чтение по ключу в этой структуре, как и в других потокобезопасных коллекциях, реализовано так, чтобы предоставлять актуальные данные без излишних копий.

Однако **создание копии данных может происходить при работе с итераторами** или когда требуется создать моментальный "снимок" состояния коллекции. Вот как это работает в разных ситуациях:

1. **Чтение по ключу**:
   - Когда вы читаете значение по конкретному ключу (например, через метод `get(key)`), `ConcurrentSkipListMap` просто находит соответствующий узел и возвращает значение. 
   - **Копии не создается** — возвращается ссылка на существующий объект (если объект является изменяемым, он, конечно, не защищен от изменений после получения, поскольку сам объект не копируется).
   - Данная операция потокобезопасна, так как структура Skip List поддерживает актуальность ссылок даже при параллельных изменениях.

2. **Итераторы**:
   - Итераторы `ConcurrentSkipListMap` **устойчивы к изменениям** (не fail-fast, как у обычных коллекций). Они могут видеть элементы, добавленные или удаленные другими потоками, после их создания.
   - Вместе с тем, сами итераторы не создают полноценную копию всех данных в коллекции. Они используют текущие ссылки на элементы и таким образом могут видеть изменения, произошедшие после создания итератора. В этом смысле можно сказать, что итераторы дают "моментальный срез" на момент начала итерирования, но этот срез не зафиксирован, и он может обновляться, когда в коллекции происходят модификации.
  
3. **Создание "снимков" коллекции**:
   - Если необходимо получить статический снимок текущего состояния коллекции, можно использовать метод `clone()` или собрать элементы в другую коллекцию (например, через конструктор или метод `toArray`). В этом случае будет создана копия данных, но это не является частью обычного процесса чтения и используется только при необходимости.

Таким образом, **копии данных в `ConcurrentSkipListMap` не создаются при обычном чтении по ключу**. Копии могут быть созданы только в случае явного создания статического снимка данных или при сборе данных в другую коллекцию.