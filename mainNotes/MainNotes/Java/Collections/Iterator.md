**Итератор — объект, позволяющий перебирать элементы коллекции. Например foreach реализован с использованием итератора. Одним из ключевых методов интерфейса Collection является метод Iterator< E> iterator(). Он возвращает итератор — то есть объект, реализующий интерфейс Iterator.** Благодаря свойству Fail-fast и Fail-safe потокобезопасен, т.е. если другой какой-то поток изменить коллекцию, то в случае fail-fast у нас будет exception, а в случае fail-safe мы не упадем, но можем работать со снимком коллекции, которая была в тот момент, когда мы создали итератор.

### Fail-fast и Fail-safe
Определяет, как реализованный итереатор(а мы можем писать разные реализации) поведет себя при изменении коллекции. В начальный момент времени итератор не на что не указывает, чтобы он стал указывать на первый элемент в коллекции нужно вызвать iter.next().

**Fail-fast**  - если коллекция изменилась после создания такого итератора, то он выбросит исключение(если мы попытаемся передвинуть итератор, вызовом iter.next()). Например, такой тип итератора в ArrayList, HashSet, HashMap. 

В итераторе содержится счетчик. Этот счетчик используется для отслеживания изменений в коллекции. Если коллекция изменилась(на коллекции вызвали add, remove методы), то следующий вызов next() выбросит исключение ConcurrentModificationException.

При этом важно, что если мы сами вызвали на итераторе метод remove (iter.remove()) для удаления того элемента, на котором сейчас находится итератор, то ошибки не произойдет! Мы дальше сможем спокойно двигаться по коллекции.


**Fail-safe – «умный» итератор. Обычно плата за отказоустойчивость – возможная неконсистентность данных («слабая консистентность»). Итератор класса ConcurrentHashMap работает с копией данных, он не выбросит исключение при изменении коллекции, но может не увидеть часть свежих изменений.**


### Помимо Iterator, который можно получить у всех коллекций, которые реализуют интерфейс Iterable есть еще и ListIterator, который можно получить у классов, которые реализуют интерфейс List

### 1. **Основные операции:**

- **Iterator** предоставляет базовые методы для обхода коллекций:
    
    - `hasNext()`: проверяет, есть ли еще элементы в коллекции.
    - `next()`: возвращает следующий элемент в коллекции.
    - `remove()`: удаляет последний элемент, возвращенный методом `next()` (опциональная операция).
- **ListIterator** расширяет возможности `Iterator` и предоставляет дополнительные методы для двунаправленного обхода списка:
    
    - **Все методы `Iterator`:**
        - `hasNext()`
        - `next()`
        - `remove()`
    - **Дополнительные методы `ListIterator`:**
        - `hasPrevious()`: проверяет, есть ли предыдущие элементы в коллекции.
        - `previous()`: возвращает предыдущий элемент в коллекции.
        - `nextIndex()`: возвращает индекс следующего элемента.
        - `previousIndex()`: возвращает индекс предыдущего элемента.
        - `add(E e)`: добавляет элемент перед текущей позицией итератора.
        - `set(E e)`: заменяет последний элемент, возвращенный методом `next()` или `previous()`, на новый.

Из дополнительного функционала следует обратить особое внимание на то, что можно перемещаться вперед и назад, а также добавлять элементы. Итератор же может ходить только вперед и удалять, а добавлять не может.
### 2. **Направление обхода:**

- **Iterator** работает только в одном направлении (только вперед). Он не позволяет вернуться к предыдущему элементу после вызова `next()`.
- **ListIterator** поддерживает двунаправленный обход списка. Можно двигаться как вперед (с помощью `next()`), так и назад (с помощью `previous()`).

### Также существует Enumeration - раньше использовался для перебора элементов в коллекции, т.е. использовался как Iterator. В современных приложениях используется Iterator, но на старых проектах, которые используют старые коллекции, такие как Vector, Hashtable там как раз Enumeration
### Основные характеристики `Enumeration`:
- Это **однонаправленный** итератор, который позволяет последовательно проходить по элементам коллекции.
- Не поддерживает удаление элементов из коллекции во время итерации, в отличие от `Iterator`. 
- Чаще всего используется для работы с устаревшими коллекциями, такими как `Vector` и `Hashtable`.
- Можно использовать только для read-only коллекций.
**Enumeration в два раза быстрее Iterator и использует меньше памяти.**

Enumeration: hasMoreElement(), nextElement()
Iterator: hasNext(), next(), remove()

