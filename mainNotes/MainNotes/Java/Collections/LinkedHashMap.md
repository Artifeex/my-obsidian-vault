![[Pasted image 20241112103224.png]]
![[Pasted image 20241112103253.png]]
Т.е. LinkedHashMap - это та же HashMap, только внутри себя она еще хранит связный список, за счет которого и обеспечивается порядок.

Данная структура может слегка уступать по производительности родительскому HashMap, при этом время выполнения операций add(), contains(), remove() остается константой — O(1). Понадобится чуть больше места в памяти для хранения элементов и их связей, но это совсем небольшая плата за дополнительные фишечки.

Только что созданный объект linkedHashMap, помимо свойств унаследованных от HashMap (такие как table, loadFactor, threshold, size, entrySet и т.п.), так же содержит два доп. свойства:

- header — «голова» двусвязного списка. При инициализации указывает сам на себя; before - указывает на последний элемент, а after на первый.
    
- accessOrder — указывает каким образом будет осуществляться доступ к элементам при использовании итератора. При значении true — по порядку последнего доступа (об этом в [конце](https://habr.com/ru/post/129037/#accessOrderTrue) статьи). При значении false доступ осуществляется в том порядке, в каком элементы были вставлены.
    

Конструкторы класса LinkedHashMap достаточно скучные, вся их работа сводится к вызову конструктора родительского класса и установке значения свойству accessOrder. А вот инициализация свойства header происходит в переопределенном методе init() (теперь становится понятно для чего в конструкторах класса HashMap присутствует вызов этой, ничегонеделающей функции).

![[Pasted image 20241022151425.png]]

Добавление:(Каждый Entry хранит в себе ссылки на следующий entry, который добавили после него(если не добавляли, то ссылается на header) и на предыдущий. За счет этого и сохраняется порядок вставки элементов. И прикольно, что скорость почти никак не падает, мы все еще можем быстро найти нужный entry по обычным правилам, а при удалении какого-то элемента нужно у entry просто переставить ссылки у предыдущего entry на следующий, а у следующего entry на предыдущий)
![[Pasted image 20241022151730.png]]
![[Pasted image 20241022152622.png]]
![[Pasted image 20241022152636.png]]
Ситуация с коллизией(вставили элемент с ключом 38, как видим, он вставляется в начало цепочки).
![[Pasted image 20241022152649.png]]

Если попытаться добавить элемент с ключом, который уже существует, то обновится значение, но при этом порядок вставки не меняется.
### acessOrder = true. Что делает(по дефолту оно false)
А теперь давайте рассмотрим пример когда свойство accessOrder имеет значение true. В такой ситуации поведение LinkedHashMap меняется и при вызовах методов get() и put() порядок элементов будет изменен — элемент к которому обращаемся будет помещен в конец.
```java
Map<Integer, String> linkedHashMap =  
new LinkedHashMap<Integer, String>(15, 0.75f, true) {{  
    put(1, "obj1");  
    put(15, "obj15");  
    put(4, "obj4");  
    put(38, "obj38");  
}};  
// {1=obj1, 15=obj15, 4=obj4, 38=obj38}  

//после вызова get или put по ключу 1 элемент с ключом 1 окажется в конце
//списка
linkedHashMap.get(1); // or linkedHashMap.put(1, "Object1");  
// {15=obj15, 4=obj4, 38=obj38, 1=obj1}** 
```
