![[Pasted image 20240925170055.png]]
HashMap хранит пары - ключ, значение.
Под капотом в HashMap есть массив bucket-ов. В них сохраняются Node(узлы). В каждой ноде хранится ключ и значение. По дефолту создается 16 бакетов. Со временем этот массив увеличивается, с увеличением числа элементов в HashMap. А это влечет за собой то, что нужно будет потратить ресурсы на перераспределение сохраненных элементов, т.к. формула по вычислению ячейки зависит от размера массива бакетов. Такое перераспределение происходит, когда превышается loadFactor - процент заполненности.

### Процесс вставки в HashMap
При вызове метода put. У ключа вызывается вызов метода hashCode(), чтобы получить hashCode - это какое-то большое число. И нам необходимо положить этот ключ в какой-то один из бакетов. Для этого мы берем хеш-код и производим операцию побитового И. Каждый бакет представляет собой LinkedList(там его кастомная реализация). И в этом бакете хранятся все элементы, у которых 
hashCode && N дал одно и тоже значение. После этого мы должны проверить, что внутри этого списка нет элемента с таким же ключом(т.е. производится дублирующая вставка). Для этого мы проверяем с помощью equals значения ключа(НЕ ХЭШ, А ИМЕННО ЗНАЧЕНИЕ КЛЮЧА). Если равны, то, значит, что это дублирующая вставка, поэтому мы просто обновляем значение по этому элементу. А если не была найдено ни одного ключа с таким же значением, то происходит вставка.

Побитовое "И" используется, потому что это быстро. 

Также стоит заметить, что LinkedList может со временем для оптимизации перестроиться в красно-черное дерево, если будет 8 элементов в LinkedList. И за счет этого мы можем найти нужный ключ, который нам надо за log(N).

### Асимптоты 
- Вставка - O(1) (но в худшем случае может быть и O(N), если все элементы попадут в один bucket)
- Поиск - O(1) (но в худшем случае может быть и O(N), если все элементы попадут в один bucket)
- Удаление - O(1)







