`CopyOnWriteArrayList` — это потокобезопасная реализация интерфейса `List` в Java, которая обеспечивает **блокировку при записи**, но **не блокирует операции чтения**. Основной принцип работы этого класса заключается в том, что **каждая операция модификации списка создаёт его копию**, а чтение производится из неизменяемого оригинала. Это делает `CopyOnWriteArrayList` очень эффективным для сценариев, где чтений больше, чем записей.

### Основные принципы работы

1. **Неизменяемость во время чтения**: Все операции чтения, такие как `get()`, `contains()`, `size()`, работают с неизменяемым массивом, который не изменяется в процессе чтения. Таким образом, чтение не требует синхронизации, и несколько потоков могут одновременно и безопасно читать список.
2. **Копирование при записи(в том числе и просто при об**: Когда происходит операция модификации (например, `add()`, `remove()`, `set()`), список копируется, и все изменения происходят в новой копии массива. После завершения модификации новая копия заменяет старую. Это делает операции записи относительно дорогими с точки зрения производительности и памяти, поскольку для каждой операции модификации создаётся новый массив. 
   
   Если поток хочет добавить элемент в список, создаётся новая копия текущего массива, в которую добавляется новый элемент, и затем эта новая копия заменяет оригинал. Остальные потоки, которые в этот момент читают список, продолжают использовать старую версию массива.
   
   Также важно заметить, что если два потока одновременно будут добавлять какой-то элемент в список, то создается 2 копии и один поток пишет в одну копию, а другой в другую. И в таком случае обновление одного из потоков потеряется, поскольку потоки заменят тот вариант списка, который будет храниться внутри CopyOnWriteArrayList и это сначала сделает 1-ый поток, а потом второй и тем самым изменения первого затрутся. 
3. **Потокобезопасность**: Поскольку операции записи выполняются с копиями массива, которые затем атомарно заменяются, `CopyOnWriteArrayList` является потокобезопасным без использования сложных блокировок для чтения. Модификации могут происходить одновременно с чтением, не блокируя потоки, которые читают данные.
4. Также интересным является то, что итератор, который мы можем получить из CopyOnWriteArrayList будет работать с копией и даже если потом какой-нибудь поток запишет данные в коллекцию, то мы все равно сможем итерироваться с помощью итератора, т.к. итератор будет работать с тем вариантом списка, который был при создании итератора. Т.е. не выбросится исключение ConcurrentModificationException. Но и изменений мы не увидим, которые произошли с CopyOnWriteArrayList.
   
   Но при этом мы не можем с помощью итератора как-то изменять список, т.е. вызов, например, метода remove приведет к ConcurrentModificationException.
#### Преимущества:

- **Потокобезопасность без сложных блокировок**: Каждая операция записи работает с копией, что исключает необходимость в сложных механизмах блокировки для чтений и записей. Это особенно полезно для операций чтения, которые не блокируются.
- **Эффективность для сценариев с частыми чтениями и редкими модификациями**: Если операции модификации редки, потери от создания новых копий незначительны.

#### Недостатки:

- **Высокие накладные расходы при частых модификациях**: Для каждой операции записи создается новая копия массива, что может привести к значительным накладным расходам по памяти и времени при частых изменениях.
- **Потеря изменений при одновременных модификациях**: Как видно из примеров, несколько параллельных операций записи могут перезаписывать друг друга, и в конечном итоге сохраняется только одно из изменений.

### Есть коллекция, которая работает поверх CopyOnWriteArrayList - [[CopyOnWriteArraySet]]
