Появился в Java в пакете java.util.concurrent в JDK 1.5. Является потокобезопасным вариантом HashMap.

Реализует интерфейс ConcurrentMap(интерфейс) extends Map.

До Java 8 ConcurrentHashMap представляла из себя массив сегментов, а каждый сегмент был по сути полноценной HashMap. И когда происходили операции добавления, удаления или изменения, то вычислялся hash, потом определялся сегмент и этот сегмент блокировался, а дальше выполнялась операция.
Начиная с Java 8 от сегментов отказались и теперь ConcurrentHashMap представляет из себя массив бакетов, как и обычная HashMap. Но теперь для обеспечения потокобезопасности используются CAS и может заблокироваться 1 bucket, в который происходит добавление или удаление.

В `ConcurrentHashMap` для вставки и изменения значений используется комбинация двух механизмов: **[[CAS]] (Compare-And-Swap)** и **блокировки на уровне бакетов**. Эти механизмы оптимизируют работу с многопоточной средой, минимизируя блокировки и обеспечивая высокую производительность.

### 1. **Когда используется CAS (Compare-And-Swap)**

Операция **CAS** в `ConcurrentHashMap` используется для атомарного обновления значений **без блокировки**. Это происходит в простых случаях, когда можно безопасно выполнить вставку или обновление значения без необходимости блокировать другие потоки. CAS работает с отдельными переменными (например, `volatile` полями) и позволяет потокам взаимодействовать друг с другом с минимальной задержкой.

#### Примеры использования CAS:

- **Вставка первой записи в бакет**:
  Когда бакет (ячейка массива `table[]`) пуст, и один из потоков выполняет вставку новой записи (например, вызов `put()` для нового ключа), операция происходит через CAS. Поток пытается атомарно установить новое значение, используя `CAS` для изменения пустого бакета на новый узел (`Node<K, V>`).

  ```java
  if (casTabAt(tab, i, null, new Node<>(hash, key, value))) {
      // Вставка успешна
  }
  ```

  Если операция CAS прошла успешно, узел добавляется в бакет без необходимости блокировки. Если другой поток в это же время пытается выполнить вставку в этот же бакет, и он уже изменен, CAS операция вернёт неудачу, и поток повторит попытку или применит другие методы (возможно, с блокировкой).

- **Обновление значения существующего узла**:
  Когда поток находит узел с уже существующим ключом и ему нужно обновить значение, если узел не блокирован другими потоками, обновление происходит через CAS. Это позволяет выполнить атомарное обновление значения в узле, не блокируя весь бакет.

  ```java
  if (casValue(node, expectedValue, newValue)) {
      // Успешно обновлено
  }
  ```

Таким образом, **CAS** используется для:
- Вставки нового узла в пустой бакет.
- Атомарного обновления значения узла без блокировки.

### 2. **Когда происходит блокировка бакета**

Если ситуация становится более сложной и атомарные операции на основе CAS недостаточны для обеспечения корректности данных, `ConcurrentHashMap` переходит к использованию **блокировок на уровне бакетов**. Это необходимо, чтобы избежать состояния гонки или конфликтов между потоками, когда CAS не может справиться.

#### Примеры, когда требуется блокировка:

- **Коллизии (несколько узлов в одном бакете)**:
  Когда в одном бакете оказывается несколько узлов из-за коллизии хешей (одинаковый хеш-код для разных ключей), простая вставка нового узла или обновление значения существующего требует более сложного управления. В таких случаях применяется блокировка на уровне конкретного бакета (а не всей карты). Поток блокирует бакет, чтобы безопасно изменить структуру данных (например, изменить связный список или дерево).

  ```java
  synchronized (f) {
      // Поток блокирует узел f и выполняет вставку или изменение
  }
  ```

- **Преобразование связного списка в дерево**:
  Если в одном бакете слишком много коллизий (по умолчанию 8 элементов), связный список преобразуется в красно-черное дерево для оптимизации доступа к данным. Такое преобразование — сложная операция, и она выполняется с блокировкой бакета, чтобы предотвратить другие изменения в этот момент.

  ```java
  synchronized (f) {
      if (binCount >= TREEIFY_THRESHOLD) {
          treeifyBin(tab, hash);
      }
  }
  ```

  В момент, когда поток преобразует структуру бакета из связного списка в дерево, другие потоки не могут выполнять вставки или изменения в этом бакете.

- **Ре-хеширование при увеличении карты**:
  Когда карта расширяется (например, при увеличении количества элементов или превышении порога загрузки), нужно перераспределить узлы по новым бакетам. Ре-хеширование — это операция, которая требует временной блокировки для перемещения узлов в новые бакеты.

### 3. **Алгоритм выбора между CAS и блокировкой**

Алгоритм работы `ConcurrentHashMap` устроен так, чтобы **в первую очередь использовать CAS** для атомарных операций, когда это возможно, поскольку это более быстрый и неконкурентный механизм. Блокировка применяется только в случаях, когда:

- CAS не может справиться с операцией из-за более сложных условий (например, коллизий).
- Требуется изменение сложных структур (например, преобразование списка в дерево или реорганизация бакетов).

Таким образом, **блокировки применяются только там, где это действительно необходимо**, в то время как во всех остальных случаях карта стремится использовать более быстрые неконкурентные методы, такие как CAS.

### Резюме

- **CAS используется** для атомарных вставок в пустые бакеты или обновлений значений в простых случаях, когда нет конфликтов между потоками. Также может использоваться, когда нужно вставить значение в конец списка, там просто нужно проверить, что последний элемент все еще не изменился и если не изменился, то можем вставлять.
- **Блокировка бакетов происходит** в более сложных случаях, таких как:
  - Коллизии в одном бакете. Имеется в виду при вставке в середину, например, нужно переставить ссылки, а это сложно сделать атомарным в CAS.
  - Преобразование связного списка в дерево.
  - Реорганизация данных при увеличении карты (ре-хеширование).
- Операция get() не блокирует concurrentHashMap.

Это делает `ConcurrentHashMap` эффективной и масштабируемой для работы в многопоточной среде, минимизируя необходимость в блокировках и обеспечивая высокий уровень параллелизма.




 