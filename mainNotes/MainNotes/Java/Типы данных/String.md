Класс String не является примитивным типом данных! Это полноценный класс, поэтому это [[Ссылочный тип данных|ссылочный]] тип данных. Являются неизменяемыми, т.е. мы не можем менять содержимое строки, может только создать новую строку в куче и сохранить ссылку на нее. Начиная с Java 9 ввели Compact String. До Java 9 строки внутри представляли собой массив char:
```java
char[] myStringCharacters;
```
Но теперь, перед созданием объекта строки Java анализирует строку и если все элементы строки представляют собой символы, которые кодируются 1 байтом, то используется уже массив byte, за счет чего происходит улучшение по потреблению памяти в 2 раза! Т.к. теперь мы не тратим 2 байта на символ, который по факту требует всего 1 байта.
```java
byte[] myStringCharacters;
```


![[Pasted image 20240925141753.png]]
Особенности:
1. Строки неизменяемы. Т.е. после того, как мы создали строку - ее больше нельзя изменить. Если мы делаем какую-то операцию над строкой, то изначальная строка остается неизменной и создается новая на основе исходной. Это называется immutable.
2. В Heap Memory есть особая область памяти String Pool. В ней кэшируются строки, которые задаются через литералы. На скрине выше - это "Hello", "World". Если бы мы создали еще одну строку через литерал со значением "Hello", то она бы ссылалась на строку из String Pool. Это нужно для того, чтобы не плодить множество одинаковых строк, а переиспользовать часто используемые строки из String Pool и ссылаться на них. Но, если строку создавать не через литерал, а через new, то такая строка не будет помещена в String Pool. Это является ответом на то, какая разница между тем, чтобы задать строку через литерал и задать строку через конструктор. 
   Но все-таки есть возможность перенести строку, созданную через new, в String Pool. Для этого используется вызов метода intern() на объекте строки. В String Pool создается строка с таким же значением и из метода intern() возвращается ссылка на объект из String Pool. А если в String Pool уже была строка с таким значением(проверяется с помощью equals метода), то новая строка не создается, возвращается ссылка из String Pool.

Проблема, связанная с immutable строк: если мы в цикле решим складывать строки, то при каждом сложении будут создаваться новые объекты строк. Т.е. если в цикле складывается массив из 100 строк, то будет создано 100 объектов. Эту проблему решают [[StringBuilder&StringBuffer]].

### Оптимизации при работе со строками
1. При сложении строк через оператор + компилятор может использовать StringBuilder, чтобы не создавать каждый раз новую строку.
2. Если результат конкатенации можно определить на этапе компиляции, например, String a = "Hello" + "World", то конкатенация произойдет на этапе компиляции.

### Особенности работы оператора + со строками
1. String + Примитивный тип = String + String.valueOf(примитивный тип)
2. Примитивный тип + String = String.valueOf(примитивный тип) + String
3. Объект + String = Объект.toString() + String
4. String + Объект = String + Объект.toString() 
5. Примитивный тип + примитивный тип + String = String.valueOf(примитивный тип + примитивный тип) + String. Т.е. Сначала посчитается сумма, а потом только от нее возьмется строка.
6. String + примитивный тип + примитивный тип = String + String.valueOf(примитивный тип) + String.valueOf(примитивный тип). Т.е. работает такое правило, что все операнды, которые идут правее строки при конкатенации преобразуются в строку и потом складываются.