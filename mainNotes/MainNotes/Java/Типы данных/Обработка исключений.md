![[Pasted image 20240925194249.png]]
Блок finalyy выполняется всегда. И когда было выброшено исключение, и когда не было. И даже, если внутри catch было выброшено исключение. Он не выполнится только в том случае, если наше приложение выключится из розетки)


Внутри catch мы можем перечислить сразу несколько типов исключений, чтобы обработать их внутри catch.
![[Pasted image 20240925194554.png]]
### Несколько каверзных вопросов на эту тему
При вызове такого метода вернется 2
```java
private static int check() {  
    try {  
        return 3;  
    } finally {  
        return 2;   
    }  
}
```

Если код внутри try не выбрасывает checked exception, которое мы отлавливаем, то код не скомпилируется!
```java
private static int check() {  
    try {  
        return 3;  
    } catch (SQLException e) {  
            }  
}
```

Exception - не является checked exception! Поэтому мы код ниже скопилируется, даже если код внутри try не выбрасывает Exception:
```java
try {  
    return 3;  
} catch (Exception e) {  
  
} catch (Throwable e) {  
    }
```

Важно соблюдать иерархию при использовании catch. Сначала должны идти более низкие в иерархии исключения, т.е. более узкие, а только после них более высокие в иерархии. Поэтому код наверху скомпилируется, посольку Exception в иерархии ниже, чем Throwable и идет раньше Throwable. А код ниже не скомпилируется:

Ресурсы нужно закрывать, чтобы не было утечки памяти. Мы можем, например, оперативную память заполнить этим ресурсами, например, соединениями к чему-нибудь или открытыми файлами и наше приложение упадет. Или открывать постоянно соединения с БД, но не закрывать их. Тогда БД может просто перестать нам выдавать соединения. Поэтому ресурсы закрывать важно, это делается либо в finally, либо в блоке try with resource.
### Try with resources
Используется для закрытия каких-либо ресурсов. JVM автоматически вызывает метод close(), после выхода из блока try(т.е. либо когда все catch сработают и finally отработает, либо, если catch не справились, то перед тем, как выйти из функции с ошибкой закроются ресурсы). Поэтому класс, который используется внутри этого блока должен реализовывать интерфейс AutoCloseable или Closeable. Через ";" можно перечислять сразу несколько объектов.
```java
try (ResourceType resource = new ResourceType();
	 ResourceType resource1 = new ResourceType()) {
    // Использование ресурса
} catch (ExceptionType e) {
    // Обработка исключений
}

```

### Разница между Closeable и AutoCloseable
```java
public interface AutoCloseable {
    void close() throws Exception;
}

public interface Closeable extends AutoCloseable {
    void close() throws IOException;
}

```
Closeable - является более специфичным для работы с IOE. Т.е. он просто наследуется от AutoCloseable и вместо throws Exception, он выбрасывает IOException, который специчен как раз для IOE операций.

