![[Pasted image 20240925150706.png]]
В нашей программе постоянно создаются объекты, они какое-то время используются, а потом они становятся ненужными и должны удалиться, чтобы не занимать место в памяти. Если не удалять эти объекты, то память бы забилась, и мы не смогли выделять новые объекты.
Удалением ненужных объектов занимается сборщик мусора.

### Как работает сборщик мусора?
Первое, что нужно сделать - это узнать, какие объекты нужно удалять, а какие нет?
Для этого вводится понятие корни сборки(GC Roots) - это объекты, которые достижимы ВСЕГДА в любой момент работы нашей программы! Мы помечаем такие объекты. У этих GC roots есть ссылки на другие объекты. И по этим ссылкам можно пройти. Следовательно, эти объекты будут достижимыми. У достижимых объектов есть свои ссылки, и объекты по этим ссылкам также будут достижимыми. Таким образом, GC помечает все достижимые объекты. Этот процесс называется маркировкой объектов. Те объекты, до которых не удалось дойти - недостижимые, а, следовательно, являются мусором. Происходит удаление объектов. После этого происходит уплотнение памяти, чтобы не было дефрагментации памяти. Т.е. мы поудаляли мусор и в памяти образовались свободные области. И нужно сделать так, чтобы таких маленьких кусочков было поменьше, а наоборот были большие участки свободной памяти. 
Этот механизм сборки мусора похож у различных сборщиков мусора, но эти различные сборщики мусора могут разделять кучу на какие-то подобласти для своей внутренней оптимизации. 

Например, есть Serial и Parallel GC, которые разделяют heap на 2 области: Young Generation, Old Generation. И все новые объекты выделяются в области Young Generation и сборка мусора чаще происходит в области Young Generation. А объекты, которые долго живут в нашей программе постепенно перемещаются в Old Generation область heap. И таким образом, чаще всего запускается сборка мусора внутри Young Generation, но иногда запускается и общая сборка мусора всех созданных объектов, т.е. и для Young и для Old Generation.

G1(garbage first) GC. Он разделяет всю кучу на равные куски и запускает сборку по тем кускам, где как можно больше мусора и затем производит уплотнение. Он является дефолтным для Java 17.

Z GC - предназначен для больших куч. Куч, которые могут достигать размера 16тб. Он ориентирован на маленькие задержки. Для приложений, в которых очень критичны задержки и время на сборку мусора очень ограничено. Является дефолтным для Java 21.

### Как GC понимает, что является корнями сборки?
- Все статические переменные
- Все статические методы(локальные переменные, которые используются в статических методах являются)
- Все активные потоки. У каждого потока на стеке хранятся все переменные, которые могут быть доступны из данного потока, следовательно, это тоже корни сборки.
- Все объекты, по которым захвачен монитор(synchronized).

### Механика работы сборщика мусора
https://habr.com/ru/articles/269621/
Вот тут и возникает идея разделения объектов на _младшее поколение (young generation)_ и _старшее поколение (old generation)_. В соответствии с этим разделением и процессы сборки мусора разделяются на _малую сборку (minor GC)_, затрагивающую только младшее поколение, и _полную сборку (full GC)_, которая может затрагивать оба поколения. Малые сборки выполняются достаточно часто и удаляют основную часть мертвых объектов. Полные сборки выполняются тогда, когда текущий объем выделенной программе памяти близок к исчерпанию и малой сборкой уже не обойтись.  
  
При этом разделение объектов по поколениям не просто условное, они физически размещаются в разных регионах памяти. Объекты из младшего поколения по мере выживания в сборках мусора переходят в старшее поколение. В старшем поколении объект может прожить до окончания работы приложения, либо будет удален в процессе одной из полных сборок мусора.

Традиционно, при определении эффективности работы сборщика мусора учитываются следующие факторы:  
- Максимальная задержка — максимальное время, на которое сборщик приостанавливает выполнение программы для выполнения одной сборки. Такие остановки называются _stop-the-world_ (или _STW_).
- Пропускная способность — отношение общего времени работы программы к общему времени простоя, вызванного сборкой мусора, на длительном промежутке времени.
- Потребляемые ресурсы — объем ресурсов процессора и/или дополнительной памяти, потребляемых сборщиком.

Понятно, что добиться улучшения всех трех параметров одновременно практически невозможно. Уменьшение максимального времени задержки приводит к учащению сборки мусора, уменьшая пропускную способность. Либо приходится использовать более ухищренные алгоритмы для сохранения пропускной способности, что чаще всего увеличивает потребление ресурсов. И так далее.

Поэтому при настройке сборщиков мусора разработчики обычно фокусируются на оптимизации одного или двух параметров, стараясь сильно не ухудшать остальные, но жертвуя ими в случае необходимости.

Чаще всего для целей малой сборки мусора объект считается мертвым и подлежащим утилизации, если до него невозможно добраться по ссылкам ни из объектов старшего поколения, ни из так называемых _корней (roots).

До этого мы поговорили о базовых концепциях, которые присущи в целом всем GC. 



