![[Pasted image 20240925150706.png]]
В нашей программе постоянно создаются объекты, они какое-то время используются, а потом они становятся ненужными и должны удалиться, чтобы не занимать место в памяти. Если не удалять эти объекты, то память бы забилась, и мы не смогли выделять новые объекты.
Удалением ненужных объектов занимается сборщик мусора.

### Как работает сборщик мусора?
Первое, что нужно сделать - это узнать, какие объекты нужно удалять, а какие нет?
Для этого вводится понятие корни сборки(GC Roots) - это объекты, которые достижимы ВСЕГДА в любой момент работы нашей программы! Мы помечаем такие объекты. У этих GC roots есть ссылки на другие объекты. И по этим ссылкам можно пройти. Следовательно, эти объекты будут достижимыми. У достижимых объектов есть свои ссылки, и объекты по этим ссылкам также будут достижимыми. Таким образом, GC помечает все достижимые объекты. Этот процесс называется маркировкой объектов. Те объекты, до которых не удалось дойти - недостижимые, а, следовательно, являются мусором. Происходит удаление объектов. После этого происходит уплотнение памяти, чтобы не было дефрагментации памяти. Т.е. мы поудаляли мусор и в памяти образовались свободные области. И нужно сделать так, чтобы таких маленьких кусочков было поменьше, а наоборот были большие участки свободной памяти. 
Этот механизм сборки мусора похож у различных сборщиков мусора, но эти различные сборщики мусора могут разделять кучу на какие-то подобласти для своей внутренней оптимизации. 

Например, есть Serial и Parallel GC, которые разделяют heap на 2 области: Young Generation, Old Generation. И все новые объекты выделяются в области Young Generation и сборка мусора чаще происходит в области Young Generation. А объекты, которые долго живут в нашей программе постепенно перемещаются в Old Generation область heap. И таким образом, чаще всего запускается сборка мусора внутри Young Generation, но иногда запускается и общая сборка мусора всех созданных объектов, т.е. и для Young и для Old Generation.

G1(garbage first) GC. Он разделяет всю кучу на равные куски и запускает сборку по тем кускам, где как можно больше мусора и затем производит уплотнение. Он является дефолтным для Java 17.

Z GC - предназначен для больших куч. Куч, которые могут достигать размера 16тб. Он ориентирован на маленькие задержки. Для приложений, в которых очень критичны задержки и время на сборку мусора очень ограничено. Является дефолтным для Java 21.

### Как GC понимает, что является корнями сборки?
- Все статические переменные
- Все статические методы(локальные переменные, которые используются в статических методах являются)
- Все активные потоки. У каждого потока на стеке хранятся все переменные, которые могут быть доступны из данного потока, следовательно, это тоже корни сборки.
- Все объекты, по которым захвачен монитор(synchronized).



