![[Pasted image 20240925150706.png]]
В нашей программе постоянно создаются объекты, они какое-то время используются, а потом они становятся ненужными и должны удалиться, чтобы не занимать место в памяти. Если не удалять эти объекты, то память бы забилась, и мы не смогли выделять новые объекты.
Удалением ненужных объектов занимается сборщик мусора.

### Как работает сборщик мусора?
Первое, что нужно сделать - это узнать, какие объекты нужно удалять, а какие нет?
Для этого вводится понятие корни сборки(GC Roots) - это объекты, которые достижимы ВСЕГДА в любой момент работы нашей программы! Мы помечаем такие объекты. У этих GC roots есть ссылки на другие объекты. И по этим ссылкам можно пройти. Следовательно, эти объекты будут достижимыми. У достижимых объектов есть свои ссылки, и объекты по этим ссылкам также будут достижимыми. Таким образом, GC помечает все достижимые объекты. Этот процесс называется маркировкой объектов. Те объекты, до которых не удалось дойти - недостижимые, а, следовательно, являются мусором. Происходит удаление объектов. После этого происходит уплотнение памяти, чтобы не было дефрагментации памяти. Т.е. мы поудаляли мусор и в памяти образовались свободные области. И нужно сделать так, чтобы таких маленьких кусочков было поменьше, а наоборот были большие участки свободной памяти. 
Этот механизм сборки мусора похож у различных сборщиков мусора, но эти различные сборщики мусора могут разделять кучу на какие-то подобласти для своей внутренней оптимизации. 

Например, есть Serial и Parallel GC, которые разделяют heap на 2 области: Young Generation, Old Generation. И все новые объекты выделяются в области Young Generation и сборка мусора чаще происходит в области Young Generation. А объекты, которые долго живут в нашей программе постепенно перемещаются в Old Generation область heap. И таким образом, чаще всего запускается сборка мусора внутри Young Generation, но иногда запускается и общая сборка мусора всех созданных объектов, т.е. и для Young и для Old Generation.

G1(garbage first) GC. Он разделяет всю кучу на равные куски и запускает сборку по тем кускам, где как можно больше мусора и затем производит уплотнение. Он является дефолтным для Java 17.

Z GC - предназначен для больших куч. Куч, которые могут достигать размера 16тб. Он ориентирован на маленькие задержки. Для приложений, в которых очень критичны задержки и время на сборку мусора очень ограничено. Является дефолтным для Java 21.

### Как GC понимает, что является корнями сборки?
- Все статические переменные
- Все статические методы(локальные переменные, которые используются в статических методах являются)
- Все активные потоки. У каждого потока на стеке хранятся все переменные, которые могут быть доступны из данного потока, следовательно, это тоже корни сборки.
- Все объекты, по которым захвачен монитор(synchronized).

### Механика работы сборщика мусора
https://habr.com/ru/articles/269621/
Вот тут и возникает идея разделения объектов на _младшее поколение (young generation)_ и _старшее поколение (old generation)_. В соответствии с этим разделением и процессы сборки мусора разделяются на _малую сборку (minor GC)_, затрагивающую только младшее поколение, и _полную сборку (full GC)_, которая может затрагивать оба поколения. Малые сборки выполняются достаточно часто и удаляют основную часть мертвых объектов. Полные сборки выполняются тогда, когда текущий объем выделенной программе памяти близок к исчерпанию и малой сборкой уже не обойтись.  
  
При этом разделение объектов по поколениям не просто условное, они физически размещаются в разных регионах памяти. Объекты из младшего поколения по мере выживания в сборках мусора переходят в старшее поколение. В старшем поколении объект может прожить до окончания работы приложения, либо будет удален в процессе одной из полных сборок мусора.

Традиционно, при определении эффективности работы сборщика мусора учитываются следующие факторы:  
- Максимальная задержка — максимальное время, на которое сборщик приостанавливает выполнение программы для выполнения одной сборки. Такие остановки называются _stop-the-world_ (или _STW_).
- Пропускная способность — отношение общего времени работы программы к общему времени простоя, вызванного сборкой мусора, на длительном промежутке времени.
- Потребляемые ресурсы — объем ресурсов процессора и/или дополнительной памяти, потребляемых сборщиком.

Понятно, что добиться улучшения всех трех параметров одновременно практически невозможно. Уменьшение максимального времени задержки приводит к учащению сборки мусора, уменьшая пропускную способность. Либо приходится использовать более ухищренные алгоритмы для сохранения пропускной способности, что чаще всего увеличивает потребление ресурсов. И так далее.

Поэтому при настройке сборщиков мусора разработчики обычно фокусируются на оптимизации одного или двух параметров, стараясь сильно не ухудшать остальные, но жертвуя ими в случае необходимости.

Чаще всего для целей малой сборки мусора объект считается мертвым и подлежащим утилизации, если до него невозможно добраться по ссылкам ни из объектов старшего поколения, ни из так называемых _корней (roots).

До этого мы поговорили о базовых концепциях, которые присущи в целом всем GC. 

### Сборщики мусора
[[Serial GC]]
[[Parallel GC]]

CMS GC и G1 GC, первостепенной задачей которых является минимизация пауз при наведении порядка в памяти приложений, оперирующих средними и большими объемами данных, то есть по большей части в памяти серверных приложений.  
  
Два этих сборщика объединяют общим названием _«mostly concurrent collectors»_, то есть _«по большей части конкурентные сборщики»_. Это связано с тем, что часть своей работы они выполняют параллельно с основными потоками приложения, то есть в какие-то моменты конкурируют с ними за ресурсы процессора. Конечно, это не проходит бесследно, и в итоге они разменивают улучшение в части пауз на ухудшение в части пропускной способности. Хотя делают это по-разному. Давайте посмотрим, как.

[[CMS GC]]
[[G1 GC]]

### Резюме
Serial GC отличается от Parallel GC тем, что в Parallel включается параллельность при переносе данных из youg generation в old generation разными потоками в свои области. А также после полной сборки уплотнением данных занимается сразу несколько потоков(полная сборка происходит, когда уже не хватает места в области old generation. И за счет этого уменьшается максимальная задрежка, т.к. раньше 1 поток переносил бы данные из young generation в old generation, а теперь этим занимается сразу несколько потоков. 

CMS GC - отличается от Parallel GC тем, что полная сборка(ее называют major в CMS) мусора затрагивает только old generation, young generation не затрагивается. В результате, малая и старшая сборки здесь всегда разделены.

Важным отличием сборщика CMS от рассмотренных ранее является также то, что он не дожидается заполнения Tenured для того, чтобы начать старшую сборку. Вместо этого он трудится в фоновом режиме постоянно, пытаясь поддерживать Tenured в компактном состоянии.