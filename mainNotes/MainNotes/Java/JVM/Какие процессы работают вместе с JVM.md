Помимо сборщика мусора (Garbage Collector, GC), в JVM работает множество других процессов и потоков, которые поддерживают выполнение программы и управляют памятью. Вот основные из них:

### 1. **Main Thread** (Главный поток)
   - Этот поток запускает выполнение кода в методе `main`. Главный поток отвечает за выполнение основной логики программы.
   - Когда основной поток завершает выполнение, программа также может завершиться, если не запущено других потоков (`non-daemon`).

### 2. **Daemon Threads** (Потоки-демоны)
   - Потоки-демоны выполняются в фоновом режиме и завершаются вместе с программой, как только основной поток завершит работу. 
   - Примеры: фоновые задачи, такие как работа сборщика мусора, задачи мониторинга и очистки.
   - Они предназначены для выполнения фоновых задач, которые не требуют завершения работы программы.

### 3. **JIT-компилятор (Just-In-Time Compiler)**
   - Just-In-Time компиляция позволяет JVM компилировать байт-код в машинный код во время выполнения, что улучшает производительность.
   - JIT-компилятор запускается в отдельном потоке, который компилирует часто вызываемые методы, чтобы ускорить их выполнение в будущем.
   - JIT работает совместно с профилирующими потоками, которые отслеживают часто исполняемые части кода для оптимизации.

### 4. **Потоки управления памятью и кэшированием**
   - **Поток "Code Cache Sweeper"**: управляет кэшированием скомпилированного кода, удаляя редко используемый машинный код.
   - **Поток "Reference Handler"**: обрабатывает ссылки типа `SoftReference`, `WeakReference`, `PhantomReference`, обеспечивая корректное освобождение ресурсов, связанных с этими ссылками.
   - **Finalizer Thread**: выполняет методы `finalize()` у объектов, готовых к сборке мусора, когда они переопределены. Этот поток обрабатывает отложенные действия, связанные с уничтожением объектов.

### 5. **Потоки мониторинга и профилирования**
   - В JVM могут быть потоки для мониторинга и профилирования программы. Например, некоторые инструменты мониторинга (JConsole, VisualVM) подключаются к JVM и получают информацию о производительности, потреблении памяти, состоянии потоков и других метриках.
   - **Потоки сигнального обработчика**: отвечают на сигналы операционной системы (например, для завершения работы, снятия дампа и т.д.).

### 6. **Потоки управления сессиями и сетью**
   - Если программа работает с сетевыми соединениями или параллельными задачами, то JVM может запустить несколько потоков для управления ими.
   - Например, при использовании сервера приложений (например, Tomcat) JVM поддерживает множество сетевых потоков, управляющих запросами клиентов.

### 7. **Поток "Системные таймеры и расписания"**
   - Этот поток обрабатывает задачи, требующие выполнения по расписанию, такие как `Timer`, `ScheduledExecutorService`, и поддерживает другие действия, связанные со временем.

### 8. **Потоки классовой загрузки** (Class Loader Threads)
   - Эти потоки отвечают за динамическую загрузку и инициализацию классов, необходимых приложению во время выполнения.
   - Процессы загрузки и связывания классов выполняются только один раз для каждого класса, когда он впервые используется в программе.

### 9. **Поток Signal Dispatcher**
   - Этот поток обрабатывает системные сигналы, такие как `SIGINT` (прерывание), `SIGHUP` (разрыв соединения), `SIGTERM` (завершение) и другие. Он перехватывает сигналы операционной системы и передает их для обработки в JVM.

### 10. **Поток компиляции (Compilation Thread)**
   - Используется компилятором HotSpot для подготовки и оптимизации байт-кода для более эффективного выполнения. HotSpot анализирует байт-код и компилирует его в машинный код по мере выполнения программы.

Эти процессы и потоки поддерживают стабильную работу JVM и оптимизируют выполнение программы. Они вместе с основным потоком и сборщиком мусора обеспечивают высокую производительность, управление памятью и возможность выполнения фоновых задач без прерывания работы основного кода.


При рассказе можно говорить про 2 основных:
1. GC
2. JIT