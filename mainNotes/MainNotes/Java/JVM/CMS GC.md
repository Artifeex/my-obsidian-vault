Concurrent Mark Sweep GC
Использование CMS GC включается опцией `-XX:+UseConcMarkSweepGC`

Мы уже встречали слова Mark и Sweep при рассмотрении последовательного и параллельного сборщиков (если вы не встречали, то сейчас как раз самое время это [сделать](https://habrahabr.ru/post/269707/)). Они обозначали два шага в процессе сборки мусора в старшем поколении: пометку выживших объектов и удаление мертвых объектов. Сборщик CMS получил свое название благодаря тому, что выполняет указанные шаги параллельно с работой основной программы.

При этом CMS GC использует ту же самую организацию памяти, что и уже рассмотренные Serial / Parallel GC: регионы Eden + Survivor 0 + Survivor 1 + Tenured и такие же принципы малой сборки мусора. **Отличия начинаются только тогда, когда дело доходит до полной сборки. В случае CMS ее называют _старшей (major) сборкой_, а не полной, так как она не затрагивает объекты младшего поколения.** В результате, малая и старшая сборки здесь всегда разделены. Одним из побочных эффектов такого разделения является то, что все объекты младшего поколения (даже потенциально мертвые) могут играть роль корней при определении статуса объектов в старшем поколении.  
  
Важным отличием сборщика CMS от рассмотренных ранее является также то, что он не дожидается заполнения Tenured для того, чтобы начать старшую сборку. Вместо этого он трудится в фоновом режиме постоянно, пытаясь поддерживать Tenured в компактном состоянии.  
  
Давайте рассмотрим, что из себя представляет старшая сборка мусора при использовании CMS GC.

