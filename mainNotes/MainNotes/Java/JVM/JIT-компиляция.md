Сами по себе Java программы достаточно медленные из-за интерпретатора. Но с использованием JIT-компиляции и динамического профилировщика программы становятся почти такими же быстрыми, как и на С++.

JIT-компилятор принимает байт-код и генерирует машинный код, который исполняется не виртуальным процессором, а реальным. За счет JIT ваши программы на Java могут (теоретически) выполняться также быстро, как написанные на С++. По сути, JIT выполняет ту же работу что и компилятор C++, но делает это прямо во время выполнения программы и не для всей программы, а для так называемого Common path (основного пути исполнения). Отсюда растут ноги многих статей, показывающих, что Java-программа работает также быстро как на С++.

Откуда JIT узнает что надо компилировать, а что не стоит? — Эти данные предоставляет динамический профайлер, который прямо во время выполнения собирает статистику вызова функций, использовании переменных и т.п. То есть в интерпретируемых языках помимо вашего кода выполняется еще что-то, при каждом вызове функции, инкрементирующее счетчики и не только.

JIT читает байт-код из некоторых секторов (редко сразу из всех) и компилирует их в машинный код. Этим сектором может быть файл, функция или любой фрагмент кода. Единожды скомпилированный код может кэшироваться и в дальнейшем повторно использоваться без перекомпиляции.

JIT, как правило, эффективней, чем интерпретация кода. К тому же в некоторых случаях JIT может показывать большую производительность по сравнению со статической компиляцией за счёт оптимизаций, возможных только во время исполнения:

1. Компиляция может осуществляться непосредственно для целевого процессора и операционной системы, на которой запущено приложение. Например, JIT может использовать векторные [SSE2](https://ru.wikipedia.org/wiki/SSE2 "SSE2") расширения процессора, если он обнаружит их поддержку.
2. Среда может собирать статистику о работающей программе и производить оптимизации с учётом этой информации. Некоторые статические компиляторы также могут принимать на вход информацию о предыдущих запусках приложения.
3. Среда может делать глобальные оптимизации кода (например, встраивание библиотечных функций в код) без потери преимуществ динамической компиляции и без [накладных расходов](https://ru.wikipedia.org/w/index.php?title=%D0%9D%D0%B0%D0%BA%D0%BB%D0%B0%D0%B4%D0%BD%D1%8B%D0%B5_%D1%80%D0%B0%D1%81%D1%85%D0%BE%D0%B4%D1%8B_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)&action=edit&redlink=1 "Накладные расходы (программирование) (страница отсутствует)"), присущих статическим компиляторам и [компоновщикам](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%BE%D0%B2%D1%89%D0%B8%D0%BA "Компоновщик").
4. Более простое перестраивание кода для лучшего использования [кэша](https://ru.wikipedia.org/wiki/%D0%9A%D1%8D%D1%88_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0 "Кэш процессора").

