Согласно спецификации Java SE для того, чтобы получить работающий в JVM код, необходимо выполнить три этапа:
### 1. Загрузка байт-кода из ресурсов и создание экземпляра класса Class
- Поиск загруженного класса, среди загруженных ранее. Т.е. в Metaspace область памяти JVM уже может находиться загруженный байт-код нашего класса.
- Загрузка класса, если мы не нашли его в Metaspace
- Загрузка родительских классов. Если родительские классы и интерфейсы не были загружены, то и рассматриваемыей класс считается не загруженным
### 2. Связывание
- Verification. Проверка корректности полученного байт-кода
- Preparation - выделение места в Metaspace под статические поля и инциализация их значениями по умолчанию(а уже установка тех значений, которые мы написали происходят на следующем этапе инициализации)
- Resolution - разрешение символьных ссылок типов, полей и методов. В ClassLoader есть метод, который определяет, нужно делать разрешение ссылок(т.е. загружать в тот тип класса, который хранится по ссылке в нашем классе) или нет. По дефолту оно не делается, поэтому и считается, что в Java ленивая загрузка классов.
### 3. Инициализация полученного объекта

В Java реализована ленивая загрузка классов. А это значит, что загрузка классов ссылочных полей загружаемого класса не будет выполняться до тех пор, пока в приложении не встретится явное к ним обращение.

### Разберем подробнее этап загрузки байт-кода
![[Pasted image 20241018171600.png]]
В Java существует 3 стандартный загрузчика:
### 1. Bootstrap
Базовый загрузчик, загружает стандартные классы из JDK.
### 2. Extension ClassLoader
Загружает классы расширений
### 3. System ClassLoader
Системный загрузчик. Загружает классы из classpath.

**В Java используется иерархия загрузчиков классов, где корневым, разумеется, является базовый. Далее следует загрузчик расширений, а за ним уже системный. Естественно, каждый загрузчик хранит указатель на родительский для того, чтобы смочь делегировать ему загрузку в том случае, если сам будет не в состоянии этого сделать.**

Можно писать кастомные classloaders, которые наследуются от абстрактого класса ClassLoader. В том числе и ExtenstionClassLoader и SystemClassLoader являются его наследниками. А Bootstrap реализован нативно в JVM.

Каждый класс знает, какой его загрузчик загрузил, поэтому мы и можем вызвать String.class.getClassLoader() - для получения загрузчика нашего класса. Тот загрузчик, который загрузил наш класс называется текущим. У наших классов как правило будет SystemClassLoader.

### Три принципа загрузки классов

#### Делегирование
Запрос на загрузку класса передается родительскому загрузчику, и попытка загрузить класс самостоятельно выполняется, только если родительский загрузчик не смог найти и загрузить класс. Такой подход позволяет загружать классы тем загрузчиком, который максимально близко находится к базовому. Так достигается максимальная область видимости классов. Каждый загрузчик ведет учет классов, которые были загружены именно им, помещая их в свой кэш. Множество этих классов и называется областью видимости.
#### Видимость
Загрузчик видит только «свои» классы и классы «родителя» и понятия не имеет о классах, которые были загружены его «потомком».
#### Уникальность
Класс может быть загружен только однажды. Механизм делегирования позволяет убедиться, что загрузчик, инициирующий загрузку класса, не перегрузит загруженный ранее в JVM класс.

Таким образом, при написании своего загрузчика разработчик должен руководствоваться этими тремя принципами.

### Логика загрузки классов
Когда происходит вызов загрузки какого-либо класса, происходит поиск этого класса в кэше уже загруженных классов текущего загрузчика.

Если желаемый класс еще не загружался ранее, по принципу делегирования управление передается родительскому загрузчику, который находится по иерархии на уровень выше. Родительский загрузчик также пытается найти желаемый класс у себя в кэше. Если класс уже был загружен и загрузчик знает о его местонахождении, то будет возвращен объект Class этого класса. Если нет, поиск будет продолжаться до тех пор, пока не дойдет до базового загрузчика. Если и в базовом загрузчике нет информации об искомом классе (т.е. он еще не был загружен), будет выполнен поиск байт-кода этого класса по расположению классов, о котором знает данный загрузчик, и, если загрузить класс не удастся, управление вернется обратно загрузчику-потомку, который будет пытаться выполнить загрузку из известных ему источников. Как уже упоминалось выше, расположение классов для базового загрузчика это библиотека rt.jar, для загрузчика расширений – каталог с расширениями jre/lib/ext, для системного – CLASSPATH, для пользовательского это может быть что-то свое.

Таким образом, ход загрузки классов идет в обратном направлении - от корневого загрузчика до текущего. Когда байт-код класса найден, происходит загрузка класса в JVM и получение экземпляра типа Class.

### Исключения

Исключение ClassNotFoundException возникает при динамической загрузке класса во время выполнения программы, когда загрузчики не могут найти требуемый класс ни в кэше, ни по пути нахождения классов.

А вот ошибка NoClassDefFoundError является более критичной и возникает в том случае, когда во время компиляции искомый класс был доступен, но не виден во время выполнения программы. Это может произойти, если в поставку программы забыли включить библиотеку, которую она использует.**



