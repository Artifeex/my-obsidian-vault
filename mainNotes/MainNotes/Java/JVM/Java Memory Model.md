Код, который мы написали в программе и который реально выполнится - может отличаться. Инструкции могут быть переставлены компилятором(причем как JIT так и байткода) или выполниться процессором в другом порядке(процессор может построить по его мнению более оптимальный вариант).

Но тогда непонятно, как написать программу, которая работала корректно. Но 
существует гарантия as-if-serial - которая говорит, что как бы компилятор или процессор не выполнили код, который мы написали(даже в другом порядке) результат не должен измениться. Но проблема в том, что это гарантия работает только внутри одного потока. Т.е. если какой-то один поток ориентируется на то, что второй поток выполнит код в определенном порядке, то может возникнуть ошибка.

Например:
![[Pasted image 20241024225225.png]]
Если T1 выполнить в одном потоке, а Т2 в другом потоке, то можем получить один из 4-х выариантов значений для r1 и к2:
(0, 0) - в коде обоих потоков сначала была выполнена операция чтения r1 и r2. Т.е. х и y были равны 0, потом произошло чтение и в r1 и r2 записались 0, а потом только произошла инициализация.
(1, 0)
(0, 1)
(1, 1) - самый простой вариант, код выполнился в том порядке, в котором мы написали.


### Модель памяти
В общем, нам нужна поддержа со стороны спецификации языка. Поэтому более надежное решение — это создание так называемой _модели памяти_ (memory model), которая строго описывает какое выполнение программы является валидным. Модель памяти делает легальными многие оптимизации компилятора, JVM и процессора, но в то же время закрепляет условия, при которых программа будет вести себя корректно в многопоточной среде даже в присутствие оптимизаций. Таким образом, модель памяти:
- Разрешает выполнение различных оптимизаций компилятора, JVM или процессора
- Строго закрепляет условия, при которых программа считается правильно синхронизированной, и закрепляет поведение правильно синхронизированных программ
- Описывает отношение между высокоуровневым кодом и памятью
- Является trade-off между строгостью исполнения кода и возможными оптимизациями

Так вот, Java имеет свою модель памяти под названием **Java Memory Model** (JMM). По умолчанию JMM разрешает любые переупорядочивания и не гарантирует видимости изменений. Однако _при выполнении определенных условий_ нам гарантируется порядок действий, консистентный с порядком в коде, а также видимость всех изменений. Таким образом, JMM позволяет нам писать программы, которые будут полностью корректно работать среди множества различных имплементаций JDK и микро-архитектур процессоров, в то же время сохраняя преимущества оптимизаций.

Т.е. в JMM описаны условия, которые мы должны выполнить нашим кодом, чтобы РЕЗУЛЬТАТ выполнения был таким, как мы задумали, даже если он реально переставится.