![[Pasted image 20241107205207.png]]
![[Pasted image 20241107205232.png]]
![[Pasted image 20241107205248.png]]
![[Pasted image 20241107205343.png]]
![[Pasted image 20241107205434.png]]
![[Pasted image 20241107205722.png]]
![[Pasted image 20241107205835.png]]
![[Pasted image 20241107205946.png]]
### Практика
Обычно создают в main директорию proto, в котором и создают все proto файлы
![[Pasted image 20241107210602.png]]
HelloRequest - это мы описываем как раз то сообщение, которое будет пересылаться на сервер. Теги нужны для того, чтобы не передавать целом имя, а только число, вместо имени.
Например, вместо передачи name, мы можем передать 1, что будет заниматься сильно меньше места. Просто на сервере будет сохранено как сопоставлять теги и имена и сервер по тегу = 1 будет понимать, что имелось в виду имя ключа name.
![[Pasted image 20241107211052.png]]
Request и Response:
![[Pasted image 20241107211336.png]]
service - логическое объединение несколько rpc методов. Все rpc методы находятся внутри сервисов.
Опишем rpc метод greeting
![[Pasted image 20241107211612.png]]
Как будет все работать? На клиенте мы вызовем метод greeting, выполнится сетевой запрос, в котором передается HelloRequest + сервер узнает, что был вызов удаленного метода, сервер вызовет greeting, выполнит его и потом по сети вернется HelloReponse, который вернет метод greeting.
Осталось только сгенерировать java классы из этого proto файла, в которых будет реализация всей пересылки данных по сети, нам же останется только реализовать внутренность метода greeting.

Подключив необходимые зависимости и выполнив сборку проекта мы увидим 2 сгенерированных Java класса:
![[Pasted image 20241107212048.png]]
- GreetingServiceGrpc - это как раз вся основа, в которой и описано все взаимодействие. Нам же нужно будет отнаследоваться от вложенного внутри этого класса класса и определить поведение метода greeting.
- GreetingServiceOuterClass - в нем описываются сообщения - HelloRequest и HelloResponse.
Наследуемся от вложенного класса GreetingServiceImplBase
![[Pasted image 20241107212347.png]]
![[Pasted image 20241107212611.png]]
Почему такой неитутивный код? Почему reponse не возвращается из greeting, а принимается, так еще и обернут вокруг StreamObserver?
Это потому что gRPC позволяет стримить поток данных, а не только один объект. Поэтому, если бы мы возвращали результат из greeting, то вернуть могли только 1 объект. 
В StreamObserver мы можем как ответить 1 ответом, так и любым количеством ответов, поэтому мы и сможем перейти на стриминг данных! Мы будем вызывать на reponseObserver объекте метод и каждый такой вызов будет возвращать response на клиента. Мы не ждем, когда клиент как-то ответит, а просто пересылаем данные когда и сколько хотим.
![[Pasted image 20241107213242.png]]
![[Pasted image 20241107213337.png]]
Создаем сервер:
![[Pasted image 20241107213620.png]]
![[Pasted image 20241107213727.png]]
### Создаем клиента
Создаем новый java проект и в нем также создаем директорию proto и скопируем файл proto, который написали до этого.
![[Pasted image 20241107214647.png]]
![[Pasted image 20241107214745.png]]
### Настроим отправку потока данных между сервером и клиентом
Чтобы теперь возвращать методом greeting не 1 response, а stream(т.е. поток объектов HelloResponse) нам всего лишь нужно добавить в service в сигнатуру метода stream:
![[Pasted image 20241107215013.png]]
Перепишем метод greeting на сервере. В цикле будем вызывать создание response и его отправку onNext:
![[Pasted image 20241107215252.png]]
В клиентском proto файле также нужно добавить stream, как мы это сделали на сервере.
Клиент:
![[Pasted image 20241107215625.png]]
