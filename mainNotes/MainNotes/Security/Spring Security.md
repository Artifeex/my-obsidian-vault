### If else value in application.yml
Мы можем указывать с левой стороны название переменной, которую кто-нибудь при желании может передать как environment переменную при деплое и тогда будет использоваться она. Если же ничего не будет передано, то будет использовать значение, находящееся справа от ":"
![[Pasted image 20241220095440.png]]
### Security dependecy
Когда мы подключаем security dependecy, то благодаря автоконфигурации используется базовая реализация, в которой при любом запросе нас будет перекидывать на страничку логина:
![[Pasted image 20241220100222.png]]
А в консоли генерируется пароль для входа. username - user.
![[Pasted image 20241220100240.png]]
Также Spring автоматически запоминает нашу сессию и если перезагрузить страницу, то не нужно будет снова вводить логин и пароль.
Откуда берутся логин и пароль? Они заданы внутри SecurityProperties внутри вложенного класса:
![[Pasted image 20241220100811.png]]

### Здесь можно посмотреть основные properties
https://docs.spring.io/spring-boot/3.3/appendix/application-properties/index.html

### Зададим свои настройки, чтобы не копировать сгенерированный пароль, а использовать один и тот же
![[Pasted image 20241220101455.png]]

### Ответственность
![[Pasted image 20241220110626.png]]
### Servlets and Filters
Много security функциональности в приложении реализовано благодаря фильтрам и сервлетам.
![[Pasted image 20241220110903.png]]
### Spring Security Internal Flow
![[Pasted image 20241220111558.png]]
1. Client Application отправляет запрос. Данный запрос ловится Spring Security Filters и они выполняют работу с security. Например, есть фильтр, который проверяет аутентифицирован пользователь или нет. Если нет, то перенаправляет запрос на страницу логина. Фильтров в security много и их количество зависит от нашей конфигурации. 
2. Если пользователь передал свои credentials(данные для входа) в запросе, то один из фильтров должен преобразовать эти credentials, которые хранятся в HTTP Requeste(в body в основном) в объект Authentication, с которым уже будет удобно работать и с которым будут работать другие компоненты Spring Security. В Authentication объекте есть username, password, isAuthenticated(boolean поле). Когда такой объект Authentication впервые создается, то эта булева переменная = false. В общем, Authentication объект используется для сохранения в нем user credentials, а также в нем хранится информация о том, аутентифицирован данный пользователь или нет.
3. После того как был создан Authentication объект фильтры передают запрос в Authentication Manager. Authentication Manager ответственен за аутентификацию пользователя. В него отправили Authentication объект и он на основе той информации, что в нем хранится и с помощью дополнительных компонентов производит аутентификацию и потом вернет результат аутентификации обратно в фильтры, чтобы они решили, что делать дальше.
4. Authentication Manager взял на себя отвественность, что выполнит аутентификацию, но он не выполняет ее напрямую, а поручает ее Authentication Providers. Их может быть несколько для нескольких вариантов аутентификации. 
5. Authentication Provider использует UserDetailsService. UserDetailsService ответственен за то, чтобы получить User Details(вытащить из БД по username информацию о пользователе) по username, который был сохранен в Authentication объекте. После получения User Details UserDetailsService передает его обратно в Authentication Provider. 
6. Authentication Providers использует PasswordEncoder. Authentication Provider не может сравнить password, который передал user и который сохранен в Authentication и тот, что реально хранится в БД, поскольку в БД мы не храним raw пароли, а храним их в закодированной форме. Поэтому нам и нужен еще и Passowrd Encoder, который мы можем попросить сравнить пароль, который мы получили от пользователя при аутентификации(в Authentication объекте) и тот, что реально хранился в БД.
7. После того, как Password Encoder подтвердил, что пароли совпадают, то Authentication Provider сообщает Authentication Manager-у, что аутентификация прошла успешно. Как он сообщает? Он возвращает все тот же Authentication объект, но в нем уже boolean переменная isAuthenticated = true.
8. Этот же Authentication объект отправляется обратно в фильтры.
9. Не зависимо от того, прошла аутентификация успешно или нет фильтр сохраняет результат аутентификации в Security Context, который похож на Map. Ключом является JSESSIONID(кука, которая присваивается клиенту при POST запросе с отправкой формы логина) а значением этой Map является Authentication объект. Для чего сохранять ? Чтобы, когда клиент обратился к нашему сервису еще раз, то мы могли зайти в Security Context и получить по JSESSIONID из запроса информацию, что пользователь уже аутентифицирован и не нужно его повторно аутентифицировать. 
   
   Шаги с 3 по 8(когда выполняется реальная работа по аутентификации) происходят только при первом запросе. Решение о том, нужно обращаться к Authentication Manager или нет происходит с помощью проверки, есть ли в Security Context JSESSIONID данного пользователя или нет(он передается в куки). 
10. В зависимости от результатов аутентификации будет либо отправлен ответ с успешной аутентификацией, либо ошибка.

![[Pasted image 20241220115810.png]]
Мы можем передать уровень логирнования для секьюрити, чтобы в консоли проследить, как реально под капотом вызываются те компоненты, которые мы обсуждали ранее.
![[Pasted image 20241220120034.png]]

### Authorization Filter
![[Pasted image 20241220120701.png]]Данный фильтр ответственен за то, чтобы определить пытается ли пользователь получить доступ к protected ресурсу без переди credentials или без authenticated session.

В нем есть метод:
![[Pasted image 20241220121035.png]]

### DefaultLoginPageGeneratingFilter
Эту ошибку отлавливает DefaultLoginPageGeneratingFilter, который перенаправляет пользователя на login page и генерирует саму login page.

### Какие фильтры обрабатывают POST запрос с текстом логин формы
![[Pasted image 20241220121921.png]]
Рассмотрим его реализацию:
![[Pasted image 20241220122001.png]]

![[Pasted image 20241220133307.png]]
Если все-таки аутентификация нужна, то вызывается метод attempAuthentication:
![[Pasted image 20241220133513.png]]
В конце методы мы видим создание какого-то UsernamePasswordAuthenticationToken. Но мы же говорили, что должен создаваться Authentication. Ответ: Authentication - это интерфейс, а, следовательно, его объекты мы не можем создавать. Поэтому нужен класс, который реализует этот интерфейс - и этим классом и является UsernamePasswordAuthenticationToken.
Внутри метода unauthenticated вызывается конструктор:
А в конструкторе заполняются поля, а также boolean переменная, о которой мы говорили isAuthenticated устанавливается в false.
![[Pasted image 20241220134454.png]]
![[Pasted image 20241220134515.png]]
И потом мы видим, что дальше созданный Authentication объект отправляется в authenticationManager:
![[Pasted image 20241220134610.png]]

Если зайдем внутрь authenticate метода, то увидим, что он вызывается на объекте класса ProviderManager, который реализует интерфейс AuthenticationManager
![[Pasted image 20241220134719.png]]
Внутри authenticate метода:
![[Pasted image 20241220134810.png]]
Самое важное здесь это for цикл по всем доступным AuthenticationProvider-ам.
![[Pasted image 20241220134918.png]]
И мы видми, что если result != null, то, значит, один из AuthenticationProvider-ов смог провести аутентификацию и дальше нет смысла утруждать другие, поэтому там break.

В нашем случае, когда мы используем дефолтный Spring Security по умолчанию используется DaoAuthenticationProvider:
![[Pasted image 20241220135142.png]]
У него есть метод authenticate:
![[Pasted image 20241220135330.png]]
Зайдем в метод receiveUser:
![[Pasted image 20241220135709.png]]
Внутри loadUserByUsername. Причем стоит заметить, что этот метод также находится в классе, который предоставлен Spring по умолчанию InMemoryUserDetailsManager:
![[Pasted image 20241220135802.png]]
![[Pasted image 20241220135905.png]]

После того, как мы получили User-а, нам нужно сравнить пароли. Это происходит внутри additionalAuthenticationChecks:
![[Pasted image 20241220140052.png]]

А вот и сравнение:
![[Pasted image 20241220140207.png]]

### Справка по стандартному поведению аутентификации Spring Security
![[Pasted image 20241220140850.png]]

Тоже самое, но меньше деталей
![[Pasted image 20241220140947.png]]

### Как работает механизм, который после успешной аутентифкации не заставляет по новой вводить свои данные для входа 
В cookies сохраняется JSESSIONID. И по нему и происходит проверка, есть ли в SecurityContext Authentication.
![[Pasted image 20241220141221.png]]

### SpringBoot класс, который автоконфигурацией настраивает поведение по умолчанию, когда любой запрос требует аутентификации:
![[Pasted image 20241220170838.png]]
http.authorizeHttpRequests - этой строчкой мы как раз задали, что для доступа к любой страничке нужна аутентификация.
А дальше мы включаем различные стили аутентификации:
- http.formLogin() - включили аутентификация через логин форму, когда мы вводим данные в HTML форме и отправляет POST запрос на аутентификацию.
- http.httpBasic - включили basic аутентификацию. Это когда данные передается в base64 и не через HTML форму, а в headere.

### Напишем свой Bean SecurityFilterChain, который полностью заменяет тот, что предоставляет нам Spring
Есть permitAll - которая разрешает доступ для всех и анонимных юзеров и аутентифицированных.
Есть denyAll - запрещает доступ и анонимных и аутентифицированных.
![[Pasted image 20241220172748.png]]
Создадим Configuration класс в котором создадим SecurityFilterChain. В requestMatchers указываем пути, которые будут требовать аутентификацию, и которые будут доступны всем.
![[Pasted image 20241220173026.png]]

Также стоит добавить в permitAll путь до /errors, т.к. Spring по дефолту редиректит на эту страницу в том случае, если прозошел runtime error, который не поймали. Но можем добавить ее и в authenticated, если хотим, чтобы Runtime ошибка выводилась только для аутентифицированных пользователей.
![[Pasted image 20241220173431.png]]

### Отключение formLogin и httpBasic authentication
Форма логина нужна не всем приложениям. Например, если это мобильное приложение, то ему форма логина не нужна. Поэтому мы можем отключить ее:
`http.formLogin(flc -> flc.disable())`
Когда у нас включена форма логина, то за создание Authentication начинает отвечать UsernamePasswordAuthenticationFilter

Когда у нас включена basic authentication, то созданием Authenticaion занимается:
BasicAuthenticationFilter
basicAuthentication:
![[Pasted image 20241223112348.png]]

Когда мы используем basic authenticaton, то credentials передаются внутри хедера "Authorization". Значением этого хедера является Basic + данные в base64 кодировке:
![[Pasted image 20241223112541.png]]
В Base64 хранится так: "username:password". 
Сам метод, который занимается созданием Authentication(UsernamePassowrdAuthenticationToken - реализация интерфейса Authentication.)
![[Pasted image 20241223113037.png]]

Отключить basic authentication:
`http.httpBasic(hbc -> hbc.disable());`

Если мы отключим и basic и form authentication, то будем получать 403 статус:
![[Pasted image 20241223113327.png]]

В будущем мы научимся писать свои виды аутентификации!

### Чтобы в Postman делать проверки basic authentication:
![[Pasted image 20241223114824.png]]
В хедере будет Authorization:
![[Pasted image 20241223114848.png]]

### До этого мы задали username и password для usera нашего приложения внутри application.yml файла. Но мы хотим, чтобы нам приложением могли пользоваться сразу много людей, поэтому нам такой вариант не подходит
Для решения этой проблемы мы должны будем сохранять пользователей в БД или каком-либо другом хранилище.

Для начала создадим бин, который будет реализовывать интерфейс [[UserDetailsService]] - это тот интерфейс, который умеет получать UserDetails из БД вызовом метода loadUserByUsername.

Создадим пока что пользователей в памяти:
![[Pasted image 20241223121308.png]]
Когда мы создаем юзера таким образом, что выше, то по дефолту не используется никаких энкодеров. Пароли хранятся в том виде, в котором они есть.
![[Pasted image 20241223121506.png]]

Но если мы все оставим так, то после ввода пароля мы получим 500 ошибку. Если не настроен кодировщик паролей, то Spring выбрасывает исключение в том случае, если пароль не помечен префиксом - {noop}. Т.е. либо мы настраиваем энкодер паролей, либо используем для паролей: "{noop}password" при сохранении. 

### [[PasswordEncoder]]
После создание PasswordEncoder:
![[Pasted image 20241223122939.png]]
Закодированный пароль будет в hash формате из которого невозможно получить исходное значение.

noop - это префикс энкодера. В случае noop никакой encoder не работает. Но мы можем использовтаь и другие префиксы для энкодеров и тогда при валидации и извлечении данных из БД будет использован тот энкодер, префикс которого использовался.  

И теперь при сохранении пользователя мы сохраняем уже закодированный пароль.(Для кодировки мы использовали сайтик, но в будущем можно будет использовать энкодер, чтобы закодировать пароль. Но т.к. мы пока сохраняем пароль в source, а не получаем от пользователя в runtime, то мы кодируем, т.к. не хотим, чтобы в source хранился пароль, который будет всем виден)
![[Pasted image 20241223134241.png]]

### Как запретить пользователю использовать простые пароли?
Для этого используется CompromisedPasswordChecher.

Это интерфейс, который используется для проверки пароля.
![[Pasted image 20241223135207.png]]
Вот класс, который его реализует. Он идет на сайт, на котором собираются пароли, которые слиты в сеть благодаря утечкам данных и проверяет нет ли пароля, введенного пользователем в этих слитых паролях. Но нам никто не мешает написать свой класс, который будет реализовывать интерфейс CompomisedPasswordChecker.
![[Pasted image 20241223135320.png]]


### UserDetailsService vs UserDetailsManager
![[Pasted image 20241223140115.png]]

Логика такая - есть UserDetailsService - это базовый интерфейс, который формирует контракт на выполнение метода, возвращающего UserDetails. UserDetails - это дословно детали о пользователе. Т.е. этот интерфейс описывает методы, которые нужны для того, чтобы описать конечного пользователя системы. И т.к. это интерфейс, то Spring также предлагает его базовую реализацию - класс User. 

### UserDetails vs Authentication
 Это два интерфейс, которые нужны для представления информации о конечном пользователе. Но, где какой используется?
 Principal - интерфейс из JDK. В нем абстрактный метод getName().
 ![[Pasted image 20241223142348.png]]
 UserDetails используется только в моменте аутентификации пользователя. UserDetails предоствляет информацию и пользователе, который сохранен в БД. И дальше, например, проверки совпадения пароля происходит между тем паролем, что находится внутри UserDetails и тем паролем, что передан в Authentication тем пользователем, что пытается залогиниться. И в том случае, если аутентификация прошла успешно, то для Authentication объекта устанавливается флаг в isAuthencitated = true и дальше Authentication объект возвращается обратно в фильтры, где уже на основе этого флага определяется, успешна ли аутентификация. 
![[Pasted image 20241223142551.png]]

В Authentication интерфейсе есть интересный метод - eraseCredentials. В нем стирается пароль, чтобы он не хранился внутри Authentication объекта(а точнее реализации этого интерфейса(наиболее популярной) - UsernamePasswordAuthenticationToken). 

Зачем и когда стирать пароль? пароль стирается после успешной проверки аутентификации пользователя. Нет смысла после того, как мы поняли, что пользователь аутентифицирован тоскать его пароль по системе. Поэтому этот метод вызывается спрингом по умолчанию после того, как аутентификация была выполнена. 
![[Pasted image 20241223143307.png]]

Вот место, в котором происходит использование Authentication объекта и получение UserDetails объекта - это все внутри AuthenticationProvidera.
![[Pasted image 20241223143649.png]]
Логика такая - в методе authenticate, который должен провести аутентификацию пользователя вызывается метод retrieveUser, в котором извлекаются UserDetails из БД. Если такого пользователя там нет, то, значит, сразу завершаем аутентификацию, а если есть, то продолжаем. Если продолжаем, то, значит, для переданного username такой пользователь есть, а, значит, мы должны сравнить пароли. И в методе additionalAuthenticationChecks и выполняется сравнение паролей:
![[Pasted image 20241223144120.png]]

Вот сравнение:
![[Pasted image 20241223144347.png]]
Если все проверки прошли, то внутри метода authenticate вызывается метод createSuccessAuthenticaton:
![[Pasted image 20241223144536.png]]
В нем создается объект Authentication из данных в UserDetails.
![[Pasted image 20241223144525.png]]
### Хотим начать использовать БД для хранения пользователей. 
Будем использовать mysql. И также мы будем использовать дефолтную реализацию JdbcUserDetailsManager для работы с юзерами. Внутри users.ddl мы можем найти какие таблицы должны быть в БД, чтобы JdbcUserDetailsManager мог работать. 
![[Pasted image 20241223154041.png]]
Создаем JdbcUserDetailsManager:
![[Pasted image 20241223163217.png]]
Но это такой себе вариант, поскольку мы полностью ограничены этим JdbcUserDetailsManager и той схемой, которая должна быть у нашего приложения. Но мы не хотим иметь такие ограничения.

### Напишем свой UserDetailsService, чтобы избавиться от ограничений, наложенных использованием JdbcUserDetailsManager

Создадим свою собственную таблицу для пользователей. Назовем ее customer. 
![[Pasted image 20241223163741.png]]

Также создаем Entity и Repository для этой таблицы:
![[Pasted image 20241223165039.png]]
![[Pasted image 20241223165048.png]]

Создаем свой класс, который будет реализовывать интерфейс UserDetailsService. И в нем используем репозиторий, чтобы извлечь информацию о пользователе. А дальше Spring будет использовать наш бин типа UserDetailsService. Только главное, чтобы мы не создавали где-то еще бины такого же типа UserDetailsService. 
![[Pasted image 20241223170608.png]]

### Controller для регистрации
![[Pasted image 20241223171826.png]]
Но нужно еще добавить этот путь в SecurityFilterChain как permitAll, а также в SpringSecurity для HTTP методов, изменяющих данные(POST, PUT, DELETE) требуется CSRF защита. Если мы ничего не будем делать, то из-за требований CSRF защиты мы будем получать 403 статус для наших ответов. И у нас два варианта, либо реализовать CSRF защиту для нашего приложения, либо отказаться от CSRF. В будущем мы рассмотрим тему CSRF подробнее, а пока можем просто ее отключить.

### Validation password without password encoder
![[Pasted image 20241224091434.png]]
### Пароли в БД храним только в зашифрованном виде
![[Pasted image 20241224091808.png]]

### Encoding vs Encryption vs Hashing
![[Pasted image 20241224091914.png]]
![[Pasted image 20241224093241.png]]
Encoding - преобразовываем данные из одного формата в другой. При этом потом эти преобразованные данные мы МОЖЕМ ВОССТАНОВИТЬ в исходный формат. 
Т.к. можно восстановить исходные данные, то encoding не подходит для паролей.
Пример использования: отправка email с фотографией. Фотография - это бинарные данные, а по почте можем пересылать только тестовые, поэтому мы кодируем фото в BASE64 и получаем из фото текстовые данные. И потом они отправляются, а на принимающей стороне также используется base64, чтобы уже декодировать и получить исходный файл.

Encryption - преобразование данных из одного формата в другой, но при этом теперь для преобразования используется алгоритм + secret key. Теперь для того, чтобы получить исходные данные нужно воспользоваться secret key - без него преобразовать данные в исходный формат не получится. Также не является рекомендуемым подходом, поскольку, если кто-нибудь получит доступ к secret key, то он сможет расшифровать все данные.

В encryption разделяют 2 вида ключей - симметричные и асимметричные. Симметричные - один ключ используется и для шифрования и для дешифрования: 
![[Pasted image 20241224093404.png]]
Симметричный ключ можно использовать только тогда, когда мы используем подход data at rest. Data at rest - это состояние, когда данные не перемещаются по сети, а хранятся где-либо в одном месте. Например, это AWS S3 хранилище, где мы можем сохранять фото, видео и т.д. Но чтобы не хранить данные в открытом виде, чтобы злоумышленник не смог получить все данные, получив доступ к S3 - мы шифруем такие данные и secret key хранится только внутри AWS S3 и никуда наружу он не выходит. Т.е. мы ни с кем не делимся этим ключом. 

Если же наше приложение А общается с другими приложениями и хочет шифровать данные при общении, то, чтобы расшифровать такие данные другим приложениям нужно будет знать secret key. И в случае, если мы используем симметричный подход - если хотя бы одно приложение, с которым общается приложение А взломают и узнают secret key, то вся система будет под угрозой, а не только то приложение, которое взломали.
![[Pasted image 20241224094342.png]]


![[Pasted image 20241224094511.png]]
Асимметричный ключ - используется 2 вида ключей. 
public key - ключи, которые раздаются всем желающим, кто хочет уметь шифровать данные для общения. 
private key - ключ, которые находится только у ownera всего шифровательного процесса. Только с помощью private ключа мы можем расшифровать данные. Этот private ключ не передаются никуда вовне, чтобы избежать проблему симметричного ключа, когда взлом одной системы приводит к тому, что весь процесс шифрования всей системы сводится на нет. 

Такой подход отлично подходит для data in transit(перемещающиеся данные).
Приложение А хочет получить данные из приложения B. Но оно боится, что данные, которые будут передаваться по сети могут быть перехвачены кем-либо, поэтому нужно, чтобы данные передавались в зашифрованном виде. Поэтому приложение А создает public и private key. public key передает приложению B, чтобы оно смогло зашифровать данные и передать их по сети приложению А. Когда зашифрованные данные будут доставлены до приложения А, то оно сможет их расшифровать, используя private key.

Почему не подходит для паролей? Потому что мы не можем гарантировать, что кто-либо в нашей компании не сможет втереться в доверие и каким-нибудь образом не узнать secret key.


Hashing - процесс преобразования данных, используя hash функцию. Данные, которые были преобразованы хэш функцией невозможно вернуть в исходное состояние. Т.е. даже если мы знаем функцию хэширования и сам хэш, то нам это ничего не даст. Функция хэширования не умеет преобразовывать данные из хэша в исходный текст из которого хэш был получен.

Из интересного - какой бы длины мы не передали данные на вход в хэш функцию - мы получим хэш одной и той же длины. Например, если мы используем SHA-256 то длина будет 256 бит для хэша. 

Отлично подходит для паролей, а также для проверок целостности данных. Если мы знаем, как должны выглядеть целостные данные, то мы можем для них посчитать хэш. И потом, когда передаем данные, то принимающая сторона может также посчитать хэш тех данных, которые приняла, а потом сравнить наш хэш и посчитанный хэш. И если совпадают, то данные переданы целостно, а если нет, то, значит, ошибка при передачи и нужно попробовать снова. Ну и также мы тем самым можем обеспечить, что пока мы скачивали данные - никто не смог подменить какие-то кусочки файла и добавить в них вредоносный код. 

### Недостатки hashing варианта
1) Если у нас много юзеров в системе, то есть большой шанс, что несколько из них могут использовать одинаковый пароль. А т.к. хэш для одинаковых значений - одинаковый, то и в БД будет храниться один и тот же хэш для нескольких пользователей. 

Если хакер завладает данные из БД - username + хэш пароля, то дальше он может выполнять различные атаки:
1) Brute force attack - он возьмет топ самых популярных паролей и посчитает для них хэш и будет сравнивать с тем хэшом, который он получил из БД. Страшно не то, что он таким образом сможет угадать пароль 1-го пользователя, а то, что раз хэш этого пароля повторется у нескольких пользователей, то это значит, что этот пароль будет подходить для нескольких пользователей!
2) Dictionary table attack -  схема похожая на brute force вариат. Только тут заранее создается таблица с хэшами всех популярных паролей, а не происходит динамическое вычисление хэша при подборе пароля. 
3) Есть улучшенный вариант Dictionary Table - это Rainbow table. Логика та же, но данные хранятся как-то более оптимизированно в таблице, чтобы увеличить скорость поиска, а также уменьшить место, занимаемое для хранения. 

В общем, основные недостатки:
1) Для одного и того же пароля- вернется один и тот же результат. Что плохо, потому что пользователи могут использовать одинаковые пароли.
2) Быстро вычисляется хэш, поэтому brute force реален.

### Как преодолеть недостатки хэшинга
1) Использовать соль при хэшировании пароля. Соль - это какое-то рандомное число, которое генерируется перед тем, как захэшировать пароль. После того, как сгенерировали соль, то мы добавляем ее к паролю, т.е. получаем salt + password. Потом мы вычисляем хэш: hash(salt + password) - и сохраняем его в БД. А также в БД сохраняется и соль, которая использовалась при хэшировании. 
   
   Какую проблему решили? 
   - Решили проблему с тем, что у пользователей может быть одинаковый пароль. Т.к. соль генерируется рандомно на сервере в момент регистрации, то даже для одинаковых паролей у двух пользователей будет разный хэш из-за того, что они будут иметь разные значения соли. 
   - Решили проблему rainbow table, т.к. теперь такая таблица с заранее посчитанными хэшами бесполезна, поскольку там хэши паролей. А у нас в БД теперь хранится хэш(соль + пароль).

Но это не решает проблему brute force в том плане, что хакер может пытаться подбирать пароль. Но для этого мы уже используем доп механизм - количество попыток авторизоваться. А также требовать при авторизации более сложные пароли от пользователя, которые хакеру придется подбирать очень долго.

Но как быть в том случае, если хакер получил доступ ко всей БД. А это значит, что он теперь знает соль для пароля. И теперь он снова может брут форсом пытаться посчитать. А т.к. хэш функции считаются быстро(порядка наносекунд на вычисление), то он за какое-то адекватное время сможет подобрать пароль. А тут оказывается, что мы можем НАМЕРЕННО ЗАМЕДЛИТЬ вычисление hash функции. Т.е. специально использовать хэш функцию, которая долго вычисляет значение, например, порядка 1-2 секунд. И тогда даже для того, чтобы попробовать миллион комбинаций(что не очень много для перебора) потребуется 11 дней. Помимо того, что долго - такие функции при вычислении требуют еще и мощное железо, чтобы вычислиться, т.е. если у хакера не очень мощное железо, то вычисление такой хэш функции может стать еще дольше, чем у нас на бекенде, где стоит мощное железо.

BCrypt(рекомендуется спрингом по умолчанию и используется по умолчанию), SCrypt - как раз такие намеренно замедленные хэширующие функции. 

### Проверка пароля в Spring с использованием password encoders
![[Pasted image 20241224111400.png]]
Spring при использовании энкодеров оказывается умеет извлекать соль из хэша, который хранится в БД! И это все происходит без нас. Т.е. когда пользователь пытается залогиниться, то Spring извлекает по такому username hash из БД. Дальше из этого hash извлекает соль и потом вычисляет хэш для соль + пароль, который передал пользователь при логине. И если хэш совпал с тем, что получили из БД - аутентификация прошла успешно. 

Соль хранится как часть хэша:
![[Pasted image 20241224112427.png]]


### [[AuthenticationProvider]]

### [[Environment specific Security Configurations]]

### [[AcceptingOnlyHTTPS]]

### [[ExceptionHandlingSpringSecurity]]

### [[Session Security]]

### [[Authentication Events]]

### [[Security Context & Security Context Holder]]

### [[CORS & CSRF]]

### [[Authorization]]

### [[Custom Filters]]

### [[JWT Authentication]]