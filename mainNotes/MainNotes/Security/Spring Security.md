### If else value in application.yml
Мы можем указывать с левой стороны название переменной, которую кто-нибудь при желании может передать как environment переменную при деплое и тогда будет использоваться она. Если же ничего не будет передано, то будет использовать значение, находящееся справа от ":"
![[Pasted image 20241220095440.png]]
### Security dependecy
Когда мы подключаем security dependecy, то благодаря автоконфигурации используется базовая реализация, в которой при любом запросе нас будет перекидывать на страничку логина:
![[Pasted image 20241220100222.png]]
А в консоли генерируется пароль для входа. username - user.
![[Pasted image 20241220100240.png]]
Также Spring автоматически запоминает нашу сессию и если перезагрузить страницу, то не нужно будет снова вводить логин и пароль.
Откуда берутся логин и пароль? Они заданы внутри SecurityProperties внутри вложенного класса:
![[Pasted image 20241220100811.png]]

### Здесь можно посмотреть основные properties
https://docs.spring.io/spring-boot/3.3/appendix/application-properties/index.html

### Зададим свои настройки, чтобы не копировать сгенерированный пароль, а использовать один и тот же
![[Pasted image 20241220101455.png]]

### Ответственность
![[Pasted image 20241220110626.png]]
### Servlets and Filters
Много security функциональности в приложении реализовано благодаря фильтрам и сервлетам.
![[Pasted image 20241220110903.png]]
### Spring Security Internal Flow
![[Pasted image 20241220111558.png]]
1. Client Application отправляет запрос. Данный запрос ловится Spring Security Filters и они выполняют работу с security. Например, есть фильтр, который проверяет аутентифицирован пользователь или нет. Если нет, то перенаправляет запрос на страницу логина. Фильтров в security много и их количество зависит от нашей конфигурации. 
2. Если пользователь передал свои credentials(данные для входа) в запросе, то один из фильтров должен преобразовать эти credentials, которые хранятся в HTTP Requeste(в body в основном) в объект Authentication, с которым уже будет удобно работать и с которым будут работать другие компоненты Spring Security. В Authentication объекте есть username, password, isAuthenticated(boolean поле). Когда такой объект Authentication впервые создается, то эта булева переменная = false. В общем, Authentication объект используется для сохранения в нем user credentials, а также в нем хранится информация о том, аутентифицирован данный пользователь или нет.
3. После того как был создан Authentication объект фильтры передают запрос в Authentication Manager. Authentication Manager ответственен за аутентификацию пользователя. В него отправили Authentication объект и он на основе той информации, что в нем хранится и с помощью дополнительных компонентов производит аутентификацию и потом вернет результат аутентификации обратно в фильтры, чтобы они решили, что делать дальше.
4. Authentication Manager взял на себя отвественность, что выполнит аутентификацию, но он не выполняет ее напрямую, а поручает ее Authentication Providers. Их может быть несколько для нескольких вариантов аутентификации. 
5. Authentication Provider использует UserDetailsService. UserDetailsService ответственен за то, чтобы получить User Details(вытащить из БД по username информацию о пользователе) по username, который был сохранен в Authentication объекте. После получения User Details UserDetailsService передает его обратно в Authentication Provider. 
6. Authentication Providers использует PasswordEncoder. Authentication Provider не может сравнить password, который передал user и который сохранен в Authentication и тот, что реально хранится в БД, поскольку в БД мы не храним raw пароли, а храним их в закодированной форме. Поэтому нам и нужен еще и Passowrd Encoder, который мы можем попросить сравнить пароль, который мы получили от пользователя при аутентификации(в Authentication объекте) и тот, что реально хранился в БД.
7. После того, как Password Encoder подтвердил, что пароли совпадают, то Authentication Provider сообщает Authentication Manager-у, что аутентификация прошла успешно. Как он сообщает? Он возвращает все тот же Authentication объект, но в нем уже boolean переменная isAuthenticated = true.
8. Этот же Authentication объект отправляется обратно в фильтры.
9. Не зависимо от того, прошла аутентификация успешно или нет фильтр сохраняет результат аутентификации в Security Context, который похож на Map. Ключом является JSESSIONID(кука, которая присваивается клиенту при POST запросе с отправкой формы логина) а значением этой Map является Authentication объект. Для чего сохранять ? Чтобы, когда клиент обратился к нашему сервису еще раз, то мы могли зайти в Security Context и получить по JSESSIONID из запроса информацию, что пользователь уже аутентифицирован и не нужно его повторно аутентифицировать. 
   
   Шаги с 3 по 8(когда выполняется реальная работа по аутентификации) происходят только при первом запросе. Решение о том, нужно обращаться к Authentication Manager или нет происходит с помощью проверки, есть ли в Security Context JSESSIONID данного пользователя или нет(он передается в куки). 
10. В зависимости от результатов аутентификации будет либо отправлен ответ с успешной аутентификацией, либо ошибка.

![[Pasted image 20241220115810.png]]
Мы можем передать уровень логирнования для секьюрити, чтобы в консоли проследить, как реально под капотом вызываются те компоненты, которые мы обсуждали ранее.
![[Pasted image 20241220120034.png]]

### Authorization Filter
![[Pasted image 20241220120701.png]]Данный фильтр ответственен за то, чтобы определить пытается ли пользователь получить доступ к protected ресурсу без переди credentials или без authenticated session.

В нем есть метод:
![[Pasted image 20241220121035.png]]

### DefaultLoginPageGeneratingFilter
Эту ошибку отлавливает DefaultLoginPageGeneratingFilter, который перенаправляет пользователя на login page и генерирует саму login page.

### Какие фильтры обрабатывают POST запрос с текстом логин формы
![[Pasted image 20241220121921.png]]
Рассмотрим его реализацию:
![[Pasted image 20241220122001.png]]

![[Pasted image 20241220133307.png]]
Если все-таки аутентификация нужна, то вызывается метод attempAuthentication:
![[Pasted image 20241220133513.png]]
В конце методы мы видим создание какого-то UsernamePasswordAuthenticationToken. Но мы же говорили, что должен создаваться Authentication. Ответ: Authentication - это интерфейс, а, следовательно, его объекты мы не можем создавать. Поэтому нужен класс, который реализует этот интерфейс - и этим классом и является UsernamePasswordAuthenticationToken.
Внутри метода unauthenticated вызывается конструктор:
А в конструкторе заполняются поля, а также boolean переменная, о которой мы говорили isAuthenticated устанавливается в false.
![[Pasted image 20241220134454.png]]
![[Pasted image 20241220134515.png]]
И потом мы видим, что дальше созданный Authentication объект отправляется в authenticationManager:
![[Pasted image 20241220134610.png]]

Если зайдем внутрь authenticate метода, то увидим, что он вызывается на объекте класса ProviderManager, который реализует интерфейс AuthenticationManager
![[Pasted image 20241220134719.png]]
Внутри authenticate метода:
![[Pasted image 20241220134810.png]]
Самое важное здесь это for цикл по всем доступным AuthenticationProvider-ам.
![[Pasted image 20241220134918.png]]
И мы видми, что если result != null, то, значит, один из AuthenticationProvider-ов смог провести аутентификацию и дальше нет смысла утруждать другие, поэтому там break.

В нашем случае, когда мы используем дефолтный Spring Security по умолчанию используется DaoAuthenticationProvider:
![[Pasted image 20241220135142.png]]
У него есть метод authenticate:
![[Pasted image 20241220135330.png]]
Зайдем в метод receiveUser:
![[Pasted image 20241220135709.png]]
Внутри loadUserByUsername. Причем стоит заметить, что этот метод также находится в классе, который предоставлен Spring по умолчанию InMemoryUserDetailsManager:
![[Pasted image 20241220135802.png]]
![[Pasted image 20241220135905.png]]

После того, как мы получили User-а, нам нужно сравнить пароли. Это происходит внутри additionalAuthenticationChecks:
![[Pasted image 20241220140052.png]]

А вот и сравнение:
![[Pasted image 20241220140207.png]]

### Справка по стандартному поведению аутентификации Spring Security
![[Pasted image 20241220140850.png]]

Тоже самое, но меньше деталей
![[Pasted image 20241220140947.png]]

### Как работает механизм, который после успешной аутентифкации не заставляет по новой вводить свои данные для входа 
В cookies сохраняется JSESSIONID. И по нему и происходит проверка, есть ли в SecurityContext Authentication.
![[Pasted image 20241220141221.png]]

### SpringBoot класс, который автоконфигурацией настраивает поведение по умолчанию, когда любой запрос требует аутентификации:
![[Pasted image 20241220170838.png]]
http.authorizeHttpRequests - этой строчкой мы как раз задали, что для доступа к любой страничке нужна аутентификация.
А дальше мы включаем различные стили аутентификации:
- http.formLogin() - включили аутентификация через логин форму, когда мы вводим данные в HTML форме и отправляет POST запрос на аутентификацию.
- http.httpBasic - включили basic аутентификацию. Это когда данные передается в base64 и не через HTML форму, а в headere.

### Напишем свой Bean SecurityFilterChain, который полностью заменяет тот, что предоставляет нам Spring
Есть permitAll - которая разрешает доступ для всех и анонимных юзеров и аутентифицированных.
Есть denyAll - запрещает доступ и анонимных и аутентифицированных.
![[Pasted image 20241220172748.png]]
Создадим Configuration класс в котором создадим SecurityFilterChain. В requestMatchers указываем пути, которые будут требовать аутентификацию, и которые будут доступны всем.
![[Pasted image 20241220173026.png]]

Также стоит добавить в permitAll путь до /errors, т.к. Spring по дефолту редиректит на эту страницу в том случае, если прозошел runtime error, который не поймали. Но можем добавить ее и в authenticated, если хотим, чтобы Runtime ошибка выводилась только для аутентифицированных пользователей.
![[Pasted image 20241220173431.png]]

### Отключение formLogin и httpBasic authentication
Форма логина нужна не всем приложениям. Например, если это мобильное приложение, то ему форма логина не нужна. Поэтому мы можем отключить ее:
`http.formLogin(flc -> flc.disable())`
Когда у нас включена форма логина, то за создание Authentication начинает отвечать UsernamePasswordAuthenticationFilter

Когда у нас включена basic authentication, то созданием Authenticaion занимается:
BasicAuthenticationFilter
basicAuthentication:
![[Pasted image 20241223112348.png]]

Когда мы используем basic authenticaton, то credentials передаются внутри хедера "Authorization". Значением этого хедера является Basic + данные в base64 кодировке:
![[Pasted image 20241223112541.png]]
В Base64 хранится так: "username:password". 
Сам метод, который занимается созданием Authentication(UsernamePassowrdAuthenticationToken - реализация интерфейса Authentication.)
![[Pasted image 20241223113037.png]]

Отключить basic authentication:
`http.httpBasic(hbc -> hbc.disable());`

Если мы отключим и basic и form authentication, то будем получать 403 статус:
![[Pasted image 20241223113327.png]]

В будущем мы научимся писать свои виды аутентификации!

### Чтобы в Postman делать проверки basic authentication:
![[Pasted image 20241223114824.png]]
В хедере будет Authorization:
![[Pasted image 20241223114848.png]]

### До этого мы задали username и password для usera нашего приложения внутри application.yml файла. Но мы хотим, чтобы нам приложением могли пользоваться сразу много людей, поэтому нам такой вариант не подходит
Для решения этой проблемы мы должны будем сохранять пользователей в БД или каком-либо другом хранилище.

Для начала создадим бин, который будет реализовывать интерфейс [[UserDetailsService]] - это тот интерфейс, который умеет получать UserDetails из БД вызовом метода loadUserByUsername.

Создадим пока что пользователей в памяти:
![[Pasted image 20241223121308.png]]
Когда мы создаем юзера таким образом, что выше, то по дефолту не используется никаких энкодеров. Пароли хранятся в том виде, в котором они есть.
![[Pasted image 20241223121506.png]]

Но если мы все оставим так, то после ввода пароля мы получим 500 ошибку. Если не настроен кодировщик паролей, то Spring выбрасывает исключение в том случае, если пароль не помечен префиксом - {noop}. Т.е. либо мы настраиваем энкодер паролей, либо используем для паролей: "{noop}password" при сохранении. 

### [[PasswordEncoder]]
После создание PasswordEncoder:
![[Pasted image 20241223122939.png]]
Закодированный пароль будет в hash формате из которого невозможно получить исходное значение.

noop - это префикс энкодера. В случае noop никакой encoder не работает. Но мы можем использовтаь и другие префиксы для энкодеров и тогда при валидации и извлечении данных из БД будет использован тот энкодер, префикс которого использовался.  

И теперь при сохранении пользователя мы сохраняем уже закодированный пароль.(Для кодировки мы использовали сайтик, но в будущем можно будет использовать энкодер, чтобы закодировать пароль. Но т.к. мы пока сохраняем пароль в source, а не получаем от пользователя в runtime, то мы кодируем, т.к. не хотим, чтобы в source хранился пароль, который будет всем виден)
![[Pasted image 20241223134241.png]]

### Как запретить пользователю использовать простые пароли?
Для этого используется CompromisedPasswordChecher.

Это интерфейс, который используется для проверки пароля.
![[Pasted image 20241223135207.png]]
Вот класс, который его реализует. Он идет на сайт, на котором собираются пароли, которые слиты в сеть благодаря утечкам данных и проверяет нет ли пароля, введенного пользователем в этих слитых паролях. Но нам никто не мешает написать свой класс, который будет реализовывать интерфейс CompomisedPasswordChecker.
![[Pasted image 20241223135320.png]]


### UserDetailsService vs UserDetailsManager
![[Pasted image 20241223140115.png]]

Логика такая - есть UserDetailsService - это базовый интерфейс, который формирует контракт на выполнение метода, возвращающего UserDetails. UserDetails - это дословно детали о пользователе. Т.е. этот интерфейс описывает методы, которые нужны для того, чтобы описать конечного пользователя системы. И т.к. это интерфейс, то Spring также предлагает его базовую реализацию - класс User. 

### UserDetails vs Authentication
 Это два интерфейс, которые нужны для представления информации о конечном пользователе. Но, где какой используется?
 Principal - интерфейс из JDK. В нем абстрактный метод getName().
 ![[Pasted image 20241223142348.png]]
 UserDetails используется только в моменте аутентификации пользователя. UserDetails предоствляет информацию и пользователе, который сохранен в БД. И дальше, например, проверки совпадения пароля происходит между тем паролем, что находится внутри UserDetails и тем паролем, что передан в Authentication тем пользователем, что пытается залогиниться. И в том случае, если аутентификация прошла успешно, то для Authentication объекта устанавливается флаг в isAuthencitated = true и дальше Authentication объект возвращается обратно в фильтры, где уже на основе этого флага определяется, успешна ли аутентификация. 
![[Pasted image 20241223142551.png]]

В Authentication интерфейсе есть интересный метод - eraseCredentials. В нем стирается пароль, чтобы он не хранился внутри Authentication объекта(а точнее реализации этого интерфейса(наиболее популярной) - UsernamePasswordAuthenticationToken). 

Зачем и когда стирать пароль? пароль стирается после успешной проверки аутентификации пользователя. Нет смысла после того, как мы поняли, что пользователь аутентифицирован тоскать его пароль по системе. Поэтому этот метод вызывается спрингом по умолчанию после того, как аутентификация была выполнена. 
![[Pasted image 20241223143307.png]]

Вот место, в котором происходит использование Authentication объекта и получение UserDetails объекта - это все внутри AuthenticationProvidera.
![[Pasted image 20241223143649.png]]
Логика такая - в методе authenticate, который должен провести аутентификацию пользователя вызывается метод retrieveUser, в котором извлекаются UserDetails из БД. Если такого пользователя там нет, то, значит, сразу завершаем аутентификацию, а если есть, то продолжаем. Если продолжаем, то, значит, для переданного username такой пользователь есть, а, значит, мы должны сравнить пароли. И в методе additionalAuthenticationChecks и выполняется сравнение паролей:
![[Pasted image 20241223144120.png]]

Вот сравнение:
![[Pasted image 20241223144347.png]]
Если все проверки прошли, то внутри метода authenticate вызывается метод createSuccessAuthenticaton:
![[Pasted image 20241223144536.png]]
В нем создается объект Authentication из данных в UserDetails.
![[Pasted image 20241223144525.png]]
### Хотим начать использовать БД для хранения пользователей. 
Будем использовать mysql. И также мы будем использовать дефолтную реализацию JdbcUserDetailsManager для работы с юзерами. Внутри users.ddl мы можем найти какие таблицы должны быть в БД, чтобы JdbcUserDetailsManager мог работать. 
![[Pasted image 20241223154041.png]]
Создаем JdbcUserDetailsManager:
![[Pasted image 20241223163217.png]]
Но это такой себе вариант, поскольку мы полностью ограничены этим JdbcUserDetailsManager и той схемой, которая должна быть у нашего приложения. Но мы не хотим иметь такие ограничения.

### Напишем свой UserDetailsService, чтобы избавиться от ограничений, наложенных использованием JdbcUserDetailsManager

Создадим свою собственную таблицу для пользователей. Назовем ее customer. 
![[Pasted image 20241223163741.png]]

Также создаем Entity и Repository для этой таблицы:
![[Pasted image 20241223165039.png]]
![[Pasted image 20241223165048.png]]

Создаем свой класс, который будет реализовывать интерфейс UserDetailsService. И в нем используем репозиторий, чтобы извлечь информацию о пользователе. А дальше Spring будет использовать наш бин типа UserDetailsService. Только главное, чтобы мы не создавали где-то еще бины такого же типа UserDetailsService. 
![[Pasted image 20241223170608.png]]

### Controller для регистрации
![[Pasted image 20241223171826.png]]
Но нужно еще добавить этот путь в SecurityFilterChain как permitAll, а также в SpringSecurity для HTTP методов, изменяющих данные(POST, PUT, DELETE) требуется CSRF защита. Если мы ничего не будем делать, то из-за требований CSRF защиты мы будем получать 403 статус для наших ответов. И у нас два варианта, либо реализовать CSRF защиту для нашего приложения, либо отказаться от CSRF. В будущем мы рассмотрим тему CSRF подробнее, а пока можем просто ее отключить.