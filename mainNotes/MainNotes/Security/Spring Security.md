### If else value in application.yml
Мы можем указывать с левой стороны название переменной, которую кто-нибудь при желании может передать как environment переменную при деплое и тогда будет использоваться она. Если же ничего не будет передано, то будет использовать значение, находящееся справа от ":"
![[Pasted image 20241220095440.png]]
### Security dependecy
Когда мы подключаем security dependecy, то благодаря автоконфигурации используется базовая реализация, в которой при любом запросе нас будет перекидывать на страничку логина:
![[Pasted image 20241220100222.png]]
А в консоли генерируется пароль для входа. username - user.
![[Pasted image 20241220100240.png]]
Также Spring автоматически запоминает нашу сессию и если перезагрузить страницу, то не нужно будет снова вводить логин и пароль.
Откуда берутся логин и пароль? Они заданы внутри SecurityProperties внутри вложенного класса:
![[Pasted image 20241220100811.png]]

### Здесь можно посмотреть основные properties
https://docs.spring.io/spring-boot/3.3/appendix/application-properties/index.html

### Зададим свои настройки, чтобы не копировать сгенерированный пароль, а использовать один и тот же
![[Pasted image 20241220101455.png]]

### Ответственность
![[Pasted image 20241220110626.png]]
### Servlets and Filters
Много security функциональности в приложении реализовано благодаря фильтрам и сервлетам.
![[Pasted image 20241220110903.png]]
### Spring Security Internal Flow
![[Pasted image 20241220111558.png]]
1. Client Application отправляет запрос. Данный запрос ловится Spring Security Filters и они выполняют работу с security. Например, есть фильтр, который проверяет аутентифицирован пользователь или нет. Если нет, то перенаправляет запрос на страницу логина. Фильтров в security много и их количество зависит от нашей конфигурации. 
2. Если пользователь передал свои credentials(данные для входа) в запросе, то один из фильтров должен преобразовать эти credentials, которые хранятся в HTTP Requeste(в body в основном) в объект Authentication, с которым уже будет удобно работать и с которым будут работать другие компоненты Spring Security. В Authentication объекте есть username, password, isAuthenticated(boolean поле). Когда такой объект Authentication впервые создается, то эта булева переменная = false. В общем, Authentication объект используется для сохранения в нем user credentials, а также в нем хранится информация о том, аутентифицирован данный пользователь или нет.
3. После того как был создан Authentication объект фильтры передают запрос в Authentication Manager. Authentication Manager ответственен за аутентификацию пользователя. В него отправили Authentication объект и он на основе той информации, что в нем хранится и с помощью дополнительных компонентов производит аутентификацию и потом вернет результат аутентификации обратно в фильтры, чтобы они решили, что делать дальше.
4. Authentication Manager взял на себя отвественность, что выполнит аутентификацию, но он не выполняет ее напрямую, а поручает ее Authentication Providers. Их может быть несколько для нескольких вариантов аутентификации. 
5. Authentication Provider использует UserDetailsService. UserDetailsService ответственен за то, чтобы получить User Details(вытащить из БД по username информацию о пользователе) по username, который был сохранен в Authentication объекте. После получения User Details UserDetailsService передает его обратно в Authentication Provider. 
6. Authentication Providers использует PasswordEncoder. Authentication Provider не может сравнить password, который передал user и который сохранен в Authentication и тот, что реально хранится в БД, поскольку в БД мы не храним raw пароли, а храним их в закодированной форме. Поэтому нам и нужен еще и Passowrd Encoder, который мы можем попросить сравнить пароль, который мы получили от пользователя при аутентификации(в Authentication объекте) и тот, что реально хранился в БД.
7. После того, как Password Encoder подтвердил, что пароли совпадают, то Authentication Provider сообщает Authentication Manager-у, что аутентификация прошла успешно. Как он сообщает? Он возвращает все тот же Authentication объект, но в нем уже boolean переменная isAuthenticated = true.
8. Этот же Authentication объект отправляется обратно в фильтры.
9. Не зависимо от того, прошла аутентификация успешно или нет фильтр сохраняет результат аутентификации в Security Context, который похож на Map. Ключом является JSESSIONID(кука, которая присваивается клиенту при POST запросе с отправкой формы логина) а значением этой Map является Authentication объект. Для чего сохранять ? Чтобы, когда клиент обратился к нашему сервису еще раз, то мы могли зайти в Security Context и получить по JSESSIONID из запроса информацию, что пользователь уже аутентифицирован и не нужно его повторно аутентифицировать. 
   
   Шаги с 3 по 8(когда выполняется реальная работа по аутентификации) происходят только при первом запросе. Решение о том, нужно обращаться к Authentication Manager или нет происходит с помощью проверки, есть ли в Security Context JSESSIONID данного пользователя или нет(он передается в куки). 
10. В зависимости от результатов аутентификации будет либо отправлен ответ с успешной аутентификацией, либо ошибка.

![[Pasted image 20241220115810.png]]
Мы можем передать уровень логирнования для секьюрити, чтобы в консоли проследить, как реально под капотом вызываются те компоненты, которые мы обсуждали ранее.
![[Pasted image 20241220120034.png]]

### Authorization Filter
![[Pasted image 20241220120701.png]]Данный фильтр ответственен за то, чтобы определить пытается ли пользователь получить доступ к protected ресурсу без переди credentials или без authenticated session.

В нем есть метод:
![[Pasted image 20241220121035.png]]

### DefaultLoginPageGeneratingFilter
Эту ошибку отлавливает DefaultLoginPageGeneratingFilter, который перенаправляет пользователя на login page и генерирует саму login page.

### Какие фильтры обрабатывают POST запрос с текстом логин формы
![[Pasted image 20241220121921.png]]
Рассмотрим его реализацию:
![[Pasted image 20241220122001.png]]

![[Pasted image 20241220133307.png]]
Если все-таки аутентификация нужна, то вызывается метод attempAuthentication:
![[Pasted image 20241220133513.png]]
В конце методы мы видим создание какого-то UsernamePasswordAuthenticationToken. Но мы же говорили, что должен создаваться Authentication. Ответ: Authentication - это интерфейс, а, следовательно, его объекты мы не можем создавать. Поэтому нужен класс, который реализует этот интерфейс - и этим классом и является UsernamePasswordAuthenticationToken.
Внутри метода unauthenticated вызывается конструктор:
А в конструкторе заполняются поля, а также boolean переменная, о которой мы говорили isAuthenticated устанавливается в false.
![[Pasted image 20241220134454.png]]
![[Pasted image 20241220134515.png]]
И потом мы видим, что дальше созданный Authentication объект отправляется в authenticationManager:
![[Pasted image 20241220134610.png]]

Если зайдем внутрь authenticate метода, то увидим, что он вызывается на объекте класса ProviderManager, который реализует интерфейс AuthenticationManager
![[Pasted image 20241220134719.png]]
Внутри authenticate метода:
![[Pasted image 20241220134810.png]]
Самое важное здесь это for цикл по всем доступным AuthenticationProvider-ам.
![[Pasted image 20241220134918.png]]
И мы видми, что если result != null, то, значит, один из AuthenticationProvider-ов смог провести аутентификацию и дальше нет смысла утруждать другие, поэтому там break.

В нашем случае, когда мы используем дефолтный Spring Security по умолчанию используется DaoAuthenticationProvider:
![[Pasted image 20241220135142.png]]
У него есть метод authenticate:
![[Pasted image 20241220135330.png]]
Зайдем в метод receiveUser:
![[Pasted image 20241220135709.png]]
Внутри loadUserByUsername. Причем стоит заметить, что этот метод также находится в классе, который предоставлен Spring по умолчанию InMemoryUserDetailsManager:
![[Pasted image 20241220135802.png]]
![[Pasted image 20241220135905.png]]

После того, как мы получили User-а, нам нужно сравнить пароли. Это происходит внутри additionalAuthenticationChecks:
![[Pasted image 20241220140052.png]]

А вот и сравнение:
![[Pasted image 20241220140207.png]]

### Справка по стандартному поведению аутентификации Spring Security
![[Pasted image 20241220140850.png]]

Тоже самое, но меньше деталей
![[Pasted image 20241220140947.png]]

### Как работает механизм, который после успешной аутентифкации не заставляет по новой вводить свои данные для входа 
В cookies сохраняется JSESSIONID. И по нему и происходит проверка, есть ли в SecurityContext Authentication.
![[Pasted image 20241220141221.png]]

### SpringBoot класс, который автоконфигурацией настраивает поведение по умолчанию, когда любой запрос требует аутентификации:
![[Pasted image 20241220170838.png]]
http.authorizeHttpRequests - этой строчкой мы как раз задали, что для доступа к любой страничке нужна аутентификация.
А дальше мы включаем различные стили аутентификации:
- http.formLogin() - включили аутентификация через логин форму, когда мы вводим данные в HTML форме и отправляет POST запрос на аутентификацию.
- http.httpBasic - включили basic аутентификацию. Это когда данные передается в base64 и не через HTML форму, а в headere.

### Напишем свой Bean SecurityFilterChain, который полностью заменяет тот, что предоставляет нам Spring
Есть permitAll - которая разрешает доступ для всех и анонимных юзеров и аутентифицированных.
Есть denyAll - запрещает доступ и анонимных и аутентифицированных.
![[Pasted image 20241220172748.png]]
Создадим Configuration класс в котором создадим SecurityFilterChain. В requestMatchers указываем пути, которые будут требовать аутентификацию, и которые будут доступны всем.
![[Pasted image 20241220173026.png]]

Также стоит добавить в permitAll путь до /errors, т.к. Spring по дефолту редиректит на эту страницу в том случае, если прозошел runtime error, который не поймали. Но можем добавить ее и в authenticated, если хотим, чтобы Runtime ошибка выводилась только для аутентифицированных пользователей.
![[Pasted image 20241220173431.png]]

