![[Pasted image 20241226103526.png]]

### Как хранятся роли в Spring Security?
Есть интерфейс GrantedAuthority, который описывает контракт, которому нужно следовать, чтобы описывать роли.
У этого интерфейса единственный метод: 
![[Pasted image 20241226104609.png]]
Spring предоставляет реализацию данного интерфейса:
![[Pasted image 20241226104708.png]]

### У нас есть 2 интерфейса для описания пользователя - Authentication и UserDetails.
Разберемся, как они хранят роли пользователя.
Для UserDetails есть класс User, который реализует интерфейс UserDetails. И в нем мы в поле со список GrantedAuthority складываем значения ролей
![[Pasted image 20241226105024.png]]

В конструкторе Usera список ролей преобразуется в unmodifiableSet. Т.е. роли должны быть уникальны, а также после того, как был создан список ролей, его никто не мог случайно модицифировать.
![[Pasted image 20241226105215.png]]

Что по поводу Authentication объекта? Где он хранит GrantedAuthority? У нас есть базовая реализация интерфейса Authentication - UsernamePasswordAuthenticationToken в котором есть поле для хранения GrantedAuthority
![[Pasted image 20241226105620.png]]

Кратко, вот так:)
![[Pasted image 20241226105741.png]]

### Обычно создают отдельную табличку, в которой хранятся роли пользователей. Т.к. у одного пользователя может быть несколько ролей - то это связь один ко многим.
![[Pasted image 20241227085610.png]]
Заполняем authority. (На самом деле есть разница между authority и role, но об этом позже)
![[Pasted image 20241227085754.png]]

Создаем сущность:
![[Pasted image 20241227091021.png]]

В Customer добавляем поле со список Authority
![[Pasted image 20241227091054.png]]

В UserDetailsService передаем список Authority в объект User:
![[Pasted image 20241227091141.png]]

А теперь в SecurityFilterChain указываем для каждого пути, какую роль должен иметь пользователь, чтобы не получить 403 ошибку.
![[Pasted image 20241227092617.png]]

![[Pasted image 20241227093137.png]]
![[Pasted image 20241227093643.png]]

### Authority vs Role
![[Pasted image 20241227093852.png]]
Authority - это по сути разрешение на какое-то действие.
ROLE - это группа Authority. Т.е. чтобы не перечислять последовательно для каждого действия authority, мы можем сказать, что пользователь с ролью USER может выполнять такие-то действия. И затем просто для всех действий, которые разрешены пользователью с ролью USER проверять, что у него такая роль.

Роли должны хранится в GrantedAuthority с именем ROLE_<НАЗВАНИЕ_РОЛИ>
### Перейдем на модель с ролями
Добавим в таблицу роли:
![[Pasted image 20241227095459.png]]

В SecurityFilterChain делаем следующее: причем важно, что в hasRole мы не указываем префикс "ROLE_". Он добавляется автоматически: 
![[Pasted image 20241227095913.png]]
![[Pasted image 20241227100054.png]]

### Listening Authorization Events
Можем реагировать на Event, когда у пользователя не было прав для выполнения действия и выполнить какое-то действие.
![[Pasted image 20241227100450.png]]
Можно также слушать AuthorizationGrantedEvent - когда наоборот пользователю можно совершить действие. Но т.к. таких эвентов будет возникать очень много, по умолчанию SpringSecurity не генерирует такие эвенты. 