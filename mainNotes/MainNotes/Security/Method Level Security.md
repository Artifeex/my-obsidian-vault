Мы можем использовать Security не поверх API, а поверх Java методов.
![[Pasted image 20241228084627.png]]
Когда полезно? 
1. В критических приложениях
2. В non-web приложениях. Если мы пишем, например, desktop приложение, то в нем можно будет защитить вызов методов только для авторизованных пользователей.

Как включить?
1. Нужно поставить аннотацию @EnableMethodSecurity. Но в ней есть еще 3 параметра
   - prePostEnabled - включает использование аннотаций @PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter
   - secureEnabled - включает использование аннотации @Secured - легаси аннотация
   - jsr250Enabled - вкл. использование @RoleAllower - также легаси аннотация.
![[Pasted image 20241228085233.png]]

### Invocation authorization
Для проверки того, может ли быть вызван метод используются roles/authorities.

@PreAuthorize - на скрине ниже возможные варианты использования. Но на самом деле мы не можем использовать эту аннотацию несколько раз над методов. Нужно писать все правила внутри одной аннотации. Сама аннотация используется для того, чтобы ПЕРЕД вызовом метода проверить, а можем ли мы вызвать этот метод.

Зачем оно надо? Это дополнительная защита нашего приложения. Если вдруг запрос все-таки как-то прошел через первый уровень защиты - API, то дополнительными проверками на других уровнях мы обезопасим наше приложение еще лучше. 
![[Pasted image 20241228085929.png]]

@PostAuthorize - сначала вызывается метод, но перед возвращением результата происходят проверки. Зачем такое использовать, когда есть @PreAuthorize? Сценарий использования один - когда недостаточно информации для проверки перед вызовом метода. Например, мы хотим в зависимости от результата метода решать - данный вызов метода разрешен или нет. Пример на скрине ниже - последний, когда используем зарезервированный returnObject внутри @PostAuthorize
![[Pasted image 20241228085943.png]]

Все эти аннотации работают за счет Spring AOP.


Но если у нас какое-то не супер критичное приложение, то нам достаточно обеспечить security на одном из уровней - либо на уровне API, либо на уровне методов. Например, на уровне api указываем, что запрос по данном пути должен быть аутентифицирован, а авторизацию уже проводим за счет использования @PreAuthorize
![[Pasted image 20241228091645.png]]
А потом на уровне репозитория проверяем роль юзера. Но, как я понимаю, лучше, наверное, использовать такое на уровне контроллеров?
![[Pasted image 20241228091912.png]]

Если проверка не пройдет, то получим 403 ошибку.
![[Pasted image 20241228092150.png]]

### Filtering Authorization
С помощью этих фильтров мы можем контролировать какой input должен к нам приходить(параметры) и какой output возвращается.

Когда мы используем @PreFilter параметр метода должен быть - коллекцией. А внутри мы пишем фильтрацию, т.е. это похоже на Stream, где мы перед тем, как вызвать метод фильтруем вход метода. filterObject на скрине - это объект класса Contact.
![[Pasted image 20241228092644.png]]

Аналогичная логика с PostFilter output. В фильтре указываем условие, которое должен пройти элемент возвращаемого из метода списка, чтобы остаться в этом списке. 
![[Pasted image 20241228093036.png]]