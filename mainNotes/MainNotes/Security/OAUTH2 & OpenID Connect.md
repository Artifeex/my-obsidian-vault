### Какие проблемы решает OAuth2
![[Pasted image 20241228093902.png]]
Когда используется OAuth2 то используется отдельный Authentication/Authorization Server, который ответственен за хранение информации о пользователе(а, следовательно, при регистрации пользователя информация сохраняется на этом сервере), а также за аутентификацию и авторизацию. Когда пользователь аутентифицируется в первый раз, то Authentication Server возвращает ему токен. И этот токен сохраняется где-то в браузере и потом уже другие приложение гугл не просят аутентификацию, а используют этот же токен, что был получен при первом входе в аккаунт. 

Также плюсом использования подхода OAuth2 является использование отдельного сервера аутентификации. Если не использовать такой подход, а каждый сервис - хранит у себя данные пользователя, то это, во-первых, дублирование кода аутентификации и авторизации в каждом из сервисов+ каждый сервис должен будет иметь свою базу с одним и тем же пользователем.  

Еще минусом является то, что для каждого сервиса нужно будет хранить свой токен, что тоже не удобно:
![[Pasted image 20241228094625.png]]

Решает проблему делегирования. Например, есть приложение PhotoEditor, который хочет получить доступ к фотографиям пользователя, чтобы пользователь мог их редактировать. 
Без OAuth2 - пришлось бы скачивать фотки и загружать на сайт или передавать данные от аккаунта гугл, но в таком случае, сайт имеет доступ к аккаунту гугл пользователя и выполнять любые действия.
С OAuth2 - PhotoEditor получает токен от сервера авторизации гугл. Токен имеет ограниченный набор действий - например, только читать данные. 
![[Pasted image 20241228095043.png]]

### Introduction To OAuth2
OAuth - основывается на Open Authorization. Это бесплатный open source протокол.
OAuth 2.0 - это 2-я версия данного протокола. 
OAuth - это не какая-то библиотека, это стандарт - т.е. набор правил, которым нужно следовать, если мы хотим использовать идеи OAuth.
![[Pasted image 20241228100320.png]]
Есть новая версия OAuth 2.1 . По сути она просто удаляет возможность использования grant types. 

### OAuth2. Терминология
![[Pasted image 20241228101549.png]]
Scopes в OAuth2 - аналог Roles/Authorities в Spring Security.

Flow работы с OAuth2:
![[Pasted image 20241228103029.png]]
![[Pasted image 20241228103038.png]]

### Grant Types
В OAuth есть множество способов предоставить доступ клиента к ресурсам resource ownera. Рассмотрим их.

#### Authorization Code
Такой тип используется только в том случае, если конечный пользователь участвует в процессе аутентификации. Т.е. это как раз пример того приложения с редактором картинок и google photo, где конечный пользователь вручную логинится и и предоставляет доступ клиенту к фото пользователя.
![[Pasted image 20241228103252.png]]
1. Приходит пользователь в приложение, хочет в нем получить отображение своих ресурсов. Приложение не знает, что это за пользователь, поэтому просит его пройти аутентификацию удобным способом. Клиент выбирает вариант с OAuth. 
2. Клиентское приложение перекидывает пользователя на страницу аутентификации.
3. Пользователь вводит свои данные на AuthServere.
4. AuthServer возвращает клиентскому приложению Authorization Code. Это еще не AccessToken.
5. Клиентское приложение передает свои credentials(cliend_id, client_secret - таким образом, Auth Server идентифицирует, что за клиентское приложение к нему обратилось. Т.е. заранее должна быть какая-то договоренность между AuthServer и Client приложением об этим данных), а также AuthorizationCode. 
   Зачем передавать client credentials? А это, чтобы Auth сервер мог отрисовать страничку, на которой будет пользователю показываться, какому приложению он предоставляет доступ!!!
6. Auth Server возвращает AccessToken
7. Клиентское приложение обращается к Resource Server для получения данных, передав AccessTOken
8. Resource Server проверяет переданный AccessToken, используя signature и если все хорошо, то передает ресурсы пользователя клиентскому приложению.

Здесь указано какие данные передаются на этапе 2 и 3, а также 5 от клиентского приложения к Auth серверу.
redirect_uri на шаге 2 и 3 нужен для того, чтобы клиентское приложение узнало о том, что аутентификация прошла успешно и при обращении по этому uri auth server как раз в body передаст code.

В шаге 5 передается client_id и client_secret - чтобы пруфануть Authentication Server-у, что code, который он вернул в прошлый раз приложению - его использует именно наше приложение, а не какой-то злоумышленник, который каким-то образом получил authorization code.
![[Pasted image 20241228104648.png]]

Если мы не хотим выполнять промежуточный шаг с получением auth code, то мы можем использовать "implict grant type". Тогда на auth сервер будут передаваться сразу и пользовательские данные и клиетнского приложения(client_id + client_secret). Но такой вариант лучше не использовать.
![[Pasted image 20241228112716.png]]

### Сайт, где можно поиграться с OAuth2 
https://www.oauth.com/playground/

Демо шагов при использовании Auth Code:
1. Создается URL по которому перейдет пользователь для предоставления credentials на auth сервере. В URL передаются параметры:
   - response_type = code - указываем, что будем использовать grant type = code
   - client_id - id клиенсктого приложения, которое хочет получить доступ
   - redirec_uri - куда будет прислан auth code
   - scope - указываем какие права хотим иметь
   - state - CSRF![[Pasted image 20241228113321.png]]
2. После этого мы переходим по этой ссылке и попадаем на страницу логина нашего auth сервера![[Pasted image 20241228113807.png]]
3. После передачи данных auth серверу он спрашивает у меня, действительно ли я хочу передать возможность выполнять действия такому-то приложению ![[Pasted image 20241228113934.png]]
4. Проверяем, что state(CSRF), который вернул нам auth сервер совпадает с тем, что мы ему передали на шаге 1. Этим мы убеждаемся, что code, который нам вернулся от auth сервера действительно от auth сервера, а не от хакера. ![[Pasted image 20241228114228.png]]
5. Запрос на получение accessTokena![[Pasted image 20241228114134.png]]
6. Получили accessToken(а еще и refresh token)![[Pasted image 20241228114541.png]]

### Implicit Grant Type Flow(Deprecated)
![[Pasted image 20241228114721.png]]
Почему deprecated? Потому что менее безопасно, т.к. для шага 3 используется GET запрос, а в GET запросе нет смысла передавать client_secret. Т.е. теперь достаточно передать client_id, что небезопасно. А также, когда на шаге 4 передается accessToken - это также происходит через GET запрос, а значит, внутри URL, что небезопасно. Почему через GET запрос? Потому что мы указываем redirec_uri - т.е. куда будет перенаправлен запрос, когда аутентификация пройдет успешно. Но в случае редиректа, нам доступен только GET запрос! Мы же по факту просто переходим по URL, который был передан. 
![[Pasted image 20241228115033.png]]

#### PKCE(Пикси)
Proof key for code exchange.
Проблема подхода Code Grant Type в том, что мы не можем хранить client_secret в public client приложении. Public clients are the applications that are built using UI frameworks, languages like Angular, React, Java Script etc. These applications code is open to public and any one can see their code, business logic. Since these apps, can't store the secret values, we need to go with the PKCE flow.

Т.к. мы не можем обеспечить их безопасность и когда мы будем отправлять его, то любой, кто посмотрит js код client приложения увидит secret key. Почему негде хранить? А потому что как ты клиенту без явного указания в коде установишь, например, в мобильном приложении этот secret key? Только если дополнительно делать запрос к бэку, но если у нас авторизация через oauth, то мы никак не можем заранее авторизоваться, чтобы потом получить secret key с бэка, чтобы смочь авторизоваться через oauth.
![[Pasted image 20241228132005.png]]
В тот момент, когда пользователь нажал на кнопку login и его начало редиректить на auth server для получения формы аутентификации будет сгенерирован code_verifier. А потом из этого code_verifiera генерируется 
`code_challenge = base64(sha256(code_verifier))` 
Во время редиректа на страничку логина в auth server передаются client_id, а также code_challenge. Этот code_challenge сохраняется для данного client_id. После этого пользователь ввел свои данные и происходит редирект, в котором отправляется auth code. Дальше client делает запрос для получения access tokena, передавая client_id, auth code, а также CODE_VERIFIER! Т.к. у auth servera хранится для данного client_id его code_challenge, то он теперь, используя формулу `code_challenge = base64(sha256(code_verifier))` может для клиента, который ему передал code_verifier проверить равенство с тем, что клиент отправлял на auth server при первом запросе! Зачем это нужно? Таким образом, Auth server может проверить, что отдает accessToken не какому-то случайному приложению, которое узнало client_id другого приложения и хочет через него получить его токенн, а тому же приложению, что в первый раз обращлось к нему, передав свой code_challenge! 

Таким образом, благодаря PKCE Auth server может быть точно уверен, что accessToken получает правильное приложение, хотя мы не передаем ему client_secret!
![[Pasted image 20241228133931.png]]
![[Pasted image 20241228134023.png]]
PKCE можно использовать как в public client, так и non-public client приложениях. PKCE самый безопасный вариант и лучше всего использовать его, т.к. тогда нет возможности потерять client_secret, т.к. он вообще не нужен! 

Шаг 1. Генерируется Code Verifier и Code Challenge
![[Pasted image 20241228134451.png]]
Шаг 2. Создается request для авторизации, в котором передается code challenge:
![[Pasted image 20241228134512.png]]
Шаг 3. После аутентификации пользователя редиректит, а наше приложение получает state для проверки на CSRF
![[Pasted image 20241228134653.png]]
Шаг 4. Выполняется POST запрос для получения accessTokena и передается code_verifier для того, чтобы сервер мог удостовериться, что передаст accessToken приложению, которое до этого с ним общалось, а не которое получило code и хочет им воспользоваться, чтобы получить accessToken.
![[Pasted image 20241228134937.png]]

#### Password Grant Type Flow(deprecated)
![[Pasted image 20241228135744.png]]
Недостаток очевидный - т.к. пользователь напрямую сначала вводит свои логин и пароль в client приложении, то это client приложение перде тем как обратиться к auth server может сохранить логин и пароль пользователя у себя. Такой вариант может подходить для сценариев, где auth server, client приложение и resource server принадлежат одной организации и у client приложения нет смысла что-то там сохранять дополнительно, ведь и так логин и пароль хранится внутри организации. 
![[Pasted image 20241228140243.png]]
Но все равно, лучше использовать PKCE или Code Grant Type Flow

#### Client Credentials Grant Type Flow
Наиболее использующийся тип в микросервисной архитектуре. Мы используем такой подход, когда у нас нет usera, а когда два backend приложения общаются друг с другом. 
![[Pasted image 20241228141708.png]]
![[Pasted image 20241228141955.png]]

#### Refresh Token
Когда мы используем какой-либо из grant type flow, то нам возвращается access Token и Refresh Token.
Когда у accessToken заканчивается время жизни, то, чтобы не заставлять пользователя повторно вводить данные для входа в дело вступает Refresh Token.
![[Pasted image 20241228142534.png]]
Как видим - user не участвует в refresh token grant type flow.
![[Pasted image 20241228142756.png]]

### Как Resource Server проверяет, что пришедший от client токен является валидным?
1 подход - обращение к auth server(не очень хороший подход, поскольку для каждого пришедшего запроса нужно делать запрос в auth сервер для проверки).
![[Pasted image 20241228143220.png]]
В таком подходе используются Opaque токены. Он передает его в Auth Server и проверяет валидность, а также узнает информацию о пришедшем пользователе. 

2 подход(наиболее популярный) - проверять accessToken локально на resource сервере.
![[Pasted image 20241228143805.png]]
Используются JWKS токены. Особенность в том, что нет signature. Вместо нее есть private key и public key. private key - известен только auth серверу и с помощью него он генерирует токен, когда клиент авторизуется. А resource сервер при своем старте обращается к auth серверу и получает от него public key. public key - используется для того, чтобы проверить валидность пришедшего от пользователя токена. 

Если используем такой подход, то нужно указывать малое время жизни accessTokena, потому что если accessToken был украден, то у нас нет никакой возможности сделать его не действительным, т.к. проверка accessTokena будет происходит на Resource Servere. Когда проверка происходила на Auth сервере, то мы там могли для конкретного пользователя сказать, что accessTOken не валидный и отвечать 403 статусом в случае попытки использовать не валидный токен. А тут же проверкой занимается resource server. 

### OpenID Connect
OpenID - это протокол поверх OAuth2.0. Цель его создания - унифицировать процесс аутентификации. Т.к. OAuth 2.0 работает с accessToken, а он обычно используется для того, чтобы предоставить права, т.е. это авторизация, то не было какого-то стандартного подхода описывать user details, чтобы понимать, какому пользователю принадлежит данный accessToken. Все делали так, как захотят. Кто-то id пользователя мог сохранить в accessToken, кто-то username. В общем, не было какого-то стандартного подхода, где сохранить информацию о userDetails. 

И для этого и был придуман OpenID. Когда client приложение просит пользователя авторизоваться, то auth server возвращает client приложению 
- Access Token - отвечает за авторизацию, т.к. внутри есть scopes, в которых перечисляются роли или authorities пользователя.
- ID Token - используется для аутентификации. Внутри него сохранятся информация о владельце accessTokena. Она стандартизирована. 
- Refresh Token(в случае, если используем подход с ним)
![[Pasted image 20241228144931.png]]

Благодаря этой связке появился IAM (identity - openid; access management - OAuth 2).
![[Pasted image 20241228150245.png]]

Шаг 1. Создается URL. Особенности - в scope указывается openid+profile+email - это часть от OpenID, а также photos - это уже часть для OAuth2 для собственно получения доступа к фото.
nonce - опциональный параметр, который генерируется в client приложении и потом такой же nonce будет возвращаться внутри OpenID tokena. Это нужно на всякий случай, чтобы проверить, что пришедший OpenID токен связан с тем пользователем, с которым сейчас работает приложение. 
![[Pasted image 20241228155514.png]]
Шаг 2. Защита от CSRF
![[Pasted image 20241228155933.png]]
Шаг 3. POST запрос для получения access tokena, openid tokena (refresh token - optional)
![[Pasted image 20241228160005.png]]
Шаг 4. Ответ на POST запрос
![[Pasted image 20241228160048.png]]

Вот, что находится внутри OpenID токена
![[Pasted image 20241228160146.png]]
aud  = nonce. C помощью него приложение может связать id token с сессией на клиентской стороне.

