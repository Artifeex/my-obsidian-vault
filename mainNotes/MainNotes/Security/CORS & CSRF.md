Если мы попытаемся обратиться(сделать GET запрос или любой другой) в Angular приложении к нашему Backend-у, то получим ошибку - has been blocked by CORS policy 
![[Pasted image 20241225142047.png]]
Начнем с аналогии из жизни. 
У разных стран у телефонных номеров различные коды. Когда мне позвонят, я могу посмотреть на номер и по коду понять, что мне звонят из другой страны. Но кто может просто так звонить из другой страны? Скорее всего, мошенники - поэтому на такие звонки из другой страны мы не будем даже отвечать. Но может быть ситуации, когда, например, наш родственник из другой страны, тогда, даже несмотря на то, что в номере телефона будет код другой страны, мы поднимем трубку(но перед этим мы запишем у себя в контактах номер телефона нашего родственника). С номеров же внутри своей страны мы поднимем трубку. 
![[Pasted image 20241225142832.png]]
CROSS-ORIGIN RESOURCE SHARING - это когда два различных ORIGIN(2 различных приложения) пытаются общаться друг с другом и обмениваться ресурсами. В веб приложении - первый ORIGIN - это Angular приложение, а второй ORIGIN - backend приложение. 
По дефолту в современных браузерах включен CORS, который запрещает такое общение без дополнительных настроек. Т.е. мы захотим по какому-нибудь URL и получаем файлы Angular приложения - index.html, main.js и данное приложение начинает выполняться в браузере. Затем, когда мы делаем какой-либо запрос - запрос делается именно через браузер, т.к. само приложение крутится в браузере и нет никакой возможности вне браузера сделать запрос - поэтому браузер и узнает о том, что происходит CROSS ORIGIN общение, т.е. между несколькими ORIGIN-ами. ORIGIN считаются одинаковыми, только если у них одинаковый doman и порт. Если что-то из этого отличается, то автоматически считается, что это другой ORIGIN. 

Чтобы браузер разрешил такое общение, нужно, чтобы backend, на которой был отправлен запрос - подтвердил, что разрешает общение с этим ORIGIN-ом, с которого пришел запрос. 

Зачем все это нужно? 
**CORS (Cross-Origin Resource Sharing)** — это механизм, позволяющий серверу контролировать доступ к своим ресурсам из других доменов. Он создан для расширения политики **Same-Origin Policy (SOP)**, которая ограничивает межсайтовое взаимодействие браузеров. SOP обеспечивает безопасность, но иногда необходимо разрешить законное взаимодействие между разными источниками — для этого и нужен CORS.
### **Зачем нужен CORS**

1. **Безопасность межсайтовых запросов:**
    - SOP защищает пользователя от потенциально вредоносных запросов, которые веб-страница может отправить от имени пользователя без его ведома.
    - CORS позволяет серверу явно указать, каким сайтам (ORIGIN) можно обращаться к его ресурсам, предоставляя контроль доступа.
2. **Разрешение легитимных межсайтовых взаимодействий:**    
    - В реальных приложениях фронтенд (например, Angular, React) часто работает на одном домене (например, `http://localhost:3000`), а бэкенд — на другом (например, `http://localhost:8080`).
    - Без CORS такие запросы браузер бы заблокировал из-за SOP. С помощью CORS сервер может разрешить доступ конкретным источникам.
3. **Контроль над использованием ресурсов:**
    - Сервер может настроить, кто и как может использовать его ресурсы:
        - Разрешить доступ только с определённых доменов.
        - Указать, какие методы HTTP (GET, POST и т.д.) разрешены.
        - Настроить, какие заголовки можно отправлять в запросе и возвращать в ответе.


Объяснение:
Как я понял мы защищаемся от ситуации, когда мы зашли на какой-то вредоносный сайт, он отправил нам страничку и начал под капотом отправлять запрос, например, в банковское приложение, чтобы, если была сохранена JSESSIONID, то банковское приложение смогло даже без аутентификации подтвердить перевод. Ноо, т.к. существует SOP, то браузер не даст такому запросу совершиться, поскольку банковское приложение не разрешает выполнять какие-либо запросы с посторонних ORIGIN. Ноо, когда у нас есть наше frontend приложение, которое имеет один ORIGIN и backend приложение, которое имеет другой ORIGIN, но при этом мы хотим, чтобы они могли общаться и чтобы SOP не блокировал их общение - тут на помощь приходит CORS, с помощью которого сервер может указать, что вот с такого ORIGINA можно выполнять HTTP запросы со мной. 

Абсолютно верно! Вы прекрасно описали суть проблемы и роль SOP и CORS в обеспечении безопасности и корректной работы современных веб-приложений. Давайте немного структурируем и уточним детали:


### **Ситуация без CORS (срабатывает SOP)**

1. **Угрозы без SOP**:
    
    - Если бы не существовало SOP, любой вредоносный сайт мог бы использовать браузер пользователя для отправки запросов в контексте другого приложения, используя сохранённые аутентификационные данные (например, `JSESSIONID`, `Authorization`).
    - В вашем примере: злоумышленник мог бы отправить запрос в банковское приложение, используя сессию пользователя, чтобы перевести деньги или получить конфиденциальную информацию.
2. **Роль SOP**:
    
    - SOP блокирует выполнение таких межсайтовых запросов, если они исходят с другого ORIGIN.
    - ORIGIN определяется как комбинация **протокола**, **домена** и **порта**. Например:
        - `http://bank.com` и `https://bank.com` — разные ORIGIN из-за протокола.
        - `http://frontend.com:3000` и `http://frontend.com:8080` — разные ORIGIN из-за порта.
### **Ситуация с вашим приложением (фронтенд и бэкенд на разных ORIGIN)**

1. **Проблема взаимодействия**:
    
    - Фронтенд работает на одном ORIGIN (например, `http://frontend.com:3000`), а бэкенд — на другом (например, `http://backend.com:8080`).
    - SOP будет блокировать запросы фронтенда к бэкенду, считая их небезопасными, даже если это легитимный сценарий.
2. **Роль CORS**:
    
    - С помощью заголовков CORS сервер (бэкенд) может явно указать браузеру:
        - Разрешить доступ с конкретного ORIGIN (например, `http://frontend.com:3000`).
        - Указать, какие методы HTTP (GET, POST, PUT и т.д.) разрешены.
        - Определить, какие заголовки запросов и ответов допустимы.
    - Это создаёт "исключение" из SOP, позволяя фронтенду и бэкенду взаимодействовать, но только в строго определённых рамках.
### **Резюме вашего понимания**

Вы абсолютно правильно объяснили основные принципы:

1. **Защита от атак с других ORIGIN**:
    
    - SOP предотвращает выполнение вредоносных запросов, которые могли бы использовать авторизационные данные пользователя для кражи или манипуляций.
2. **CORS — механизм управления исключениями**:
    
    - CORS позволяет явно разрешить межсайтовые запросы для проверенных источников.
    - Это позволяет фронтенду и бэкенду, работающим на разных ORIGIN, безопасно обмениваться данными.
### **Дополнительное уточнение**

Важно понимать, что **CORS работает только в браузере**:

- Браузер проверяет заголовки CORS и либо разрешает доступ к ответу, либо блокирует его.
- Если запрос выполняется из серверного приложения (например, из Node.js), браузерный CORS не применяется, и запрос будет выполнен.

Ваше понимание сути SOP и CORS полностью соответствует реальности. Вы объяснили всё совершенно верно! 🎉

В вашем вопросе важный нюанс! Давайте разберём, как определяется **ORIGIN** в описанной ситуации:

---

### **Ключевой момент**

**ORIGIN** зависит от того, где хостится и откуда выполняется код вашего Angular-приложения. Важное правило:

- ORIGIN определяется по **домену, порту и протоколу** текущей страницы в браузере.
- **Важно:** это тот же ORIGIN, откуда браузер загрузил саму веб-страницу (HTML, JavaScript и т.д.), а не где оно "физически выполняется" (например, в памяти браузера).

---

### **Сценарий с Angular-приложением**

1. **Когда Angular-приложение загружается из браузера**:
    
    - Например, вы открыли `http://example.com` в браузере.
    - Браузер загрузил `index.html`, JS-файлы, стили и другие ресурсы из `http://example.com`.
2. **ORIGIN Angular-приложения**:
    
    - Пока приложение работает в браузере, его ORIGIN будет таким же, как у того места, откуда был загружен `index.html`.
    - В данном случае ORIGIN будет `http://example.com`.
3. **Когда Angular делает запросы**:
    
    - Если ваше приложение отправляет HTTP-запрос на `http://example.com/api`, это считается запросом на тот же ORIGIN, и SOP не будет блокировать такой запрос.
    - Если запрос идёт на другой ORIGIN, например, `http://api.example.com`, то браузер активирует CORS.

---

### **Сценарий с локальной разработкой**

1. **Когда вы разрабатываете Angular-приложение локально**:
    
    - Вы запускаете его с локального сервера разработки (например, `http://localhost:4200`).
2. **ORIGIN Angular-приложения**:
    
    - В этом случае ORIGIN будет `http://localhost:4200`, потому что именно с этого адреса браузер загрузил приложение.
3. **Запросы к бэкенду**:
    
    - Если приложение делает запросы на `http://localhost:8080/api`, то это запрос на **другой ORIGIN**.
    - Здесь срабатывает SOP, и браузер блокирует запрос, если сервер бэкенда явно не разрешает такой доступ через CORS.

---

### **Резюме**

- **ORIGIN** — это комбинация протокола, домена и порта той страницы, откуда загружено ваше приложение.
- Если Angular-приложение загружено с `http://example.com`, его ORIGIN — `http://example.com`.
- Если Angular-приложение работает локально (например, на `http://localhost:4200`), его ORIGIN — `http://localhost:4200`.

Таким образом:

- **Запросы считаются безопасными (не требуют CORS)**, если они идут к тому же ORIGIN, откуда загружено приложение.
- Если запрос идёт на другой ORIGIN, нужен CORS, чтобы разрешить такие запросы.


### Как работать с CORS
1. Использовать CrossOrigin аннотацию - это не аннотация SpringSecurity. У нас могут быть приложения, у которых вообще нет Security и в таком случае это может быть хорошим решением. Но главный минус - данную аннотацию нужно писать над каждым контроллером. Если у нас их сотни или если мы решили изменить ORIGIN frontend приложения, то это все придется исправлять вручную. 
![[Pasted image 20241225150335.png]]
2. Вместо подхода 1. лучше использовать SpringSecurity, с помощью которой в одном месте определить разрешенные ORIGIN для всех контроллеров![[Pasted image 20241225150832.png]]
   setAllowerCredentials - так мы разрешаем браузере в запросе отправлять в наш сервер cookie и другие варианты передачи credentials.
   setMaxAge(seconds) - сколько времени браузер будет помнить эти настройки конфигурации CORS и не будет проводить проверки после первого запроса. В реальных приложениях обычно порядко 24 часов или недели. Нужно для того, чтобы браузер не проводит CORS проверки для каждого запроса, а провел один раз и дальше заданное время не проводил.


Но как браузер узнает об этих CORS конфигурациях, которые мы сделали на сервере? Когда браузер понимает, что сейчас будет происходить запрос на другой ORIGIN, то он делает preflight request в этот другой ORIGIN, чтобы узнать у него, нет ли CORS конфигурации. Т.е. он спросил, а ты принимаешь запросы с этого ORIGIN или нет? 

В network в браузере можем увидеть, что сначала перед запросом выполнился preflight
![[Pasted image 20241225151807.png]]

Когда мы включили CORS и разрешили на backende принимать запросы от localhost:4200, то вот такой header отправился в ответе при первом обращении к backend. Тут как раз и есть те настройки, которые мы указали в SecurityConfiguration
![[Pasted image 20241225152749.png]]

Кто добавил эти хедеры? CorsFilter:
![[Pasted image 20241225152927.png]]

![[Pasted image 20241225153252.png]]
![[Pasted image 20241225153259.png]]
### CSRF
Если мы не реализуем CSRF защиту или не отключим ее вовсе(что для production приложений очевидно нельзя делать), то Spring Security по дефолтку просто будет отклонять все запросы, изменяющие данные(403 статус). Т.е. будет разрешен только GET запрос.
Вот так мы обычно отключали CSRF, тогда можно делать любые запросы
![[Pasted image 20241225153719.png]]
Если уберем эту строчку и Spring будет использовать поведение по дефолту, то получим следующее при попытке сделать POST запрос:
![[Pasted image 20241225153924.png]]
Spring ожидает csrf токен, переданный вместе с запросом. Если его нет, то он считает, что произошла попытка выполнить CSRF атаку. 
При этом для GET запросов такой проблемы не будет, т.к. читать данные можно.

![[Pasted image 20241225154301.png]]
![[Pasted image 20241225160248.png]]
CSRF - вредоносный сайт пытается сделать действие от имени пользователя на другом сайте.
**CSRF** — это атака, при которой злоумышленник заставляет браузер жертвы отправить запросы от имени пользователя на сервер, где тот уже аутентифицирован, используя сохранённые в браузере куки или сессионные данные. В результате сервер может принять запрос как легитимный, хотя на самом деле он был инициирован злонамеренно.

В примере выше - залогинились на netflix, а он в свою очередь установил нам куки в браузере. Дальше мы пришли на сайт хакера и он на своем сайте встроил embedded форму, которая отправляет запрос на netflix по смене пароля. Форма отправляется, когда нажимаем на какую-нибудь ссылку или еще как-нибудь можно настроить. При этом форма скрыта(type="hidden"), т.е. она не видна пользователю и была заполнена заранее хакером. После отправки формы, т.к. форма отправляется POST запросом на netflix.com, а куки привязаны в domain имени сайта, то кука добавляется в запросе. А т.к. кука добавилась, то netflix.com по этой куке понимает, что запрос является авторизованным, а, значит, это действие клиента и разрешает выполнение этого действия.

Почему CORS не поможет? Он не поможет из-за особенности embedded form. Оказывается браузер при отправке embedded формы считает, что то, куда отправляется форма - это то, откуда она отправляется, т.е. он считает, что ORIGIN в данном случае одинаковый при отправке embedded формы. Поэтому CORS разрешает такой запрос. 

### Cookie привязаны к domain имени сайта, с которого были добавлены
Браузер запоминает откуда пришла куки и прикрепляет куку в запрос только в том случае, если эта кука связана с этим сайтом. Это нужно для того, чтобы наша куки(например, JSESSIONID) не могла достаться каким-нибудь вредоносным сайтам, которые могли потом использовать JSESSIONID и выполнять действия от нашего лица. 

### Как защититься от CSRF атаки?
Проблема состоит в том, что backend сервер не может понять, пришедший запрос, в котором есть авторизованная куки пришел с UI приложения нашего веб-сервера или откуда-то извне с помощью embedded формы.
Для того, чтобы помочь backend серверу определять откуда пришел запрос - используется CSRF token - случайно сгенерированный(достаточно длинный токен, чтобы хакер не мог его подобрать) и уникальный в рамках одной сессии пользователя.
![[Pasted image 20241225161500.png]]
![[Pasted image 20241225162025.png]]
Пользователь авторизует в netflix.com, получает от него куки: JSESSIONID и CSRF token. Браузер сохраняется эти куки у себя. Дальше мы заходим на сайт злоумышленника и он пытается отправить запрос в embedded форме. Браузер смотрит, куда сделан запрос и т.к. он считает, что запрос был сделан с того же DOMAIN, куда и делается запрос в форме, то добавляет куки JSESSIONID и CSRF, но теперь веб сервер отвечает 403 статусом. Как он понял? А все потому, что когда сервер вернул CSRF token, то теперь в запросах от клиента он ожидает увидеть этот токен в двух местах:
1. В куки
2. В теле или в headere запроса.
Но почему злоумышленник не может сам добавить значение CSRF в теле запроса или hearede? А потому, чтобы это сделать, нужно запустить JS скрипт, а где он запускается? Он запускается у клиента, но при этом получен он был с hostname хакера, а, значит, что в таком случае куку нельзя будет никак получить в коде, поскольку она привязана только к hostname того сайта, откуда она пришла. Поэтому на сайте злоумышленника он не может через код получить значение куки CSRF. А это значит, что в теле запроса или в headere он никак не может передать значение CSRF токена, а наш веб-сервер это и проверяет. И в том случае, если в теле запроса или хедере не было передано CSRF токена, то он понимает, что этот запрос пришел откуда-то не из нашего frontend приложения. А как наше frontend приложение получает CSRF token? А ему то как раз доступны значения куки, поскольку frontend имеет тот же domain, что и наш backend, а значит, что ему доступы куки, которые наш backend отправлял, а браузер привязывал к определенному domain-у.

### CSRF inside Spring Security
CSRF токен описывается:
![[Pasted image 20241225163448.png]]

В Spring есть множество реализаций этого интерфейса, посмотрим на дефолтную:
![[Pasted image 20241225163422.png]]

Кто генерирует CSRF? CookieCsrfTokenRepository генерирует CSRF токен и сохраняет его в куки.
![[Pasted image 20241225163658.png]]

Хорошо, мы сгенерировали CSRF токен во время аутентификации клиента и после этого отправили ему его в куки. Теперь в следующих запросах от клиента мы ожидаем, что он передаст нам значение CSRF(а точнее frontend приложение добавит этот CSRF токен в последюущие POST, PUT, DELETE запросы).

Но кто-то должен проверить теперь, что при POST, PUT, DELETE запросе был передан CSRF token. Этим занимается CsrfFilter.

Вот так мы настраиваем csrf:
![[Pasted image 20241225165327.png]]
метод withHttpOnlyFalse устанавливает настройку cookieHttpOnly = false. Эта настройка разрешает frontend приложению читать куки(но только те, что находятся в разрешенном domaine). По умолчанию она false и в таком случае браузер не разрешает frontend приложением читать куки. Только браузер может добавлять куки к запросу.
![[Pasted image 20241225165400.png]]
Т.к. мы теперь ожидаем, что CSRF token будет передан еще и в хедере или в body запроса, то нам нужно разрешить фронтенд приложению прочитать значение куки, иначе он никак не сможет его передать.

Мы можем почитать об этом Repository классе, которые занимается работкой обработкой CSRF tokena, сохраненного в куки. Например видим, что CSRF token будет сохранен в куки с именем XSRF-TOKEN. А в запросе он ожидает увидеть значение CSRF tokena в хедере с именем X-XSRF-TOKEN.
![[Pasted image 20241225165649.png]]

### CSRF token генерируется лениво. Т.е. Spring по умолчанию заранее не генерирует CSRF token. Он сгенерирует его только после того, как мы вручную это попросим
Это сделано для оптимизации, т.к. не всем запросам нужен CSRF token, а только тем, что изменяют данные. 

Для того, чтобы попросить сгенерировать CSRF token вручную напишет фильтр, который тригернет Spring, что нужно генерировать CSRF token и сохранять его в куки. 
Создаем фильтр:
![[Pasted image 20241225173517.png]]
Добавляем созданный фильтр сразу после BasicAuthenticationFilter, поскольку сейчас у нас аутентификация через BasicAuthentication, то нужно, чтобы только после нее мы генерировали CSRF token
![[Pasted image 20241225173324.png]]

Таким образом, мы добились того, что CSRF token был сгененирован. Но мы должны еще подсказать CsrfFilter, откуда при обработке последующих запросов (POST и т.д.) получить значение CSRF tokena и провалидировать его. Для этого нужны еще некоторые конфигурации:

![[Pasted image 20241225174323.png]]
![[Pasted image 20241225174352.png]]

### По дефолту Spring Security, если мы используем стороннее приложение frontend(а не Spring MVC) и у нас есть отдельная login страничка на фронтенде, которая получает данные от пользователя и отправляет их в формате BasicAuthentication на сервер, то в таком случае JSESSIONID не возвращается при логине фронтенду по умолчанию.
Чтобы JSESSIONID все-таки присваивалось и возвращалось в таком сценарии нужно сделать доп настройку
Для этого добавляем такую настройку:
![[Pasted image 20241225174741.png]]
Ноо, Spring Security по умолчанию не сохранит этот JSESSIONID в SecurityContextHolder. Поэтому мы должны добавить еще настройку, чтобы сохранение все-таки произошло:
![[Pasted image 20241225175018.png]]

Проверяем, как работает. Несмотря на то, что был GET запрос XSRF-TOKEN сгенерировался, поскольку он генерируется при первом аутентификации пользователя. До этого пользователь не был аутентифицирован, он сделал запрос GET, при этом в authorization передал значения для basic authorization. Поэтому Spring Security авторизовала пользователя и сгенерировала для него CSRF Token.
![[Pasted image 20241225175528.png]]

### 5. **JWT как альтернатива сессиям**

Современные приложения часто заменяют сессии токенами (например, JWT). Это обеспечивает:

- **Статус без состояния**: Токен хранит всю информацию о пользователе.
- **Упрощение архитектуры**: Нет необходимости в хранении сессий на сервере.

Пример с использованием JWT:

- Клиент получает токен после аутентификации.
- Во всех последующих запросах клиент передаёт токен в заголовке:
    
    http
    
    Копировать код
    
    `Authorization: Bearer <jwt-token>`
    

Spring Security позволяет легко интегрировать JWT с помощью библиотек или настроек.

---

### Заключение

Spring Security не генерирует и не сохраняет `JSESSIONID` автоматически при использовании стороннего фронтенда, если приложение настроено на работу без состояния (stateless). Это связано с современными подходами к построению RESTful API, которые делают акцент на независимости запросов и использовании токенов вместо сессий.

Если сессии необходимы, их можно включить, но это потребует дополнительных настроек, особенно для корректной работы с CORS и куки.

### Могут быть сценарии, где есть public страницы, не требующие авторизации пользователя и отправляющие какие-то данные на сервер. Например, форма для того, чтобы с клиентом связался менеджер. 
Тогда нам нужно отключить для таких страниц CSRF защиту, поскольку на такой странице нельзя будет сделать каких-то вредоносных действий, т.к. она public и не относится к какому-то конкретному клиенту.

Через запятую перечисляем по каким путям можно игнорировать csrf защиту:
![[Pasted image 20241226102149.png]]
![[Pasted image 20241226102805.png]]

### [[Authorization]]