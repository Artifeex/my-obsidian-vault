### Token Formats
![[Pasted image 20241227121811.png]]
- Opaque Tokens - токен представляет из себя рандомно сгенерированную строку, которая сама по себе не имеет никакого значения. Этот токен начинает иметь смысл только на сервере, где токен связан с сессией пользователя. 
  Обычно в Enteprise приложениях есть отдельный Auth Server, который отвечает за аутентификацию. Есть приложение А1, оно хочет обратиться в А2 по protected api. В таком случае А2 говорит, что нужно передать токен, чтобы узнать, есть ли у А1 доступ к этому protected api. Для этого A1 идет на Auth Server, передает в него Credentials и получаем токен. Дальше А1 с этим токеном обращается к А2. А2 же сначала должно проверить переданный токен. Но самостоятельно оно проверить не может, поэтому идет в Auth Server и спрашивает, валидный ли токен.![[Pasted image 20241227122430.png]]
  Пример Opaque Tokens:
  ![[Pasted image 20241227125554.png]]
- JWT - они уже внутри себя хранят какую-то полезную информацию о пользователе. Т.е. это не просто набор рандомных символов. Если раскодировать JWT, то можно получить полезную информацию. И если посмотреть на пример из Opaque TOkens, то в случае JWT, приложение А2 уже может самостоятельно проверить переданный токен, а не обращаться к Auth Server. В общем, основным плюс JWT токенов является то, что не нужно делать дополнительный вызов в Auth Server, как в случае Opaque Token.

Логика использования токенов: - авторизовались на сервере, сервер вернул токен. Следующие запросы уже не требует авторизаации, поскольку мы передаем токен, который проверяется сервером.
![[Pasted image 20241227123528.png]]

### Плюсы использования токенов
![[Pasted image 20241227123647.png]]
1. Безопасность. Пользователю нужно всего 1 раз передать свои данные на сервер, чтобы авторизоваться, а дальше он будет передавать токен, а не свои данные для последующих запросов. Даже если хакер завладает токеном, то, если у нас есть подозрения об этом, то мы можем сделать все токены не валидными и тогда хакер, даже если сделает запрос и передаст токен, то запрос не будет выполнен, т.к. токен не валидный. Пользователь же ничего об этом не узнает, он просто увидит, что нужно залогиниться снова, при этом credentials остаются прежними, их хакер никак узнать не может, т.к. Opaque token - он вообще не хранит в себе этой информации. А в JWT пароль не передается, а только какая-то частичная информация о пользователе, которая помогает бекенду определять, что за пользователь сейчас с нами работает.
2. Expiration(истечение срока действия). Когда я выдаю(to issue) токен, то я могу задать время его жизни. Это может спасти, если хакер завладел токеном, то он сможет им воспользоваться ограниченное количество времени и не сможет нанести много вреда, как мог бы, если бы токен действовал бесконечно.
3. Self-contained - только для JWT токенов. Внутри токена содержится часть информации о пользователе. И благодаря этому в распределенной системе при обращении мы можем получить информацию из токена, а не обращаться в Auth сервер для получения информации.
4. Reusability. Когда токен сгенерирован, то с одним токеном можно будет обращаться к разным приложениям без дополнительной аутентификации. Например, в гугл есть множество приложений. В первый раз мы логинимся в каком-нибудь из них, это приложение перенаправляет логин в Auth server, который генерирует токен. данный токен сохраняется в cookies и дальше, когда мы будем обращаться к какому-нибудь другому приложению гугл, то аутентификацию уже проводить не нужно будет, т.к. будет передан токен в приложение, а этого достаточно, чтобы приложение поняло, кто к нему обратился.![[Pasted image 20241227124737.png]]
   Такой подход, когда происходит одна аутентификация, а дальше переиспользуется токен другими приложениями называется SSO - single sign on.
5. Кросс-плафторма. Токены могут быть использованы всеми видами приложений - как браузерными, так и мобильными. Если же мы испольуем какой-нибудь form подход, то в таком случае, телефоны не смогут этим воспользоваться. 
6. Стейтлесс. В токене содержится вся необходимая информация, нам теперь не нужно хранить на сервере сессию клиента, в которой будет хранится username и еще какая-то информация. Это особенно полезно в распределенной среде, т.к. у нас может быть несколкьо серверов и load balancer, который будет перенаправлять запросы и в случае использования JWT мы сможем направить запрос в любой из серверов, а не только в тот, в котором аутентифицировался пользователь и где сохранена сессия! Это особенно важно для микросервисов.

### JWT Token Format
![[Pasted image 20241227125645.png]]
Состоит из 3 частей, разделенных точками.
Header.Payload.Signature
- Header - метаинформация о токене. 
- Payload - информация о пользователе. Нужно передавать как можно меньше данных, а также категорически запрещено передавать пароль, поскольку тут просто кодировка base64, которая спокойно кодирует и декодирует текст. Поэтому, если хакер получит токен и в нем будет пароль, то он узнает пароль, преобразовав base64 строка обратно в исходных JSON.
![[Pasted image 20241227125847.png]]
- Signature - опционально. В каких случаях опционально? Например, когда мы точно уверены, что JWT будет передаваться только внутри нашей защищенной сети и никуда вовне не передается. А это, значит, что никто не будет подделывать токен.
  ![[Pasted image 20241227130239.png]]
  А вот в случае, если мы генерирует токен для пользовательское приложения, которое потом будет с нами общаться - в таком случае нужно использовать signature.
  Она используется для того, чтобы проверить - токен подделан или нет. Т.е. хакер может попытаться подделать свою роль и обратиться к серверу с подделанным токеном, чтобы совершить действие, например, с ролью admin. Если бы не было signature, то наш сервер бы просто прочитал роль из токен и в случае правильной роли - разрешил действие для этого пользователя, хотя на самом деле роль была подделана. 
  
  Как создается signature? Используется хеширующая функция(а мы знаем, что такие функции работают в одну сторону. Т.е. подается значение на вход, получаем хэш из которого уже никак нельзя получить данные). Что подается на вход для генерации signature? SHA256(base64(header).base64(payload), ==secret==). secret - хранится на сервере и не должнен никому передаваться.

### Как сервер определяет, что произошла подделка токена?
![[Pasted image 20241227131547.png]]
Пользователь получил свой JWT token header.payload.signature. signature - это хэш от строки "base64(header).base64(payload), ==secret==". Предположим, пользователь изменил значение в payload -> получил другое значение в base64 payload. Потом делает запрос на сервер, сервер снова считает хэш по той же формуле от тех значений, что пришли от клиента + secret на сервер и сравнивает с signature, которая была передана при генерации токена.
Пользователь изменил payload -> получим другой хэш, который отличается от значения в signature, а это, значит, что никак токен подделать нельзя.

Единственный вариант - как подделать токен - это узнать secret, т.к. если мы знаем secret, то мы можем у себя локально изменить payload, после этого закодировать его в base64. А потом, используя хэш функцию и секрет, который узнали - получить новый хэш и вставить его в signature. И тогда уже, signature, которую мы посчитаем на сервере для входного JWN совпадет с signature, которую передал нам хакер. А т.к. совпала, то, считаем, что токен не подделан!

### Реализация в Spring Security
Зависимости для удобной работы с JWT:
```xml
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>0.12.5</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>0.12.5</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId>
			<version>0.12.5</version>
			<scope>runtime</scope>
		</dependency>
```

Должны указать в настройках STATELESS, тем самым убираем сохранение сессий и токенов на сервере.
А также, т.к. включен CORS, то оказывается, мы должны указать разрешенный для установки хедер(если он кастомный) на сервере. 
![[Pasted image 20241227142236.png]]
Константы:
![[Pasted image 20241227145956.png]]
Создадим фильтр, который будет заниматься генерацией JWT токенов:
![[Pasted image 20241227145940.png]]
![[Pasted image 20241227145947.png]]

Создаем фильтр, который будет заниматься валидацией токенов. Вся логика валидации внутри try { } catch, поскольку, если выбросится исключение во время валидации токена - значит, что-то не так с токеном! Например, verifyWith(secretKey).pargeSignedClaims(jwt) - тут мы проверим пришедшую подпись JWT с настоящей подписью. Если не совпадет - JWT подделан. 
![[Pasted image 20241227150032.png]]
И в этом же фильтре указываем путь, по которому этот фильтр не будет вызываться. /user - это путь, по которому пользователь логинится, поэтому нет смысла для пути логина проверять токен, т.к. его нет или он устарел, поэтому и пошел запрос на такой путь. 
![[Pasted image 20241227150111.png]]

Добавляем созданные фильтры.
- JWTTokenGenerator - мы его ставим после того, как аутентификация прошла, т.к. генерировать JWT токен есть смысл только в том случае, если аутентификация прошла успешно.
- JWTTokenValidator - наоборот ставим перед BasicAuthentication фильтром, поскольку мы теперь для создания Authentication объекта используем информацию из токена, а не сохраненную сессию пользователя.
![[Pasted image 20241227150551.png]]

Итого имеем следующую логику:
Пользователь первый раз зашел, у него нет токена. Он авторизуется, переходя по пути /user, используя BasicAuthentication(т.е. в хедере с именем Authorization передается Basic < BASE64URL(username:password)>). На основе этих данных фильтр BasicAuthenticationFilter создает объект Authentication и дальше уже вызывается наш JwtTokenGeneratorFilter. Он забирает Authentication объект из SecurityContext и генерирует на его основе JWT и потом этот JWT возвращает клиенту в виде header заголовка Authorization:  Bearer < JWT_TOKEN>.

В дальнейшем, когда пользователь заходит на какой-то protected путь, то срабатывает наш JwtTokenValidatorFilter. Он забирает значение токена и проверяет его, создавая объект Authentication. А дальше запрос уже не идет в BasicAuthenticationFilter, поскольку Spring Security видит, что Authentication объект со значением isAuthenticated=true уже создан и нет смысла такой объект посылать в другие Authentication фильтры. 

Логинимся в систему:
![[Pasted image 20241227152816.png]]

А теперь для всех последующих запросов на фронтедне мы добавляем в хедер Authorization значение JWT токена
![[Pasted image 20241227153001.png]]

На текущий момент мы не используем refresh token. В том случае, если accessToken was expired, то на этапе проверки валидации мы получим исключение. В catch блоке мы можем его как хотим обработать. 

### Но, что, если мы хотим, чтобы аутентификация была ни через basicAuthentication, ни через formLogin. Т.е. какой-то не стандартный подход. Например, хотим, чтобы пользовательские данные передавались в body, потом происходила аутентификация и пользователю возвращался JWT token
В таком случае, мы должны создать обработчик отдельного пути для такой авторизации, по которому в POST запросе будут передаваться credentials, а потом вручную нужно будет вызвать в контроллере аутентификацию.

Создаем бин AuthenticationManager, чтобы потом использовать его в контроллере и запустить аутентификацию.
![[Pasted image 20241227160801.png]]

Создаем в контроллере обработчик POST запроса, по которому пользователь сможешь аутентифицироваться. Внутри мы будем использовать как раз AuthenticationManager.
![[Pasted image 20241227160854.png]]
В запросе передается такое dto:
![[Pasted image 20241227161025.png]]
Возвращаем в body такой объект:
![[Pasted image 20241227160949.png]]


В примере выше мы возвращаем token как в body, так и в хедере, но обычно возвращают в одном месте.

В конфигурации должны сделать созданный для аутентификации путь public, а также убрать для него CSRF, поскольку это публичная страница и нет смысла в CSRF защите, а также потому что CSRF токен появится только после аутентификации. 
![[Pasted image 20241227160617.png]]
