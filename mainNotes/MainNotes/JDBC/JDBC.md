JDBC - Java Database Connectivity - набор классов и интерфейсов для работы с БД из нашего Java приложения. Нужен для того, чтобы мы могли работать с разными БД, используя один и тот же интерфейс. 
Есть интерфейс Driver, который нужно реализовать для работы с БД. Когда мы скачиваем PostrgesDriver, то он как раз реализует этот интерфейс и мы работаем Api, который предоставляет нам JDBC, а всю подкапотную работу делает скачанный драйвер.

```Java
Connection connection = DriverManager.getConnection(username, password, url);
```
Из соединения мы можем получать различную информацию, устанавливать уровни изоляции и т.д.
Есть интерфейс Statement и в нем есть метод execute. Statement получаем из connection. Методы, которые вызываются на Statement:
- execute - в основном для DDL(но можем использовать любые операции). Возвращает true только в том случае, если вызывался SELECT
- executeUpdate - возвращает количество обновленных строк. Используется для DML
- executeQuery - возвращает ResultSet.
  ![[Pasted image 20240927151819.png]]
Обычным Statement никто не пользуются. Все используют PreparedStatement, т.к. он защищаешь от SQL инъекций.
connection.prepareStatement(SQL)
И используем те же методы. Также можем устанавливать значения в знаки вопросика по порядку.

FetchSize - чтобы при SELECT \* FROM приложение не упало, т.к. данных в БД может быть очень много и если все их загрузить сразу в оперативную память, то ее может не хватить. Поэтому через FetchSize мы можем ограничить, сколько данных придет с БД. И когда мы с помощью ResultSet будет двигаться по строкам, то когда посмотрим все данные, которые вернулись, то выполнится еще один запрос и вернет FetchSize строк.

По умолчанию используется автокоммит мод. т.е. каждый наш запрос просто создает транзакцию, выполняется и закрывает транзакцию.
Чтобы организовать транзакцию, нужно выключить автокоммит мод для connection через сеттер. После этого мы сами управляем тем, когда транзакция будет завершена. connection.commit() - для завершения транзакции.

Batch запросы используются для того, чтобы одной пачкой отправить сразу множество запросов, а не гонять по сети данные для каждого запроса. Т.е. мы вместо 4 обращений к БД для 4 запросов, может сделать 1 обращение, внутри которого будут находиться запросы, которые БД последовательно прочитает.

Чтобы сделать batch запрос, мы должны воспользоваться Statement, а не PreparedStatement(он не позволяет делать batch запросы).

Для этого мы:

1) устанавливаем setAutoCommit(false)

2) Создаем наш statement

3) Вызываем addBatch, в который передаем строку с нашим SQL запросом

4) Вызываем executeBatch, который и отправит наши запросы ВМЕСТЕ, а не по отдельности. Он вернет массив, в котором будет хранится сколько данных было обновлено для каждого запроса. При этом, логично, что нет смысла делать SELECT запросы в BATCH, так как мы не можем получить ResultSet, из которого потом будем получать значения. Поэтому Batch запросы обычно используются для DDL и DELETE/UPDATE/INSERT операций, а не SELECT. И т.к. он выполняется в рамках одной транзакции, то выполнятся либо все запросы, либо не выполнится ни одного.

Прикольно, что можем писать массив Байт

Dao - паттерн. Использует внутри JDBC, маппит данные из БД на объекты в Java. Являетяс синглтоном. Для каждой таблицы создается свой Dao.

В JDBC, чтобы вернулся id созданной записи(когда используются автогенерированные id, то просто доп параметр нужно передать в connection.prepareStatement())

