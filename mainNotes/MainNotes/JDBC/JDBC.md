JDBC - Java Database Connectivity - набор классов и интерфейсов для работы с БД из нашего Java приложения. Нужен для того, чтобы мы могли работать с разными БД, используя один и тот же интерфейс. 
Есть интерфейс Driver, который нужно реализовать для работы с БД. Когда мы скачиваем PostrgesDriver, то он как раз реализует этот интерфейс и мы работаем Api, который предоставляет нам JDBC, а всю подкапотную работу делает скачанный драйвер.



```Java
Connection connection = DriverManager.getConnection(username, password, url);
```
Из соединения мы можем получать различную информацию, устанавливать уровни изоляции и т.д.
Есть интерфейс Statement и в нем есть метод execute. Statement получаем из connection. Методы, которые вызываются на Statement:
- execute - в основном для DDL(но можем использовать любые операции). Возвращает true только в том случае, если вызывался SELECT.
- executeUpdate - возвращает количество обновленных строк. Используется для DML
- executeQuery - возвращает ResultSet. Используется для SELECT.
  ![[Pasted image 20240927151819.png]]
Обычным Statement никто не пользуются. Все используют PreparedStatement, т.к. он защищаешь от SQL инъекций.
`PreparedStatement pr = connection.prepareStatement(SQL)`
И используем те же методы. Также можем устанавливать значения в знаки вопросика по порядку.


### FetchSize
FetchSize - чтобы при SELECT \* FROM приложение не упало, т.к. данных в БД может быть очень много и если все их загрузить сразу в оперативную память, то ее может не хватить. Поэтому через FetchSize мы можем ограничить, сколько данных придет с БД. И когда мы с помощью ResultSet будет двигаться по строкам, то когда посмотрим все данные, которые вернулись, то выполнится еще один запрос и вернет FetchSize строк.

### Autocommit
По умолчанию используется автокоммит мод. т.е. каждый наш запрос просто создает транзакцию, выполняется и закрывает транзакцию.
Чтобы организовать транзакцию, нужно выключить автокоммит мод для connection через сеттер. После этого мы сами управляем тем, когда транзакция будет завершена. connection.commit() - для завершения транзакции.

### Batch
Batch запросы используются для того, чтобы одной пачкой отправить сразу множество запросов, а не гонять по сети данные для каждого запроса. Т.е. мы вместо 4 обращений к БД для 4 запросов, может сделать 1 обращение, внутри которого будут находиться запросы, которые БД последовательно прочитает.

Чтобы сделать batch запрос, мы должны воспользоваться Statement, а не PreparedStatement(он не позволяет делать batch запросы).

Для этого мы:

1) устанавливаем setAutoCommit(false)

2) Создаем наш statement

3) Вызываем addBatch, в который передаем строку с нашим SQL запросом

4) Вызываем executeBatch, который и отправит наши запросы ВМЕСТЕ, а не по отдельности. Он вернет массив, в котором будет хранится сколько данных было обновлено для каждого запроса. При этом, логично, что нет смысла делать SELECT запросы в BATCH, так как мы не можем получить ResultSet, из которого потом будем получать значения. Поэтому Batch запросы обычно используются для DDL и DELETE/UPDATE/INSERT операций, а не SELECT. И т.к. он выполняется в рамках одной транзакции, то выполнятся либо все запросы, либо не выполнится ни одного.

Прикольно, что можем писать массив Байт

Dao - паттерн. Использует внутри JDBC, маппит данные из БД на объекты в Java. Являетяс синглтоном. Для каждой таблицы создается свой Dao.

В JDBC, чтобы вернулся id созданной записи(когда используются автогенерированные id, то просто доп параметр нужно передать в connection.prepareStatement())
#### Преимущества PreparedStatement над Statement?
- PreparedStatement позволяет предотвратить атаки типа SQL injection, т.к. он автоматически экранирует специальные символы.
- PreparedStatement позволяет использовать динамические запросы с внедрением параметров.
- PreparedStatement быстрее Statement. Это особенно заметно при частом использовании PreparedStatement или при использовании для вызова группы запросов.
- PreparedStatement позволяет писать объектно ориентированный код с использованием сеттеров\геттеров. В то время при использовании Statement необходимо использовать конкатенацию строк для создания запроса. Для больших запросов конкатенация выглядит, как минимум, большой, а так же несет в себе большой риск ошибки в запросе.
### JDBC ResultSet

JDBC ResultSet — интерфейс, объект которого создается в результате запроса к базе данных. Его можно представить в виде таблицы данных, которая была сформирована в ответ на запрос.

Объект ResultSet поддерживает курсор, который указывает на текущую строку данных. При инициализации курсор устанавливается до первой строки. Для движение по строкам используется метод next(). При наличии строк после текущей позиции, метод next() возвращает true, что можно использовать для итерации по таблице полученных результатов.

По умолчанию объект ResultSet не модифицируемый и поддерживает курсор, который способен только к движение вперед. Для обхода такого ограничения можно использовать следующую конструкцию, которая даст возможность двунаправленного движения по таблице, а так же возможности обновления:

|   |
|---|
|Statement stmt =  <br>con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,  <br>                              ResultSet.CONCUR_UPDATABLE);|

Объект ResultSet автоматически закрывается при закрытии объекта, который его сгенерировал. Так же закрытие произойдет при повторном выполнении запроса или возврату результата из другого набора результатов.
### Типы JDBC ResultSet

При создании Statement можно задать различные типы получаемого ResultSet.
Три типа объектов ResultSet:
1. ResultSet.TYPE_FORWARD_ONLY: тип по умолчанию. Поддерживает движение курсора только в прямом направлении.
2. ResultSet.TYPE_SCROLL_INSENSITIVE: Двунаправленный курсор. Объект не чувствителен к изменениям, которые произошли с таблицей после получения результата.
3. ResultSet.TYPE_SCROLL_SENSITIVE: Двунаправленный курсор. Объект чувствителен к изменениям, которые произошли с базой данных после создания объекта ResultSet.
Два типа потокобезопасных объектов ResultSet:

1. ResultSet.CONCUR_READ_ONLY: Поддерживает только чтение (read only). Применяется по умолчанию.
2. ResultSet.CONCUR_UPDATABLE: Поддерживает метод ResultSet update для обновления строк в таблице данных.

**

## JDBC Savepoint
JDBC Savepoint позволяет создавать «чекпоинты» в транзакции с помощью которых мы можем откатить не всю транзакцию целиком, а только часть до точки сохранения.
