`docker version` - выводит информацию о клиенте и сервере докер.
`docker ps -a` - получить список запущенных и остановленных контейнеров. Если убрать -а, то увидим только запущенные контейнеры.
`docker images` - показываем список локальных образов
`docker run <image_name>` - создает и запускает контейнер, используя образ с именем image_name.
![[Pasted image 20241010135652.png]]
Докер сначала попытается найти образ с таким именем локально. Если локально его не будет, то он уже будет обращаться в репозиторий docker hub. Если там найдется такой образ, то докер его скачает и потом создает контейнер на основе скачанного образа. Если зайти на docker hub, то там можно увидеть этот образ hello-world.

`docker pull hello-world` - скачать образ с docker hub, но не будет создан контейнер, как в случае с вызовов run.

В команде docker run мы можем указать тег для образа. Например:
`docker run hello-world:latest` указываем тег latest.
Текст, который мы получим при запуске контейнера hello-world - был сгенерирован процессом, который работал в данной контейнере. При этом мы говорили, что докер автоматически останавливает контейнер, если в нем нет активных процессов. Это и произошло с контейнером hello-world.

Вывод команды docker ps -a. 
![[Pasted image 20241010140720.png]]
- Container id - генерируется автоматически. Уникальный id контейнера
- hello-world - название образа из которого был развернут контейнер
- /hello - команда, которая была выполнена внутри контейнера. Именно она запустила определенный процесс, который сгенерировал текст
- 3 minutes ago - когда был создан
- exited - статус для контейнера(был остановлен).
- padantic_cohen - название контейнера, также автоматически, но можно и задавать свое имя.

`docker rm <container_id/container_name>` - удалит контейнер с таким id или именем. После этого вызов команды `docker ps -a` снова будет пустым, т.к. мы удалили оттуда контейнер с названием pedantic_cohen.
Т.е. получается, что docker daemon создал контейнер и остановил его, когда процесс завершил свою работу. НООО, при этом сам контейнер не был удален, а был только остановлен. И таким образом, если мы еще раз захотим запустить контейнер, то нам уже не нужно будет скачивать образ из docker hub и создавать на его основе контейнер.

### busybox
Теперь давайте запустим контейнер busybox, который на самом деле запускает оболочку командной строки, используя команду sh. 
`docker run busybox` - запустив команду мы увидим, что контейнер запустился и потом закончил свое выполнение. Это произошло потому что никто не подключился к процессу, который был запущен в контейнере.

Чтобы этот контейнер оставался запущенным необходимо подключаться к процессу внутри контейнера busybox.
`docker run -i -t busybox` - теперь запустим с помощью такой команды.
- -i - обозначает интерактивный
- -t - терминал.
- -it - объединяет i и t. Означает, что подключаем мой терминал, в котором я пишу эту команду к процессу, который будет запущен в контейнере.

После этого мы попали внутрь контейнера. Т.е. подключились к процессу, который запустил терминал командной sh. И теперь мы видим, что уже работаем с этим терминалом внутри контейнера.
![[Pasted image 20241010143717.png]]

У каждого контейнера в докер есть свой ip адрес, который указывается автоматически. Находясь внутри контейнера мы можем использовать различные sh команды. Например, hostname - возвращает имя хоста. Когда мы внутри контейнера, то имя хоста = id контейнера. hostname -i - получаем ip адрес контейнера.
![[Pasted image 20241010144018.png]]

### Есть ли доступ в интернет внутри контейнера?
Введем команду ping, чтобы проверить. Видим, что получаем ответ от сервера с ip 8.8.8.8(DNS сервер гугла)
![[Pasted image 20241010144210.png]]


Теперь, если мы откроем еще один терминал и введем `docker ps` то увидим, что у нас будет рабочий контейнер busybox. 
![[Pasted image 20241010144639.png]]

Чтобы завершить работу контейнера - можно либо завершить процесс внутри контейнера, либо вызвать команду `docker stop container_id`.

`docker container prune` - удалить все остановленные контейнеры.
![[Pasted image 20241010144842.png]]

### Создание контейнера NGINX
NGINX - это веб-сервер, который может возвращать клиентам различным статический контент. Запустим его, используя docker.
`docker run nginx`. Мы увидим, что в данном случае будут скачаны несколько слоев, а также мы будем автоматически подключены к процессу nginx. Т.е. по сути мы подключились к выводу, т.е. к логам, которым выводит процесс nginx.
![[Pasted image 20241010145557.png]]

Но теперь появляются вопросы, как обратиться к серверу nginx, который мы создали. Как вернуться в командную строку, т.к. мы подключены к выводу процесса nginx.
В другом терминале введем `docker ps` и увидим, что в контейнере, в котором запущен nginx есть port 80/tcp. Это означает, что внутри контейнера открыт порт 80 и к нему можно подключиться. Этот порт открыл процесс nginx. 
![[Pasted image 20241010145917.png]]
Но как подключиться со своего компьютера к серверу nginx? Пока что никак. Мы должны настроить маппинг портов.

### Как запустить контейнер в background
Как мы можем запустить процесс в background, чтобы не было такого, как было с nginx, когда мы сразу же подключились к контейнеру внутри терминала.
Нужно добавить опцию -d.
![[Pasted image 20241010150344.png]]

Каждый раз, когда мы вводим docker run, то создается новый контейнер, т.е. не перезапускается тот, который был остановлен, он так и остается остановленным.
Запускаем в фоновом режиме и нам выводится id контейнера. Если вызвать docker ps, то увидим этот запущенный контейнер с nginx, который ожидает подключений.
![[Pasted image 20241010150610.png]]

### Как получить информацию по контейнеру?
`docker container inspect <container_id>` 
Получим следующий вывод:
![[Pasted image 20241010150916.png]]
Если хотим отфильтровать вывод:
![[Pasted image 20241010151006.png]]
И в этом выводе мы можем узнать id адрес контейреа.
Но если мы сейчас попробуем через браузер обратиться по этому адресу(а веб браузер использует протокол http, а http по дефолту использует порт 80 и протокол tcp), то он не сможет подключиться.

### Остановка контейнера
`docker stop <container_id/name>`
![[Pasted image 20241010151306.png]]
Но на самом деле процесс может не реагивать на эту команду, т.к. на самом деле докер просто отправляет команду stop в процесс, чтобы он остановился. Если не реагирует, то в таком случае можно использовать 
`docker kill <id/name>` тогда процесс будет остановлен сразу же.

### Запуск дополнительных процессов в уже запущенном контейнере
![[Pasted image 20241010151640.png]]
it нужна для того, чтобы подключить терминал к процессу, который мы собрались запускать.
Например, давайте запустим nginx в background и потом создадим внутри этого контейнера еще один процесс, который будет работать с bash и подключимся к нему. И теперь мы попали внутрь контейнера и можем, например, посмотреть файлы внутри него, используя ls.
![[Pasted image 20241010152034.png]]

### Создание контейнера с определенным именем
`docker run -d --name <custom_name> <image_name>`
![[Pasted image 20241010152400.png]]


### Теперь перейдем к мапингу портов, чтобы NGINX наконец-то стал доступным
-p - publish. С помощью этой команды можно открыть порт на НАШЕМ КОМПЬЮТЕРЕ и пробросить его на другой порт внутри контейнера. И эту проброску делает докер. И после этого при обращении по порту 8080 докер перекинет это подключения во внутрь контейнера.
![[Pasted image 20241010152646.png]]
Т.е. теперь если в браузере ввести localhost:8080, то получим страничку, которую возвращает nginx при обращении к нему(она хранится в файлах внутри контейнера, мы ее может даже посмотреть, если подключим еще один процесс bash и зайдем в директорию, с этой страничкой. В курсе мужик показывал, где она находится).
![[Pasted image 20241010153244.png]]
Только появился вопрос, а почему localhost, а не тот IP, который реально имеет контейнер? Ответ кроется в docker ps. Тут мы видим в post 0.0.0.0:8080 - это и есть маппинг портов. 0.0.0.0 - означает, что можем вводить любой IP нашего компьютера, в том числе localhost.
![[Pasted image 20241010154703.png]]

Также мы можем запустить еще один контейнер с nginx и указать другой публичный порт, например, 8081. Тогда у нас будет запущена 2 nginx и при обращении по 8080 - будет проброшено подключение к первому nginx. А при 8081 - ко второму.

Если же мы случайно используем порт, который уже используется то получим ошибку:
![[Pasted image 20241010155328.png]]

### Автоматическое удаление контейнера после того, как он был остановлен
Добавив --rm контейнер будет автоматически удален после остановки.
![[Pasted image 20241010162755.png]]

### Запуск остановленных когда-то контейнеров
`docker start <id/name>`

### Разделение команды на строки
![[Pasted image 20241010163302.png]]

### Получение информации о маппинге томов
Для этого используется команда `docker container inspect <id/name>` и в ней уже нужно найти информацию о томах.
Вот информация о маппинге портов:
![[Pasted image 20241010163559.png]]
HostPort - это порт на компьютере, а 80 - это порт внутри контейнера.
Маппинг томов находится в разделе Mounts:
![[Pasted image 20241010163654.png]]
Source - абсолютный путь до папки на моем компьютере.
Destination - абсолютный путь до папки внутри контейнера.
Также, если промотать в самый верх, то может увидеть команду, которая выполнилась при запуске контейнера.
![[Pasted image 20241010163950.png]]

### Вывод логов контейнера
`docker logs <container_id>` - так мы можем получить вывод конкретного контейнера
![[Pasted image 20241010220554.png]]