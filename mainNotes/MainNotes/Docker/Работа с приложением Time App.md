С помощью этого приложения мы разберемся, как поднять сразу 4 контейнера:
1. backend
2. frontend
3. db
4. adminer(это просто UI для работы с БД. Т.е. как в pgAdmin в postgres)
Структура выглядит так:
![[Pasted image 20241010221201.png]]

### Как будет происходить взаимодействие
Внутри Docker у нас будет запущено 4 контейнера. Причем пока мы не опубликуем порты к ним будет невозможно подключиться. Т.е. нужно будет настраивать порты. 

Начнем с фронтенд. Клиенты будут подключаться к фронтенду(скорее всего, мы поднимем nginx, который будет хранить статические файлы и возвращать их по запросу. На самом деле нет, в Vue.js там есть прям main функция, которая уже вставляет в index.html всякий динамический контент. Т.е. мы будет в контейнере запускать эту функцию), чтобы он вернул им HTML, CSS, JS файлики. Т.е. возвращаем клиенту внешний вид страницы.
![[Pasted image 20241010221457.png]]

После того, как на клиенте пользователь нажал кнопку сохранить время, то приложение на клиенте должно отправить запрос на backend. Т.е. для нажатия кнопки есть обработчик, который отправляет запрос на backend. А сама эта логика работы пришла клиенту с фронтенда.
![[Pasted image 20241010221910.png]]
После таких запросов бекенд уже будет взаимодействовать с контейнером, в которой запущена БД. Т.е. между бекенд контейнером и контейнером БД есть взаимодействие внутри docker сети. И после этого бекенд сервис отправляет данные клиентам.
![[Pasted image 20241010222005.png]]

Для управления БД мы также будем использовать веб-браузер. Для этого мы должны иметь возможность подключиться к контейнеру управления БД из нашего браузера, т.е. снова нужны публичные порты. Причем сам веб-интерфейс управления базой мы также получаем из контейнера управления БД. И этот контейнер при наших каких-то действия в браузере также будет нам отправлять данные.
![[Pasted image 20241010222151.png]]
![[Pasted image 20241010222249.png]]

### Открытие портов
На зеленом фоне указаны публичные порты. Публичные порты должны быть свободны на нашем компьютере, иначе один из сервисов может не запуститься.
![[Pasted image 20241010224232.png]]

### План запуска
![[Pasted image 20241010224823.png]]

### Docker Compose file
![[Pasted image 20241010224908.png]]

На бекенд, например, для подключения к БД в host будем указывать имя сервиса. Т.к. мы знаем, что внутри сети, которую создаст докер для наших контейнеров будет работать DNS, который будет ресолвить имена контейнеров на динамические IP адреса внутри контейнера(динамические - потому что мы узнаем их только после запуска контейнеров).
![[Pasted image 20241010231714.png]]

Также стоит заметить, что и frontend и backend требуют внешних зависимостей. Они указаны в файликах package.json. Для установки этих зависимостей используется команда npm install. После этого создается папка node-modules со скаченными зависимостями. 

### Dockerfile для frontend
![[Pasted image 20241011134447.png]]
EXPOSE 3000 - говорит о том, какой порт открыт в контейнере. Но эта инструкция не играет роли, как порты открываются в контейнере. В контейнере порты открываются определенным процессом, который запускается в контейнере и опция EXPOSE на это не влияет. Т.е. порт должен открыть сам процесс внутри контейнера. EXPOSE добавляют для того, чтобы другие разработчики понимали на каком порту работает процесс внутри контейнера.

С помощью COPY package*.json ./ - мы копируем файлы, в которых хранятся зависимости в рабочую директорию. Далее RUN npm install, чтобы установить эти зависимости. А дальше COPY, чтобы скопировать оставшиется файлы нашего фронтенд приложения. И в конце, чтобы запустить само приложение используем команду npm run dev.

Зачем два COPY? Это нужно для оптимизации, поскольку когда мы будем разрабатывать наше приложение, то будем изменять какие-то файлики с кодом, но при этом сами зависимости будут не так часто изменяться. Поэтому, когда мы напишем новую версию программы и захотим пересоздать образ, то будут переиспользованы слои с копированием и установкой зависимостей, т.к. они не изменились с прошлого создания образа.

### Dockerfile для backend
![[Pasted image 20241011194024.png]]
