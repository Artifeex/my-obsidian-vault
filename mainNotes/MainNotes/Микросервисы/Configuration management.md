Вопрос: Как отделить конфигурацию от основного приложения? Это нужно, чтобы нам не приходилось создавать новый docker image для каждой среды, а использовать один и тот же docker image и изменять только конфигурации, которые располагаются отдельно. 
![[Pasted image 20241202135211.png]]
В Spring Boot есть решения этих 3 челленджей:
![[Pasted image 20241202135350.png]]
### Как SpringBoot приложение конфигурирует приложение?
Также снизу через 
- представлены способы, которыми мы можем конфигурировать наше SpringBoot приложение. Причем они расположены в порядке от менее приоритетного до более приоритетного.
![[Pasted image 20241202140134.png]]
###  Способы получить значения
![[Pasted image 20241202140928.png]]
Чтобы работало @ConfigurationProperties:
![[Pasted image 20241202145053.png]]
![[Pasted image 20241202145131.png]]
![[Pasted image 20241202145147.png]]
### SpringBoot Profiles
Хорошо, мы научились читать в нашем приложении данные из application.yml, а также из environment, но как изменять значения под разными environments.
С помощью профайлов мы можем выбирать, какой файл с properties будет загружен в наше приложении, а также какие бины будут созданы.

Для создания properties файлов для разных профайлов используется конвенция:
application_prod - чтобы этот файлик начал влиять на наше приложении, нужно, чтобы оно было запущено с включенным профайлом prod.
Дефолтный профайл работает по дефолту с application.properties.
![[Pasted image 20241202150944.png]]
Таким образом, чтобы создать профайл:
- application_< profile_name>.properties. Причем таких профайлов в нашем приложении мы создаем сразу под все среды.
Активировать профайл:
- spring.profiles.active=< profile_name>

Важно, что в профайлах, которые мы создаем должны находиться только специфичные настройки для среды. Т.е. все общее для всех профайлов и нам не нужно менять это свойство среди множества сред мы оставляем в application.yml, т.к. этот файлик применяется по умолчанию, а в других мы уже переписываем значения, которые хотим, например, datarouse.url.

Также в файлике мы задаем следующие настройки, чтобы файл был активирован, когда включает профайл с именем "qa". Это нужно, поскольку в имени профайла мы указали нижнее подчеркивание. Если бы мы указали application-qa, то Spring по дефолту, основываясь на имени файла, использовал бы наш application-qa файл, если qa профайл активирован.
![[Pasted image 20241202152617.png]]
![[Pasted image 20241202153201.png]]
Также мы должны указать в application.yml следующее, чтобы сообщить Spring о наших профайлах. Ноо! Это все нужно только в том случае, если мы не хотим использовать стандартную конвенцию имен профайлов - application-< profile_name>.yml. Если мы используем такую конвекнцию, то не нужно указывать ни on-profile, ни spring.config.import
![[Pasted image 20241202153715.png]]

Для активации профайла qa в application.yml файл пишем:
spring
	profiles:
		active:
		  -qa
![[Pasted image 20241202154703.png]]

Но мы теперь столкнемся с проблемой, что для того, чтобы активировать профайл, нужно изменять application.yml под каждую среду. Но это неправильно, т.к. мы хотим действовать в соотвествии с [[15 Factor]]. Поэтому мы должны уметь откуда-то снаружи при старте нашего приложения изменять значения нужных нам значений в application.yml файле.

### Как изменять значения в application.yml при старте приложения?

Мы можем использовать параметры командной строки при запуске jar файла. Причем параметры командной строки являются наивысшими по приоритету и поэтому без проблем заменят значения в application.yml. Помимо переписывания можем задавать и новые значения, которые не было в application.yml
![[Pasted image 20241202155253.png]]
Чтобы активировать профайл: --spring.profiles.active=prod

Мы можем использовать JVM properties. Они по приоритету ниже, чем передачу через параметры командной строки. Но выше, чем в application.yml
![[Pasted image 20241202155519.png]]
Чтобы активировать профайл: -Dspring.profiles.active=prod

Использовать environment variables. Их плюс в том, что они подходят и в том случае, если мы не используем Java, а какой-нибудь микросервис на другом языке. Только нужно соблюдать конвенцию: build.version в application.yml превращается в BUILD_VERSION, когда мы используем environment variables, чтобы переписать это значение.
![[Pasted image 20241202155835.png]]
Чтобы активировать профайл: SPRING_PROFILES_ACTIVE=prod.
Если хотим задать несколько значений, то используем ; между ними.

### Обсудим минусы предоставления значений способами, описанными выше
![[Pasted image 20241202165221.png]]
- Нет возможности закодировать пароль, чтобы не показывать его нигде в открытом виде. Ведь даже если мы передаем пароль через environment variables, то этот пароль видят те, кто занимаются разворачиванием приложения.
- Нет возможности изменить значения у уже запущенного микросервиса. Чтобы обновить значение, нужно перезапустить микросервис.
- Нет возможности версионирования. Когда мы переходим на новую версию приложения, то мы можем менять application.properties какие-то составляющие, значения и в таком случае, нам нужно, чтобы была возможность версионирвания. Также, неплохо было бы иметь возможность аудита.
- Даже если мы будем использовать автоматизацию для запуска приложений, то могут просочиться ошибки, ведь автоматизацию также пишут люди.

### Для решения этих проблем существует Spring Cloud Config Server
Это отдельное Spring приложение. К нему регистрируются микросервисы и он выдает им конфигурации. Т.е. это такое централизованное хранилище конфигураций. Причем место, где хранить эти конфигурации мы выбираем сами. Это может быть как github, так и какое-то локальное хранилище или еще где-то.
![[Pasted image 20241202170627.png]]
Spring Cloud - это набор модулей, которые помогают решить проблемы, связанные с реализацией Cloud applications. 
![[Pasted image 20241202170859.png]]

### Реализация
Нужно добавить зависимость Spring
```xml
<dependency>  
    <groupId>org.springframework.cloud</groupId>  
    <artifactId>spring-cloud-config-server</artifactId>  
</dependency>
```
Также использовать аннотацию @EnableConfigServer
![[Pasted image 20241202174618.png]]
Теперь нужно где-то хранить все конфигурации, которые будет читать для нас ConfigurationServer:
- GitHub - самый популярный подход.
- classpath - указываем где хранится
- filesystem - где-то храним директорию с конфигурациями.

### Classpath способ
В проекте с Server Config в resource директории создаем .yml файлы. Но какое имя им дать? Для имени используем имя микросервиса, которому принадлежат файлы. Например, если мы храним в файле проперти микросервиса - accounts, то и файл называем accounts.yml. Имя файла должно совпадать с именем spring boot приложения, которому принадлежит файл - spring.application.name. 
Т.е. в application.yml в проекте accounts должно быть spring.application.name=accounts. А в Config Server проекте будут лежать файлы, которые связаны с accounts проектом с именами accounts.yml, accounts_qa.yml, accounts_prod.yml. И для других проектов аналогично.
![[Pasted image 20241202181547.png]]
Внутри файлов оставляем только информацию, которая свойствена этому профайлу. Т.е. то, что должно поменяться в зависимости от профайла.

Вот, храним только какие-то специфичные штуки, которые будут меняться.
account.yml:
![[Pasted image 20241202180521.png]]
accounts-prod.yml:
![[Pasted image 20241202180600.png]]
accounts-qa.yml:
![[Pasted image 20241202180626.png]]

Далее мы в Server Configuration классе в его application.yml прописываем:
![[Pasted image 20241202181247.png]]

И теперь мы можем проверить, работает или нет. Для этого обращаемся к серверу, например, по http://localhost:8071/accounts/prod
И получим как раз содержимое файлика accounts-prod.yml
![[Pasted image 20241202181751.png]]
Вместе с prod переданы еще и default пропертис. Но это потому что они загружаются всегда по дефолту, а потом уже будут переписаны теми, что указаны в accounts-prod.yml

### Подключаем наш микросервис к серверу конфигураций
Теперь научимся подключать к нашему микросервису эти файлы конфигурации, которые располагаются на Configuration Server.

Удаляем все application-< profile>.yml файлы. Они теперь не нужны, т.к. будем получать их с сервера.
Дефолтный application.yml оставляем и не забываем указать в нем имя нашего приложения, т.к. именно по этому имени он будет отдавать нашему микросервису его конфигурационный файл. 

Добавляем зависимость client в наш микросервис:
```xml
    <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-config</artifactId>
    </dependency>
```

```xml
 <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-dependencies</artifactId>
        <version>${spring-cloud.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>
```

```xml
<properties>
    <java.version>17</java.version>
    <spring-cloud.version>2023.0.3</spring-cloud.version>
  </properties>
```

В application.yml:
```yml
spring:
  config:
    import: "optional:configserver:http://localhost:8071/"
```
optional - указывает на то, что если по каким-либо причинам config server не ответил, то мы продолжаем запускать наше приложение, но, просто не обновим значения пропертей, которые обновились бы, при использовании выбранного профайла. 
configserver - говорит спрингу, что мы будем использовать config server для конфигураций, а потом указывает хост и порт, на котором работает этот config server. После этого мы запускаем приложении и можем активировать любой из профайлов теми способами, которые описывали ранее(JVM, program variables, environment variables). И все будет работать, данные из файлика на сервере подтянутся в соотвествии с активированным профайлом.
Также мы можем активировать дефолтный профайл при запуске приложения:
![[Pasted image 20241202184247.png]]
