Какие проблемы хотим решить.
Avoid Temporal coupling - мы хотим избегать временной связи. Временная связь - это когда у нас есть микросервис1 и он зависит от микросервиса2. Микросервис1 вызывает микросервис2 и ждет, пока он не выполнит запрос. И любые промедления микросервиса2 будут влиять и на микросервис1, а мы хотим этого избегать. Такая проблема возникает, когда мы пытаемся использовать синхронное общение между микросервисами.

В синхронном общении есть 2 основных подхода:
1. Императивный - под запрос выделяется поток(а сколько потоков в приложении в Spring?), который отправил HTTP запрос и ждет ответ. 
2. Реактивный - поток, который обрабатывает запрос не будет сидеть и ждать ответа, он пойдет заниматься другими делами и только тогда, когда ответ вернется, то отправит клиенту ответ.
   Но даже несмотря на то, реактивный подход все еще остается синхронным общением, поскольку микросервис 1 все равно приходится ждать ответа от микросервиса 2, даже если его ресурсы используются более эффективно за счет того, что используется реактивный подход.

Чтобы решить проблему временной связи в идеале использовать асинхронное общение там, где это возможно(но такое возможно далеко не везде. например, если пользователь хочет получить значение баланса на счету, то тут в любом случае просто делать запрос о получении баланса и ждать, асинхронного общение не будет и выигрыша от него тоже, т.к. пользователь просто попросил баланс).

Для реализации асинхронного общения можно исползовать Event-Driven подход. Например, у нас есть микросервис заказов и микросервис доставок. После того, как пользователь совершил покупку, нам микросервис заказов должен отправить сообщение в микросервис доставок, чтобы сообщить ему о том, что нужно будет совершить доставку такого-то товара, при этом ему не нужно ждать ответа от микрсервиса доставок, т.к. микросервис заказов уже сделал свою работу - сообщин об этом сервису доставок. 

Как строить Event-driven микросервисы:
![[Pasted image 20241210120747.png]]

Есть 2 основные модели для реализации Event-driven
![[Pasted image 20241210121802.png]]
1. Publisher/Subsriber. Publisher генерируют эвенты и отправляют их подписчикам, после отправки эвент нигде не сохраняется. Поэтому если потом подключиться еще один подписчик, то он не сможет получить информацию с прошлых рассылок, а только дожидаться новых. Самая популярная реализация - RabbigMQ.
2. Event Streaming Model. Publisher публикуют эвенты, но не подписчикам, а в специальные event stream, в том порядке, в котором эвенты происходили. Подписчики подписываются не под конкретные эвенты, а могут считывать информацию из любого event stream-а. И отличием от publisher/subsriber является то, что эвенты сохраняются внутри event stream. И тогда, если какой-то из подписчиков подключился, то он может обратиться к event stream и пропустить через себя все эвенты, что происходили до того, как он подключился. 
   Самая популярная реализация - Kafka.
Какой вариант выбрать зависит от бизнес модели. Если нам не нужно, чтобы подписчики могли воспроизводить эвенты из прошлого, то можем использовать pub/sub модель. 

### Pub/sub model
Пример сценариев, когда можно использовать pub/sub model(на самом деле это не только pub/sub model, но и для event stream подхода также подходит. Просто broker другой.)
Юзер создал аккаунт в нашем микросервисе accounts, а мы также хотим отправить юзеру нотификейшен об этом на почту, поэтому мы в брокер кладем event о том, что user создал аккаунт, это эвент читается message service-ом и он уже отправляет нотификейшен. А когда нотификейшен был отправлен, то message service может отправить в broker сообщение, что он был отправлен
![[Pasted image 20241210141017.png]]
1-2-3 - синхронное общение, а 3-4-5-6-7 - это асинхронное.

И плюсом является то, что, во-первых, микросервисы не ждут, когда другой ответит и могут сразу идти обрабатывать другие запросы - это круто по перформансу. А также круто то, что если даже микросервис упадет, то он потом может восстановиться и прочитать event(в случае, если используется event streaming вариант). Также микросервисы могут не знать о том, сколько и какие микросервисы отправляют в broker сообщения. Они знают только о брокерах.

### RabbitMQ
Опен-сорсный message broker. Использует протокол AMQP. Предоставляет возможность асинхронного программирования. В последних версиях помимо pub/sub модели предоставляет еще и event streaming вариант, но из-за того, что это было добавлено не так давно, Kafka стала монополистом на рынке event streaminga.

Под капотом работает так. Producer отправляет сообщение в exchange(обменник), который на основе прописанных маршрутных правил отправляет сообщение в соответсвующую очередь. Consumers читают сообщения из очередей и такое сообщение в очереди после того, как было потреблено всеми consumer-ами, кто читает из этой очереди - удаляется из очереди.
![[Pasted image 20241210145241.png]]
