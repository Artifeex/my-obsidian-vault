Какие проблемы хотим решить.
Avoid Temporal coupling - мы хотим избегать временной связи. Временная связь - это когда у нас есть микросервис1 и он зависит от микросервиса2. Микросервис1 вызывает микросервис2 и ждет, пока он не выполнит запрос. И любые промедления микросервиса2 будут влиять и на микросервис1, а мы хотим этого избегать. Такая проблема возникает, когда мы пытаемся использовать синхронное общение между микросервисами.

В синхронном общении есть 2 основных подхода:
1. Императивный - под запрос выделяется поток(а сколько потоков в приложении в Spring?), который отправил HTTP запрос и ждет ответ. 
2. Реактивный - поток, который обрабатывает запрос не будет сидеть и ждать ответа, он пойдет заниматься другими делами и только тогда, когда ответ вернется, то отправит клиенту ответ.
   Но даже несмотря на то, реактивный подход все еще остается синхронным общением, поскольку микросервис 1 все равно приходится ждать ответа от микросервиса 2, даже если его ресурсы используются более эффективно за счет того, что используется реактивный подход.

Чтобы решить проблему временной связи в идеале использовать асинхронное общение там, где это возможно(но такое возможно далеко не везде. например, если пользователь хочет получить значение баланса на счету, то тут в любом случае просто делать запрос о получении баланса и ждать, асинхронного общение не будет и выигрыша от него тоже, т.к. пользователь просто попросил баланс).

Для реализации асинхронного общения можно исползовать Event-Driven подход. Например, у нас есть микросервис заказов и микросервис доставок. После того, как пользователь совершил покупку, нам микросервис заказов должен отправить сообщение в микросервис доставок, чтобы сообщить ему о том, что нужно будет совершить доставку такого-то товара, при этом ему не нужно ждать ответа от микрсервиса доставок, т.к. микросервис заказов уже сделал свою работу - сообщин об этом сервису доставок. 

Как строить Event-driven микросервисы:
![[Pasted image 20241210120747.png]]

Есть 2 основные модели для реализации Event-driven
![[Pasted image 20241210121802.png]]
1. Publisher/Subsriber. Publisher генерируют эвенты и отправляют их подписчикам, после отправки эвент нигде не сохраняется. Поэтому если потом подключиться еще один подписчик, то он не сможет получить информацию с прошлых рассылок, а только дожидаться новых. Самая популярная реализация - RabbitMQ.
2. Event Streaming Model. Publisher публикуют эвенты, но не подписчикам, а в специальные event stream, в том порядке, в котором эвенты происходили. Подписчики подписываются не под конкретные эвенты, а могут считывать информацию из любого event stream-а. И отличием от publisher/subsriber является то, что эвенты сохраняются внутри event stream. И тогда, если какой-то из подписчиков подключился, то он может обратиться к event stream и пропустить через себя все эвенты, что происходили до того, как он подключился. 
   Самая популярная реализация - Kafka.
Какой вариант выбрать зависит от бизнес модели. Если нам не нужно, чтобы подписчики могли воспроизводить эвенты из прошлого, то можем использовать pub/sub модель. 

### Pub/sub model
Пример сценариев, когда можно использовать pub/sub model(на самом деле это не только pub/sub model, но и для event stream подхода также подходит. Просто broker другой.)
Юзер создал аккаунт в нашем микросервисе accounts, а мы также хотим отправить юзеру нотификейшен об этом на почту, поэтому мы в брокер кладем event о том, что user создал аккаунт, это эвент читается message service-ом и он уже отправляет нотификейшен. А когда нотификейшен был отправлен, то message service может отправить в broker сообщение, что он был отправлен
![[Pasted image 20241210141017.png]]
1-2-3 - синхронное общение, а 3-4-5-6-7 - это асинхронное.

И плюсом является то, что, во-первых, микросервисы не ждут, когда другой ответит и могут сразу идти обрабатывать другие запросы - это круто по перформансу. А также круто то, что если даже микросервис упадет, то он потом может восстановиться и прочитать event(в случае, если используется event streaming вариант). Также микросервисы могут не знать о том, сколько и какие микросервисы отправляют в broker сообщения. Они знают только о брокерах.

### RabbitMQ
Опен-сорсный message broker. Использует протокол AMQP. Предоставляет возможность асинхронного программирования. В последних версиях помимо pub/sub модели предоставляет еще и event streaming вариант, но из-за того, что это было добавлено не так давно, Kafka стала монополистом на рынке event streaminga.

Под капотом работает так. Producer отправляет сообщение в exchange(обменник), который на основе прописанных маршрутных правил отправляет сообщение в соответсвующую очередь. Consumers читают сообщения из очередей и такое сообщение в очереди после того, как было потреблено всеми consumer-ами, кто читает из этой очереди - удаляется из очереди.
![[Pasted image 20241210145241.png]]

### Spring Cloud Function
![[Pasted image 20241216152701.png]]
Т.е. я смогу использовать Supplier, Function, Consumer в моим проектах, а реализацию этих интерфейсов возьмет на себя Spring Cloud Function.

Spring Cloud Function нужна для того, чтобы реализовать общение между функциями, которые мы напишем - Supplier, Function, Consumer. Т.е. мы будем использовать эти функции, а потом Consumer сможет консьюмить значения из сапплаера, а эта связь будет реализована за нас Spring Cloud Function. Т.е. мы сможем писать бизнес логику и не думать о том, как что общается. Причем Spring Cloud Function может быть интегрирована с брокерами сообщений.
![[Pasted image 20241216153509.png]]

Кратко: офигенный плюс Spring Cloud Function в том, что мы можем для реализации бизнес логики использовать функции - Supplier, Function, Consumer, а общение возьмет на себя Spring Cloud Function и плюсом является то, что мы сможем без проблем менять технологии, которые используютяс для общения. Это может быть REST API, это может быть очереди и все, что угодно. Бизнес логику переписывать не придется при переходе между технологиями общения. 

Для реализации напишем микросервис нотификаций.  В него будут по брокеру приходить сообщения, а он будет отправять email нотификации(но саму реализацию нотификаций мы писать не будем).

Зависимость:
![[Pasted image 20241216155116.png]]

Создаем Dto - которое будет принимать нам message микросервис.
![[Pasted image 20241216170147.png]]

Создаем 2 функции. Первая будет отправлять сообщения на email, а вторая смски. Обе функции из брокера будут принимать AcountsMsgDto, в котором будет передаваться информация о пользователе, куда собственно отправить нотификацию. Заметим, что мы используем Function, потому что хотим не только потребить, но еще отправить в брокер сообщение о том, что нотификация была отправлена, чтобы другой микросервис мог сохранить в БД об этом информацию(да, мы зачем-то это сохраняем).
![[Pasted image 20241216170914.png]]

Как теперь сконвертировать эти функции в RestAPI(пока мы не через брокер общаемся)
Добавляем такую зависимость:
![[Pasted image 20241216171833.png]]
И после этого мы можем отправлять запросы, используя названия функций и передавая параметры для запроса.
![[Pasted image 20241216172158.png]]

для sms аналогично. А как вызвать одновременно две? 
![[Pasted image 20241216172652.png]]
А в запросе теперь объединяем имена:
![[Pasted image 20241216172700.png]]

### Spring Cloud Stream
Spring Cloud Stream нужен для того, чтобы предоставить нам API для работы с event streaming подходом. И этот API будет одинаковым какой бы броке мы не использовали, т.к. это надстройка над ними. В целом, это похоже чем-то на логгеры. Когда есть некоторый одинаковый API, а под ним уже мы можем подключать разные виды логгеров.
![[Pasted image 20241216173130.png]]
Он помогает также как и Spring Cloud Function. Мы сможем изменять брокер, по которому общаемся без сильных изменений.
![[Pasted image 20241216173855.png]]
![[Pasted image 20241216174132.png]]

Необходимые зависимости:
![[Pasted image 20241216174520.png]]

### [[Apache Kafka vs RabbitMQ]]