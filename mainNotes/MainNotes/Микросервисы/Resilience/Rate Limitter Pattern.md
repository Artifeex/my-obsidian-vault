Паттерн, который позволяет контролировать и ограниичивать входящий трафик в наши микросервисы. Это нужно для того, чтобы избежать ддос атак, когда злоумышленник резко начинает нагружать наши сервера, тем самым приводя нашу систему в негодность. 

После того, как пользователь превзошел лимиты в заданный период времени, то сервер не обрабатывает его запросы, а сразу отвечает со статусом 429 - Too Many Requests. Мы можем ограничивать количество запросов юзера в рамках сессии или IP и т.д.

Также с помощью этого паттерна мы можем ограничивать какой-то трафик с малым приоритетом, чтобы основные части системы работали. 

В Spring есть реализация этого паттерна:
### Redis RateLimiter
Он использует Tocket Bucket Algorithm
![[Pasted image 20241206152643.png]]
- replenishRate - сколько токенов восстанавливается в секунду и помещается в bucket. 
- burstCapacity - вместимость bucketa. Для каждого клиента создается свой bucket. Для определения того, что запрос пришел от одного и того же клиента испольузется KeyResolver, который мы сами пишем. 
- requestedTokents - это стоимость запроса в токенах. По дефолту 1 запрос = 1 токен.
Таким образом, получается следующий механизм работы:
Если пользователь не делает запросов, то исходя из replenishRate столько токенов будет добавляться в его bucket каждую секунду. У bucket есть максимальное количество токенов, которое он может хранить - burstCapacity. Когда bucket полностью заполнился токенами, дальше он не заполняется. Когда пользователь решает сделать запрос, то исходя из стоимость запроса - requestedTokens он забирает из своего бакета данное число токенов. И комбинируя эти настройки мы можем получать различные стратегии работы. 

Например, replenishrate = 1, burstCapacity = 1, requestedTokens = 1 - такой настройкой мы разрешаем пользователю делать 1 запрос в секунду, причем т.к. burstCapacity=1, то даже если пользователь не будет делать запросы в какую-то из секунд, то копиться токены не будут.

### Реализация в Gateway Server
Добавляем зависимость
```xml
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-data-redis-reactive</artifactId>  
</dependency>
```
Создаем 2 бина и добавляем RateLimiter в /eazybank/cards:
![[Pasted image 20241206155120.png]]
В RedisRateLimiter мы загоняем 1, 1, 1 - replenishRate, burstCapacity, requestedTokents

Для работы всего этого дела нужно запусть redis сервер, который и будет хранить бакеты.
Запустим redis сервер(с дефолтными настройками и credentials)
![[Pasted image 20241206162226.png]]
![[Pasted image 20241206162212.png]]
После этого будет разрешен только 1 запрос в секунду. Если будет больше, то будет возвращаться 429 статус.
Существует Apache Banchmark Server, который позволяет отправлять запросы на наш сервер и тестировать его работу под нагрузкой. 

### Как реализовать RateLimiter в accounts микросервисе на его методе
Никакие зависимости не добавляем, поскольку нам это все предоставляет Resilience4j.
Метод fallback, который будет обрабатывать ошибку в случае, если был превышен limit должен иметь такую же сигнатуру, только еще всегда добавляется Throwable. Если бы наш исходный метод принимал какие-то параметры, то и fallback метод, который мы пишем также должен был бы принимать эти же параметры + Throwable.
![[Pasted image 20241206164827.png]]
![[Pasted image 20241206164116.png]]
