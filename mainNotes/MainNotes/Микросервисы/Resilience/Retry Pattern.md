![[Pasted image 20241206124041.png]]
Добавим механизм ретраев при обращении в /loans. Причем только для GET методов, т.к. нам важно, чтобы те методы, которые мы будем ретраить были идемпотентны. Поскольку если они не будут таковыми, то несколько ретраев могут что-то поломать.
![[Pasted image 20241206133642.png]]
В setBackoff мы передаем:
- firstBackoff - время, через которого нужно будет сделать первый ретрай в случае HTTP таймаута.
- maxBackoff - максимальное время между ретраями
- factor - во сколько раз будет увеличиваться время firstBackoff.  
- basedOnPreviousValue - должен ли factor умножаться на предыдущее вычисленное значение. Т.е. если true, то время между ретраями будет постоянно увеличиваться, умножаясь на factor, после каждого ретрая.
![[Pasted image 20241206133757.png]]

Теперь если попытаемся обратить и поставим breakpoint, то увидим, что ожидание ответа было около 9 секунд. Это потому что происходил механизм ретраев. Ранее мы настроили Http Timeout(в Microservice Resilience. Мы сказали, что будет ждать ответа 2 секунды.) И после этого мы добавили механизм ретраев. После которого, если за 2 секунды, которые мы настроили на ожидание не пришел ответ, то происходит ретрай и так столько раз, сколько мы настроили в настройке выше. Как получилось 8. 95 секунд?
Первые 2 секунды ожидалось выполнение запроса, он не выполнился, происходит ожидание 100 миллисекунд и выполнятся ретрай, снова ждет 2 секунды, опять не выполнился, снова ретрай, но уже ждем (100 * 2)) перед следующим ретраем.
Итого 2 + (3 * 2) + 100 + 100 * 2 + 200 * 2 = 8.7 ну и там еще накладные расходы какие-нибудь.
![[Pasted image 20241206134358.png]]
### Условия для ретрая
Но мы можем ретраить не только, если закончилось время ожидания. Например, если в респонсе вернулась ошибка, то мы можем также выполнить ретрай. Т.е. мы можем задавать правила, когда будет происходить ретрай.

### Как реализовать Retry Pattern внутри микросервиса, а не Gateway  
В application.yml accounts микросервиса добавляем настройку для retry.
- max-attempts - кол-во ретраев(причем тут особенность, что первый запрос также входит в это количество. Т.е. по сути при значении max-attempts=3 ретраев будет всего 2.)
- wait-duration - время между ретраями
- enable-exponential-backoff - аналогично basedOnPreviousValue их Gateway retry.
- exponentional-backoff-multiplier- аналогично factor из Gateway retry
![[Pasted image 20241206142217.png]]
Навешиваем аннотацию @Retry над методом, который хотим, чтобы ретраился. Указываем в ней имя и fallbackMethod, который будет вызван 1 раз, если произойдет заданное число ретраев и ни разу не будет получен ответ.

![[Pasted image 20241206142512.png]]

В библиотеке **Resilience4j**, аннотация `@Retry` не заставляет клиента повторять запросы. Вместо этого она применяет логику повторных попыток (**retry**) к самому методу на стороне сервера, если тот выбрасывает исключения или не работает должным образом. То есть, когда клиент вызывает метод вашего контроллера, сам сервер будет пробовать выполнить метод несколько раз в случае ошибки, прежде чем возвращать fallback-ответ.
### Как это работает:

1. **Resilience4j AOP**: Аннотация `@Retry` работает на основе аспектно-ориентированного программирования (AOP). Когда метод аннотирован, вызов оборачивается специальным прокси-классом, который добавляет поведение повторных попыток.
2. **Поведение при вызове метода**: Если метод контроллера (`getBuildInfo`) выбрасывает исключение, Resilience4j автоматически перехватит это исключение и попробует повторить вызов метода заданное количество раз (по умолчанию три попытки, если не указано иное).
3. **Fallback**: Если после всех попыток метод продолжает выбрасывать исключение, Resilience4j вызывает метод-заместитель (fallback). В вашем случае, это `getBuildInfoFallback`.
### Пример работы:

1. Клиент делает вызов к `/build-info`.
2. Метод `getBuildInfo` выполняется.
3. Если метод завершился с ошибкой (например, выбросил исключение), Resilience4j:
    - Повторяет вызов метода.
    - Если задано 3 попытки, то метод будет вызван максимум 3 раза.
4. Если все попытки завершаются ошибкой, вызывается `getBuildInfoFallback`, который возвращает fallback-ответ.
### Почему аннотация на методе контроллера?

Аннотация `@Retry` применяется к тому коду, который вы хотите сделать "надежным". В данном случае это метод контроллера. Если метод выбрасывает ошибку (например, временная проблема с подключением к базе данных или другому сервису), сервер сможет повторить попытки вызова без участия клиента.
### Важный момент:

Если вы хотите заставить **клиента** выполнять повторные запросы, это уже задача клиента (например, с помощью библиотеки `Retry` в RestTemplate, Feign, или другой технологии на стороне клиента). Аннотация `@Retry` на стороне сервера не управляет поведением клиента.

Причем CircuitBreaker также продолжает работать! Мы его включили на уровне Gateway для accounts. И по умолчанию он ожидает 1 секунду овтета и если он не происходит, то он выполняет ответ. И это приводит к тому, что если мы укажем в Retry настройке на уровне accounts слишком большое время между ретраями - например, 500мс и 3 ретрая. Тогда т.к. ретраи выполняются на уровне сервера, т.е. происходит попытка еще раз вызвать метод(Gateway в этих попытках не принмает участие, а просто ждет ответа, причем про ретраи он даже не знает) то circuit breaker посчитает, что ответа не поступило и сам отправит ответ!!! Т.е. не будет вызвано заданное количество ретраев, если мы потратим на это время больше, чем указано в circuit breaker, который мы создали.

Особенностью реализации ретрая на уровне микросервиса, а не gateway является то, что circuit breaker не знает о фейлах, которые происходят в случае ретраев в данном случае. Если же мы хотим, что ретрая влияли и на circuit breaker, т.е. чтобы он переходил в состояние OPEN из-за ретраев, то нужно добавлять механизм ретраев в Gateway в том месте, где мы добавили circuit breaker.

### Настройка условий для выполнения ретрая
По дефолту, если произошло любое исключение, то ретрай выполнится. Но, что, если мы не хотим, чтобы ретрай выполнялся, например, в случае NullPointerException, т.к. нет смысла делать retry с такими же данными, с которыми мы получили null.

Поэтому мы можем в application.yml в application указываем:
![[Pasted image 20241206145317.png]]

![[Pasted image 20241206145715.png]]

Есть настройка благодаря которому мы наоборот указываем, какие исключения должны произойти, чтобы вызвался механизм ретраев:
![[Pasted image 20241206145757.png]]
### Шаги, которые мы сделали для реализации Retry Pattern 
![[Pasted image 20241206150450.png]]
![[Pasted image 20241206150512.png]]

### Как задать условия для retry на уровне Gateway?
![[Pasted image 20241206150103.png]]
