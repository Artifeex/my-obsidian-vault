Можно назвать его автоматическим выключателем. Как защита от короткого замыкания в электрической сети. Такой выключатель может отслеживать все ли хорошо с электрической цепью и если вдруг какая-то перегрузка, он он не даст этой перегрузке поломать все приборы в электросети. Т.е. он разомкнет цепь.
### Как это работает с микросервисами?
Во-первых, Circuit Breaker Pattern решает временные проблемы. Т.е., например, из-за проблем с сетью наш микросервис не может ответить на запрос. Но проблема с сетью не будет вечной, обычно они решаются довольно быстро. Аналогично с тем, что микросервис может быть перегружен запросами. Т.е. мы к нему отправляет запрос, а он и так загружен ими и мы еще сильнее его загружаем - это тоже временное явление. Если перестать слать в него запросы и дать ему время на разгрузку, то потом он снова будет готов выполнять запросы.

Circuit Breaker занимается тем, что следит за нашим сервисом, отслеживая все, поступающие в него запросы и как их выполняет наш микросервис и выполняет ли вообще. И в случае, если микросерис, например, перегружен, то Circuit Breaker ловит все запросы, которые идут в микросервис и сразу же отправляет ответ об ошибке, что сервис перегружен и пока не в состоянии вам ответить - этим мы решаем проблему ripple effect на всю систему. Т.е. тот микросервис, который сделал запрос - он не будет ждать кучу времени, чтобы в конце концов не получить ответа, а сразу же узнает об ошибке и сможет на нее как-нибудь быстро отреагировать. Также мы даем возможность передышки для микросервиса, перестав посылать в него новые запросы, т.е. реализуем self-recovery. 

Но может появиться вопрос, а сколько времени circuit breaker не будет давать запросам доходить до микросервиса? Ответ будет дан ниже:
### 3 состояния circuit breaker patterna
![[Pasted image 20241205173510.png]]
- Closed state - начальное состояние circuit breaker. В таком состоянии все запросы идут в микросервис. Но circuit breaker следит за запросами и их выполнением. Если в какой-то момент запросы начнут плохо обрабываться и это превысит какой-то заданный порог, то он перейдет в Open State. Failure rate - мы можем определять сами. Например, если 50% трафика в микросервис фейлится, значит, пора переходит в Open state.
- Open State - состояние, в котором circuit breaker не будет отправлять запросы в микросервис, а сразу будет их фейлить и отправлять клиентам ошибку. Сколько времени он будет находиться в таком состоянии? Это конфигурируемый параметр, пусть это будет 60 секунд. После этого Circuit Breaker перейдет в HALF_OPEN состояние.
- HALF_OPEN - мы начнем потихоньку нагружать микросервис. В наш микросервис продолжат приходить запросы от клиентов и мы не будет отправлять сразу все, а небольшую пачку. Пусть 10-20 запросов. И дальше снова оценивать успешность выполнения(интересно, как оценивается успешность выполнения?). Если процент успеха переволил за заданное значение, значит, можем считать, что микросервис восстановился и мы можем пускать в него весь трафик и переходить в CLOSED состояние. Если же процент ошибок все еще велик, то переходим снова в OPEN состояние и ожидаем заданное количество времени, чтобы дать микросервису восстановиться.

### Реализация Circuit Breaker
Мы реализуем Circuit Breaker Pattern в Gateway микросервисе и в accounts микросервисе. Причем мы сделаем это по-разному и покажем 2 способа реализации CircuitBreaker паттерна.

Зависимость. Причем стоит заметить, что т.к. Gateway у нас реактивный, то и зависимость, которую мы подключаем для реализации Circuit Breaker также должна быть реактивной:
![[Pasted image 20241205175630.png]]

### Circuit Breaker in Gateway
Добавляем фильтр circuit breaker. Причем важно, что мы можем создавать несколько circuit breaker-ов под разные пути. Например, на скрине ниже мы создали circuit breaker для пути /eazybank/accounts. Т.е. только для таких запросов в Gateway будет происходить отслеживание. И так мы можем сделать и для других путей, причем мы задаем имя для circuit breakera, чтобы в application.yml, где мы задаем конфигурацию для circuit breaker мы могли писать различную в зависимости от имени.
![[Pasted image 20241205180924.png]]
В application.yml:
![[Pasted image 20241205181552.png]]

Если обратимся к spring actuator нашего gatewat сервера и перед этим выполним запрос, то потом получим вот такую информацию по нашему circuit breaker-у. Видим, что он находится в состоянии CLOSED.Тут же мы видим всю статистику, которую собираем наш circuit breaker:
![[Pasted image 20241205181909.png]]

Сделаем имитацию того, что наш микросервис не отвечает - поставим точку останова. И тогда увидим, что circut breaker при запросах в этот микросервис спустя какое-то время будет возвращать такое response:
![[Pasted image 20241205182308.png]]
Причем Response выше - это когда Circuit Breaker находится в состоянии CLOSED, т.е. он все еще отправляет запросы в микросервис, но по истечению timeout-а, если ответа на пришло, то возвращает 504 ошибку и как раз говорит, что Timeout.

Но если мы продолжим делать запросы и они будут фейлиться, то когда circuit breker перейдет в состояние OPEN, то статус уже будет 503.
![[Pasted image 20241205182622.png]]
Если обратимся к статистике по circuiterBreaker, то увидим, что failureRate - 70% и он выше, чем failureRateThreshold, поэтому и состояние теперь OPEN!
![[Pasted image 20241205182725.png]]

Мы также можем смортеть какие эвенты происходит внутри конкретного circuitbreaker(в url указываем параметр name=имя circuit breakera)
![[Pasted image 20241205182901.png]]
Видим, что если ответа не произошло за 1 секунду, то он инициирует ошибку.
Чего мы добились? Теперь gateway вместо того, чтобы тратить ресурсы на запросы в accounts микросервису, который не отвечает, сразу отвечает пользователю о недоступности сервера и экономит свои ресурсы, а также дает возможность accounts микросервису очнуться. 

### Все работает, но теперь мы хотим написать fallback механизм и отправить клиенту какое-нибудь сообщение об ошибке, которое хотим мы, а не которого отправляется по дефолту
Для этого мы определяем fallbackUri - т.е. куда перенаправить запрос в случае ошибки:
![[Pasted image 20241205184553.png]]
Пишем Controller внутри Gateway проекта, который как раз обработает fail запрос по этому URI:
![[Pasted image 20241205184650.png]]
Теперь в случае ошибки(именно связанной с circuit breaker, т.е. когда мы находимся в состоянии CLOSED или HALF_OPEN и микросервис не ответил в заданный период времени, то мы обе эти ошибки будем отправлять в тот метод контроллера, который написали выше) мы будем получать response как на скрине ниже. И вот в controllere, что написан выше мы могли бы сами определять то, что захотим. Например, возвращать ResponseEntity, вместо String и иметь полный доступ к тому, что записать в response
![[Pasted image 20241205184733.png]]
Все шаги, выполненные для реализации:
![[Pasted image 20241205184506.png]]

### Реализуем Circuit Breaker в accounts микросервисе. Это вариант, когда мы используем FeignClient для общения
Это нужно, поскольку accounts microservice общается с помощью feign client с loans и cards микросервисами. И если с каким-то из них произойдут проблемы, то мы не хотим проставить кучу времени в accounts микросервисе, ожидая их ответа. При этом мы хотим вернуть хотя бы часть output-a. Т.е. если оставить Circuit Breaker только на уровне Gateway, то он ничего не узнает о том, почему account не смог выполнить запрос и вообще не вернет никакую информацию. А если мы реализовали Circuit Breaker на уровне accounts, то, например, cards микросервис ответил, мы собрали его данные, а loans - не ответил и сработал circuit breaker, в котором мы можем рассказать, что loans не ответил, но часть данных получится передать. 

Добавляем зависимость в accounts микросервис. Причем не reactor вариант, какой был в Gateway, поскольку мы не используем реактивное программирование.
![[Pasted image 20241206114405.png]]
Включаем circuit breaker
![[Pasted image 20241206114624.png]]
Также добавляем настройки для circuit breaker:
![[Pasted image 20241206114823.png]]
Теперь мы хотим определить логику fallback механизма. 
Для этого мы реализуем тот интерфейс, который мы создали для FeignClient для общения с Loans. И дальше переопределяем его метод и этот и будет fallback механизмом. В нем мы можем написать любую бизнес логику. Мы решили, что будет возвращать null, но можно было выбросить какое-нибудь кастомное исключение и обработать его в Controllere.
![[Pasted image 20241206120210.png]]
Также мы должны указать класс, который будет заниматься fallback механизмом:
![[Pasted image 20241206120343.png]]
И теперь проверяем на null результаты вызовов других микросервисов, поскольку мы теперь можем вернуть null из-за логики fallback механизма circuit breaker.
![[Pasted image 20241206120428.png]]
После того, как сделаем запрос, то увидим, что создается 2 CircuitBreaker-а. Один для общения с Cards, другой для Loans. Причем они связанны именно с методом! В конце названия мы видим StringString - это параметры метода. Т.е. если мы напишем еще методы в FeignClient, то для них также будут созданы Circuit Breaker, которые будут следить за успешностью выполнения метода.
![[Pasted image 20241206120716.png]]

Если мы намеренно выключим два микросервиса, то в outpute будет null, но при этом все равно часть информации возвращается! Т.е. если бы у нас был какой-нибудь сервис рекомендаций и он перестал работать, то все приложение бы не упало, а просто информация по рекомендациям не показывались бы, но при этом остальном функционал приложения работал бы! И это хорошо для клиента, т.к. он все еще может пользоваться большей частью функционала. 
![[Pasted image 20241206121231.png]]
Шаги:
![[Pasted image 20241206121522.png]]![[Pasted image 20241206121602.png]]
