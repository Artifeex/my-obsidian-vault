Почему бы не использовать Basic Authentication? 
Минусы:
1. Бизнес логика тесно связана с логикой аутентификации и авторизации. Также этот подход не особо дружит с mobile или REST API, т.к. использует HTML формы.
2. Также не подходит в том случае, если мы хотим в нашем сервисе иметь доступ к каким-то данные пользователи из другого источника - например, google. 

### Какие проблемы решает OAuth 2?
1. Ouath2 использует отдельный сервер для аутентификации и авторизации. Т.е. это отдельный компонент, который занимается только предоставлением функций безопасности. 
![[Pasted image 20241209153010.png]]
2. С помощью oauth2 мы можем выдавать для сайтов информацию, необходимую для регистрации или доступ к каким-то привилегиям без ввода наших настоящих данных того сайта, к информации с которого мы хотим дать доступ. Например, мы хотим залогиниться на stack over flow. Там есть возможность залогиниться через gitHub. Нажав, нам перебрасывает на сайт github! Там мы вводим наши данные(и заметим, что мы вводим эти данные на github сайте, а не на каком-то левом сайт сливаем наши данные с github). И дальше, используя ouath2 github возвращает stackoverflow accessToken, который имеет очень ограниченные привилегии. С помощью этого токена stackOverflow может обратиться к github и получить информацию или выполнить действие в соотвествие с теми привилегиями, который разрешены по этому токену. Например, stackOverflow может получить информацию об имени пользователя, его почте, но больше никаких действий выполнить нельзя. 

### OAuth2
С помощью OAuth2 приложение сможем дать какие-то права доступа внешнему приложению.
![[Pasted image 20241209154628.png]]
Основные термины OAuth2
![[Pasted image 20241209155228.png]]
Если рассматривать пример с авторизацией на StackOverflow через GitHub:
1. Resource owner - это я, пользователь, который хочет предоставить доступ к моим ресурсам, находящимся на GitHub.
2. Client - это клиентское приложение, которое хочет получить доступ к моим ресурсам - это StackOverflow, который хочет получить доступ к ресурсам, хранящимся на GitHub(имя пользователя, почта).
3. Authorization Server - сервер, который знает о Resource Owner, т.е. у Resource Owner должен быть аккаунт на Authorization Servere, чтобы этот Authorization Server знал, кто к нему пытается обратиться. В нашем примере это GitHub. Он выдает accessToken с которым можно обратиться к ResourceServer и получить разрешенные ресурсы.
4. Resource Server - сервер, на котором хранятся ресурсы. Это GitHub, который хранит имя пользователя и почту(а также другие ресурсы, связанные со мной - Resource Owner-ом.).
5. Scopes - на скопы разделяются пермишены, которые выдает Authorization Server. GitHub сервер выдает accessToken, внутри которого содержится информация о том, какие действия разрешены делать на Resource Servere. Этот токен использует StakOverflow, чтобы обратиться к Resource Server и получить необходимую информацию, а Resource Server на основе токена понимает, можно ли выдавать ему информацию или нет.

Вот тут мы видим, когда авторизуемся, что за доступ мы предоставим для StackOverFlow.
![[Pasted image 20241209160103.png]]

### Что такое OpenID и как он связан с OAuth2
OAuth2 занимается авторизацией! Т.к. он выдает token, с помощью которого определяются действия, которые разрешены выполнять с ресурсами resource owner-a какому-то внешнему приложению. Но, т.к. OAuth2 стал очень популярным, то многие компании используют его и для целей аутентификации.
![[Pasted image 20241209161441.png]]
OpenId - это протокол поверх OAuth2, который предлагает стандарт предоставления user details информации для аутентификации с помощью дополнительного токена, внутри которого будет содержаться необходимая информация. Т.е. до OpenID, если мы хотели использовать OAuth2 для аутентификации, то нам нужно было знать, какие данные может нам предоставить приложение и правильным образом попросить эти данные. А потом обратиться к Resource Server этого приложения и по accessToken-у получить необходимые данные для аутентификации пользоватля на нашем сайте. А с помощью OpenID появился token, внутри которого стандартным образом располагается необходимая для аутентификации информация.

![[Pasted image 20241209162002.png]]

### Keycloak
OAuth2 и OpenID говорят только о спецификации, как это все можно сделать, но не предлагают реализации. И можно как написать свой Authorization сервер с нуля, так и использовать готовые решения, которые реализуют спецификации OAuth2 и OpenID.
Одним из таких продуктов является Keycloak. Для небольших организаций, которые не хотят создавать с нуля свой Authorization сервер это будет неплохим решением.

### Как работает OAuth2 под капотом
![[Pasted image 20241209163425.png]]
![[Pasted image 20241209164509.png]]
client_id и client_secret выдаются для приложения в момент его регистрации админами keycloak. Т.е. если какое-то приложение хочет использовать наши внутренние приложения, то сначала нужно, чтобы админы keycloak выдали этоу приложению cliend_id и client_secret. С помощью них, когда в keycloak будет приходить запрос от какое-то приложения, то произойдет аутентификация этого приложения благодаря которой станут известны доступные для приложения действия(scope). Этот scope также настраивается админами keycloak при регистрации. 
grant type flow используется только тогда, когда два приложения пытаюся коммуницировать друг с другом без resource ownera и UI, где resource owner мог бы внести свои credentials.

Схема работы:
![[Pasted image 20241209165303.png]]
Есть внешний клиент приложение(мы сейчас рассматриваем именно такой вариант, когда нет Resource Ownera)(этот внешний клиент сначала должен быть зарегистрирован админами Keycloak. Т.е. не каждый рандомный клиент может получить доступ к нашему приложению). После того, как внешнее приложение обратилось в keycloak и передало о себе информацию. Keycloak по этой переданной информации определил клиента и его права, которые он имеет, которые были заранее выданы админами для этого клиента. После чего такое приложению выдается accessToken, с которым он идет в ResourceServer, которым выступает Gateway. Gateway проверяет токен, спросив у Keycloak, выдавал ли ты такой токен? Если все хорошо, то Gateway посылает запрос на выполнение в соответствующий микросервис и выполняется запрос. 

Может возникнуть вопрос, а не может ли клиент напрямую обратиться к микросервисам в обход gateway? Нет, не может, поскольку микросервисы задеплоины внутри защищенной сети(kubernetes или docker-compose), внутрь которой нельзя напрямую делать запросы. В эту сеть можно попасть только через gateway server, который находится на входе в эту сеть и может общаться с микросервисами внутри нее, т.к. сам является частью этой сети, но при этом имеет еще и открытый API, к которому могут обращаться клиенты, находящиеся снаружи.

### Реализация
````bash
docker run -p 7080:8080 -e KC_BOOTSTRAP_ADMIN_USERNAME=admin -e KC_BOOTSTRAP_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak:26.0.7 start-dev
````

Мы можем создавать Realms для наших пользователей и клиентов. Они нужны для объединение группы клиентских и пользовательских приложений. Можно об этом думать как об environment. Мы не хотим, чтобы у QA realm(пользователей) был доступ к production realm. Потому что иначе QA смогут на production творить то же самое, что и при тестировании.
![[Pasted image 20241209172121.png]]

Представим, что к нам - администратору Keycloak пришел тим лид другого приложения и сказал, что хочет написать интеграцию своего приложения с нашим.
Пусть это будет приложение кол центра в нашем Eazy Bank, которое хочет иметь доступ к нашим микросервисам.

Поэтому мы должны создать клиента:
![[Pasted image 20241209173612.png]]
![[Pasted image 20241209174136.png]]
![[Pasted image 20241209174156.png]]
Credentials генерируются Keycloak и передаются клиенту.
![[Pasted image 20241209174417.png]]
Эти client id и secret клиентское приложение должно испольовать при обращении в наш keycloak auth сервер для получения access токена.
Мы можем посмотреть endpoints нашего keycloak для получения различный инфы и в том числе endpoint для получения accessToken-а.
![[Pasted image 20241209174730.png]]

Для получения accessTokena мыотправляем post запрос и указываем client_id, grant_type(каким образом будет происходить авторизация как я понял и в нашем случае через client_credentials, которыми являются cliend_id и client_secret). А также мы передаем scope, внутри которого указываем какие возможности хотим получить. И может появиться вопрос, а откуда эти скопы взялись. Дело в том, что keycloak по дефолту создает некоторые скопы для нас, которые мы можем сразу использовать.
![[Pasted image 20241209174848.png]]

Вот scopes нашег оклиента eazybank-callcenter:
![[Pasted image 20241209175446.png]]
Такой ответ получим:
![[Pasted image 20241209175521.png]]
Вот инфа, которая находится внутри id_token. Видим, что это инфа о пользователе. Она во многом повторяет то, что передается в accessToken, но при желании мы можем передать больше информации о клиенте.
![[Pasted image 20241209175916.png]]

### Сделаем из Gateway сервера Resource сервер
Мы хотим, чтобы теперь при обращении к Gateway серверу на нем проверялся переданный токен через Keycloak.

Добавим в Gateway сервер 3 зависимости:
```xml
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-security</artifactId>  
</dependency>  
<dependency>  
    <groupId>org.springframework.security</groupId>  
    <artifactId>spring-security-oauth2-resource-server</artifactId>  
</dependency>  
<dependency>  
    <groupId>org.springframework.security</groupId>  
    <artifactId>spring-security-oauth2-jose</artifactId>  
</dependency>
```
И настраиваем Security. csrf мы выключили, поскольку оно нужно только при общении через браузер, а тут у нас общение одного приложения с другим.
![[Pasted image 20241210093954.png]]

И мы должны должны указать для ResourceServer uri keycloak, по которому можно будет скачать сертификат, с помощью которого мы сможем проверять пришедшие jwt токены.
![[Pasted image 20241210094504.png]]

После этого мы можем получить GET запросы, т.к. в exchanges, который мы настраивали выше проверка доступности происходит сверху вниз и мы там написали, что все get методы permitAll.

Но если мы попытаемся сделать post запрос, то получим 401 ошибку.

Чтобы получить токен мы должны сначала сделать post запрос в keycloak и передать правильные креды, которые мы создавали ранее в админке.
![[Pasted image 20241210095423.png]]
![[Pasted image 20241210095436.png]]
Но в POSTMAn есть удобная фишка для этого
![[Pasted image 20241210095603.png]]
И там в настройках передать то же самое, что мы передали в headere запроса для получения токена.
И после этого мы можем делать любые запросы.
### Авторизация
Вместо .authenticated() теперь пишем hasRole("") и указываем роль, которую должен иметь клиентское приложение, чтобы выполнить тот или иной запрос.
![[Pasted image 20241210100117.png]]

Теперь нам нужно уметь устанавливать такие роли в Keycloak для наших клиентов. Для этого сначала создаем роли:
![[Pasted image 20241210100409.png]]
Назначаем роль:
![[Pasted image 20241210100523.png]]

После этого, если мы получим AccessToken, то информация о роли будем в нем:
![[Pasted image 20241210100811.png]]
Т.е. как все это работает?
В админке я добавил для приложения, которое хочет со мной общаться новую роль. Это приложение обращается по специальному пути(который указан в configuration в Keycloak) для получения access токена. Когда это приложение обращается по этому пути, чтобы понять, что за приложение обратилось в Keycloak, мое приложение передает в headere secret key и client_id, а для grant_type используется client_credentials. После этого keycloak понимает, что за приложение к нему обратилось, смотрит у себя, что за роли оно имеет и т.д. и возвращает acces токен в котором находится информация. Эта информация потом используется Resource сервером, когда к нему приходит запрос. Он может проаналазировать accessToken и например, если мы назначали для какого-то ресурса, что к нему доступ только с определенной ролью, то из токена определить роль клиента и если с такой ролью можно получить ресурс, то клиент получит этот ресурс, а если нет, то 403.

Но получение роли из JWT не делается автоматически. Мы должны сами получить эту роль и потом преобразовать в формат, понятный Spring.
Пишем как раз такой конвертер роли из JWT в GrantedAuthority:
![[Pasted image 20241210101839.png]]

![[Pasted image 20241210102805.png]]

### Ранее мы разбирали вариант, когда с нашим backend сервисом общается другое клиентское приложение, а не конечный пользователь
Теперь посмотрим как все работает, когда к нам обращается пользователь.
![[Pasted image 20241210110502.png]]
![[Pasted image 20241210110615.png]]https://www.oauth.com/playground/client-registration.html - сайт, на котором можно поиграться с различными видами grant_type и как они работают.

Такая схема будет 
![[Pasted image 20241210112350.png]]
