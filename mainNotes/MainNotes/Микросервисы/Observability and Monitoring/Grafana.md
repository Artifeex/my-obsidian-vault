Grafana - это компания, которая создает различные интрументы для мониторинга различных программ. Это не только микросервисы, но и игры и многое другое. 
![[Pasted image 20241209093737.png]]

Grafana - тула для визуализации различной информации. Она интегрируется с различными источниками данных.
Grafana Loki - это централизованное хранилище логов. Также оно горизонтально масштрабируемое, т.е. если у нас генерируется много логов, то мы можем увеличить количество этих централизованных хранилищ
Promtail - это лог агент. Он должен быть запущен, чтобы собирать логи со всех наших микросервисов, а потом отправлять в Grafana Loki.
![[Pasted image 20241209094036.png]]
![[Pasted image 20241209094259.png]]
Начиная с Grafana Loki 3.0 Promtail был заменен на Alloy. 

### Внутренности Grafana Loki
flog - какое-то приложение, которое генерирует логи. Это наш микросервис. Он сгенерировал логи и alloy - считывает эти логи и отправляет в gateway, который посмотрит на url и поймет, что запрос нужно перенаправить в компонент, который занимается сохранением логов. После чего логи сохранятся в MiniO. Дальше мы захотели посмотреть логи за какое-то промежуток с какого-то нужного нам микросервиса. Для этого мы используем grafana(UI), которая также обращается к nginx, который уже перенаправляет запрос в компонент, который занимается чтением данных из MiniO. И так информация в красивом виде отрисовывается нам в Grafana.
![[Pasted image 20241209095326.png]]

Мы использовали grafana quickstart и подняли все эти составляющие у себя локально. Но для локальной разработки нам это не нужно, поскольку мы и так имеем доступ к логам, а также есть возможность дебага благодаря initeliji. Все эти штуки нужны для production или test environment, где также могут происходить баги. И чтобы выяснить в чем проблема, нам нужно использовать логи.

![[Pasted image 20241209105525.png]]
Сами логи идут чуть ниже:
![[Pasted image 20241209105541.png]]
### Сбор метрик
Мы научились собирать логи, но они нужны для того, чтобы понять, что происходит внутри системы. Но этого недостаточно. Мы хотим отслеживать метрики - числовые характеристики нашей системы. CPU usage, memory и т.д. 

Для получения этих метрик из нашего приложения используется Spring Actuator, который предоставляет различные метрики с помощью различных эндпоинтов. 
Но он возвращает эти метрики в виде Json. 
Prometheus - это аналогия для Loki, но только для метрик. Т.е. он собирает метрики со всех микросервисов в одном месте и может экспортировать их, отрисовывать, т.е. предоставлять мониторинг. Т.е. Prometheus - это как Grafana + Grafana Loki, только для метрик. Но мы также можем дополнительно добавлять и Grafana, которая будет использовать данные из Prometheus. Зачем это нужно? Потому что Grafana более крутой тул, который дает возможность создавать более сложные dashboards.

Но помимо Prometheus есть и другие агрегаторы и они все могут работать с разными форматами передачи метрик(не JSON, а, например, XML). Поэтому нам нужен дополнительный компонент - Micrometer, который будет преобразовывать метрики из того формата, что нам выдает наш микросервис в тот формат, который понятен Prometheus или другой агрегирующий системе сбора метрик.

![[Pasted image 20241209111826.png]]

Можем в поиске указывать различные метрики и получать такие графы, в которых указана информация по выбранной метрике для всех микросервисов.
![[Pasted image 20241209113608.png]]

Также мы можем следить за тем в каком состоянии находятся наши контейнеры.
![[Pasted image 20241209113708.png]]
Если мы рукуми остановим контейнер, то увидим, что в Prometheus он отобразится как unhealthy.
![[Pasted image 20241209113819.png]]

### Интегрирование Grafana и Prometheus
В Grafana мы можем законнектиться к Prometheus и получать из него метрики для отрисовки.
![[Pasted image 20241209114222.png]]

Команда Grafana(а также open-source community) создала множество графиков, которые мы можем использовать и которые нужно всего-то подключить к нашему проекту(это делается в пару кликов). И вот мы можем получить такой красивый dashboard:
![[Pasted image 20241209114644.png]]

### Alerts and notifications
Можно настраивать алерты, например, на то, чтобы если микросервис перешел из состояния UP в состояние DOWN(т.е. остановился), то к нам начали приходить уведомления об этом. Уведомления могут приходить в множество различных источников - discord, email, slack.
### Distributed tracing in microservices
Мы научились отслеживать внутренее состояния наших микросервисов. Но теперь мы также хотим оценить перформанс нашей системы, возможно, найти узкое горлышко, которое тормозит наши микросервисы.

Как реализовать?
1. Использовать correlation ID. Мы делали что-то подобное, когда изучали gateway. На входе мы генерировали уникальный correlationID, клали его в header и дальше в других микросервисах получали этот correlationID и логировали. И так мы по логам можем отследить весь путь нашего запроса по нашей системе. Но это глупый подход, поскольку микросервисов может быть сотни и придется смотреть логи каждого микросервиса(даже если мы будем использовать Grafana Loki и иметь одно хранилище всех логов - это будет довольно долго).

Распределенный tracing используем 3 основных концепции:
1. Tags - содержит различную метинформацию. Это может быть user details и тогда мы можем посмотреть логи по конкретному пользователю, если с каким-то конкретным пользователем произошла ошибка. Или можем добавить названия микросервиса и тогда сгруппировать логи чисто по этому тегу - названию микросервиса.
2. TraceId - уникальный id запроса. Аналог correlationId.
3. SpanId - уникальный id микросервиса.
![[Pasted image 20241209142549.png]]
![[Pasted image 20241209142943.png]]
### OpenTelemetry - одна из библиотек, которая поможет реализовать распределенный tracing
![[Pasted image 20241209144642.png]]
Используя интеграцию Grafana с OpenTelemetry мы можем по сгенерированному traceid отследить, как запрос проходил через наши микросервисы(только мы должны не забывать логировать вызовы). Причем особенностью является то, что нам не надо никак дополнительно логировать, за нас автоматически генерируются и traceID и SpanId
![[Pasted image 20241209145619.png]]

Пример логов, сгенерированных OpenTelemetry:
![[Pasted image 20241209145814.png]]
Для логов мы можем написать вот такой паттерн и trace_id и span_id вставит и сгененирует для нас open telemetry.
![[Pasted image 20241209145920.png]]
![[Pasted image 20241209150543.png]]
