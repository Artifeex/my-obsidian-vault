### Монолит Vs Микросервисы
#### Монолит
Монолит - это приложение, в котором вся функциональность представлена одним приложением и это приложение развернуто полностью на 1 сервере. Т.е. весь наш функционал приложение находится внутри одного единственного приложения.
Также у нас 1 БД на все монолитное приложение. Т.е. разные сервисы также пишут в одну БД.

Плюсы:
- Проще разрабатывать и деплоить для маленьких команд и приложений. Т.е. если у нас какое-то небольшое приложение, то монолитом написать его проще, к тому же задеплоить также проще, поскольку задеплоить нужно всего 1 приложение, а не множество - как это было бы в микросервисах.
- Меньше cross-cutting concerns. Вся функциональность, которая НЕ относится к бизнес логике - проще! Security, auditing, logging - это все проще, поскольку все наше приложение находится на одном сервере.
- Лучшая производительность благодаря отсутствию задержек сети, по которой общаются микросервисы. В монолите для вызова какой-то другой функциональности нам нужно просто вызвать метод, а не выполнять какое-то общение по сети.
Минусы:
- Сложнее внедрять новые технологии или языки в наш проект. Если я в монолите хочу добавить новую технологию я должен либо обновить всю существующую кодовую базу для этого или остаться на старой технологии. Или если захочу перейти на последнюю версию frameworka, то мне нужно другую команду пушить, чтобы они также обновили их версию. Из-за этих причин в монолите ограниченная подвижность модулей, которые мы используем.
- Единая кодовая база, которая очень связана между собой. Какие-либо изменения в существующем коде могут повлиять на другой функционал. Из-за чего появляется проблема регрессии(когда мы что-то поменяли и это поломало уже существующий функционал, который работал ранее) и нужно дополнительно тестировать код.
- Слабая отказоустойчивость. Падение монолита = полный отказ нашей системы.
- Любое маленькое обновление и фича требуют полного деплоя всего нашего приложения.
Также есть разные варианты монолитов - но все они подвержены недостаткам, которые мы описали.
![[Pasted image 20241126170859.png]]
![[Pasted image 20241126171631.png]]
Все команды работают с одной кодовой базовой и это неудобно при ведении параллельной разработки.

#### SOA
Было предложено улучшение - SOA. В которой мы отделяем frontend и backend и создаем промежуточную шину, которая будет доставлять запросы с frontend в нужный сервис. Теперь сервисы могут разрабатываться независимо, но есть минус. Шина из воздуха не берется. Ее нужно также создавать и поддерживать. Причем open source решений нет, что требует каких-то доп затрат. Также само общение происходит не обычным HTTP, а каким-нибудь SOAP, который является сложным.
![[Pasted image 20241126171736.png]]

Благодаря этому подходу у нас есть возможность параллельно разрабывать UI и Backend слои.
![[Pasted image 20241126172101.png]]

#### Microservices
Микросервисы - небольшие самостоятельные приложения, которые мы создаем под какую-то бизнес логику. Например, микросервис для работы с карточками. Вся его работа направлена на удовлетворения этой бизнес логики. Другой микросервис может заниматься кредитами и он полностью направлен на выполнение этой бизнес логики. Причем каждый микросервис может быть задеплоен на разных серверах или контейнерах.
Плюсы:
- Проще разрабывать сам микросервис(если не задумываться об общении), тестировать, деплоить, т.к. он намного меньше монолита и направлен на решение какой-то одной проблемы.
- Каждая команда работает со своим микросервисом, может использовать те технологии, которые захочет, главное соблюдать контракт с другими командами по общению с нашим микросервисом. Также т.к. микросервисы зачастую имеют каждый свою БД, то некоторые могут использовать SQL БД, а некоторые NoSQL, что также является плюсом
- Разделение на команды по микросервисам упрощает параллельную разработку из-за меньшей связности микросервисов. 
- Более удобное горизонтальное масштабирование. Если какой-то из микросервисом имеет повышенную нагрузку, то мы можем увеличить количество инстансов этого микросервиса, а не всего приложения, как это было бы в монолите. 
Минусы:
- Сложность. Когда у нас множество отдельные приложений, которые развернуты на разных серверах и должны правильно общаться между собой - это достаточно сложная задача для выполнения
- Повышенные расходы на инфраструктуру. Когда у нас монолит, то у нас нет столько инфраструктуры вокруг него. Есть несколько копий и балансировщик. В микросервисах же у нас множество контейнеров, серверов, на которых они крутятся и за всем этим надо следить.
- Security Concerns - проблемы безопасности. В монолите у нас просто вызывались методы и никаких проблем с безопаснотью не было. В микросервисах же нам нужно обеспечивать безопасное взаимодейтвие между ними, чтобы какие-то данные, которые мы передавали в процессе общение микросервисов по сети не утекли в сеть.
![[Pasted image 20241126173737.png]]
![[Pasted image 20241126174046.png]]

![[Pasted image 20241126175029.png]]

Прикольное определение микросервиса:
![[Pasted image 20241126174959.png]]

### Почему Spring Boot - это круто?
![[Pasted image 20241126181407.png]]

### Реализация аудирования
Для аудита времени создания исползьуется аннотация CreatedDate и @LastModifiedDate, которые мы вешаем в Entity.
А вот для того, чтобы аудировать, кто создал сущность или изменил нужно сделать чуть больше:
Добавляем в Entity следующие аннотации:
![[Pasted image 20241128165106.png]]
Создаем @Component, который реализует интерфейс AuditorAware, а в качестве параметра передаем тип для аудирования. String - потому что createdBY и updatedBy - String. Пока что мы просто захардкодили значение, но когда подключим Spring Security, то будем динамически записывать туда значение, полученное от авторизованного пользователя.
```java
@Component("auditAwareImpl")  
public class AuditAwareImpl implements AuditorAware<String> {  
  
    @Override  
    public Optional<String> getCurrentAuditor() {  
        return Optional.of("ACCOUNTS_MS");  
    }  
}
```
И включаем возможность аудирования:
![[Pasted image 20241128165214.png]]

### Документация наших микросервисов
Для этого нужно всего-то подключить зависимость openapi:
https://springdoc.org/#getting-started
После чего будет доступен swagger-ui! А также документация openapi. 
![[Pasted image 20241128175648.png]]
Вот, что получим:
![[Pasted image 20241128175710.png]]

#### Описание метода контроллера
![[Pasted image 20241128175912.png]]
![[Pasted image 20241128175948.png]]

#### Замена статус кода
![[Pasted image 20241128180405.png]]
![[Pasted image 20241128180512.png]]
При желании остальные описания можешь сам посмотреть, нет смысла конспектить то, что можно загуглить.

### Как определить какого размера делать микросервис и за какую часть бизнес логики он должен отвечать?
Есть два основных подхода:
### Domain-Driven-Sizing
Если большинство модификаций и улучшений нашего приложения обусловлены нуждами бизнеса, мы можем определить границы наших микросервисов выровненные по Domain-Driven design(то есть дизайн нашего приложения происходит в соотвествии с областями бизнеса. Например, в банковском приложении, которое мы пишем Accounts, Loans, Cards - это домейны(области бизнеса)). Но это не так просто, поскольку нужно иметь опыт и хорошие знания в области бизнеса.

Причем часто с первого раза не получится разделить все идеально. После написания приложения может получиться, что слишком много накладных расходов на общение микросервисов - тогда, возможно, стоит объединить несколько в один побольше, чтобы уменьшить это общение по сети. 

Основным минусом является то, что нужно реально хорошо разбираться в domain областях бизнеса, а если он огромный, то очень много времени нужно потратить на коммуникацию с другими командами, узнать, что делают их сервисы и потом обговорить со всеми, как выстроить архитектуру.

Есть еще один подход
### Event Storming Sizing
Собирается митинг среди множества заинтересованных сторон, кто тестирует и разрабатывает приложение. Дальше они накидывают эвенты, которые происходят в их приложении, commands - что должен сделать клиент, чтобы этот эвент вызвался и reaction - что должно произойти после возникновения эвента. Например, пользователь нажал кнопку оплатить - command, создался эвент с желанием выполнить оплату и потом происходит оплата. После этого, когда такие штуки написаны, то мы пытаемся их сгруппировать по группам. И каждая отдельная группа - это микросервис.
https://www.lucidchart.com/blog/ddd-event-storming
### Strangler Fig pattern
Паттерн, которым пользуются люди для того, чтобы от монолита перейти к микросервисам. Причем он полезен когда у нас большой и сложный монолит. Название получил от дерева, которое начинает расти вокруг исходного дерева и со временем полностью заменяет исходное дерево.
Паттерн делает также. Мы потихоньку заменяем по кусочкам наш монолит и переходим к новой системе шаг за шагом, причем на каждом шаге должно оставаться рабочее приложение, т.е. нет такого, что мы просто берем и пишем систему с нуля(для большей системы это может занять очень много времени). Вместо этого мы пытаемся по максимуму использовать готовый код и процессы, которые в нем были, но уже в новой системе. Т.е. интегрируем и заменяем кусочки старой системы на новые кусочки, чтобы они продолжали контактировать со старым кодом.

Защищает от Big Bang миграции, когда мы с нуля переписываем все приложение.

А как происходит постепенная замена? На самом деле у нас продолжает существовать монолит и мы рядом пишем микросервис, который, например, занимается карточками. И просто потихоньку начинаем направлять в этот микросервис трафик, т.е. частично он идет в монолит, а частично в новый микросервис и так мы можем проверить, что все работает корректно и продолжать переписывать приложение. 

### Deployment, Portability(переносимость), Scalability of microservice
Deployment - как мы задеплоим 10-ки или сотни микросервисов? В монолите у нас было всего одно приложение.
Portability - как мы перенесем наши сотни микросервисов между различными environments? Во время разработки нам нужно уметь переносить наше приложение в dev среду, в среду для тестеров, в копию production и в конце концов в сам production.
Scalability - мы хотим уметь увеличивать кол-во микросервисов, которые будут находиться под повышенной нагрузкой на лету, а не руками.

Для решение всех этих трудностей мы будем пользоваться контейнеризацией наших приложений. Благодаря этому мы сможем настраивать environment каждого приложений и запускать его в соотвествие с этим environemt-ом.

Офигенная аналогия контейнеров и переноса их - это корабль с контейнерами.
![[Pasted image 20241129113318.png]]
Каждый контейнер изолирован и может содержать какие-то требования. Например, если контейнер перевозит продукты, то он может содержать внутри себя холодильник, а какому-то другому контейнеру этот холодильник не нужен. И так мы можем настраивать каждый контейнер по отдельности.

Но почему бы не использовать просто множество виртуальных машин? Виртаульная машина - это машина, которую мы приобрели, например, на Amazon Web Services. И дальше подключаемся к ней и можем ее настраивать. Но проблема такого подхода в том, что во-первых, выделять целую машину под один микросервис - это плохое решение, т.к. если микросервис маленький, то он не будет потреблять много мощностей, а платить мы будем как за полноценную машину. К тому же, такую машину нужно настраивать, т.е .устанавливать в нее все зависимости, библиотеки, поднимать там сервер, деплоить на этот сервер. Плюс появляется проблема, что если нагрузка выросла и мы хотим увеличить кол-во копий какого-то микросервиса, то нам нужно поднимать целую виртуальную машину, снова ставить на нее все библиотеки и деплоить. А это долго. Нагрузка может увеличиться на 30 минут из которых мы вручюун 15 минут все настраивали... А потом она уменьшилась и теперь снова нужно вырубать машины. Docker контейне же - это уже готовое приложение, готовое к работе. Нам не нужно будет руками каждый раз устанавливать библиотеки и зависимости. Все необходимое будет в докер контейнере!
![[Pasted image 20241129114627.png]]
Еще плюс контейнеров в том, что поднять его или удалить или перезапустить - это достаточно быстро. Сделать аналогичное действие с вирутальной машиной - сильно дольше.
Еще плюс контейнеров, что они изолированные и их зависимости также изолированы. Т.е. один контейнер и приложение внутри могут требовать 17 джаву, другой 11 и т.д. И все это будет без проблем работать. А если бы мы поставили на одну виртульаную машину сразу несколько микросервисов, которые также требовали бы разные версии той же джавы, то это уже было бы проблематично.

В общем, основное различие контейнеров и VM в том, что контейнерам не требуется операционная система внутри самого контейнера. Для запуска нужен Container Engine. А для виртуальной машины же нужна Guest OS.

При виртуализации операционных систем происходит по сути виртуализация hardware уровня, т.е. каждая операционная система думает, что все железо принадлежит ей. А в случае docker container-ов виртуализация происходит на уровне операционной системы. Все контейнеры разделяют одну ядро операционной системы, на которой они запущены.

### [[Что такое docker container]]
Docker - это по сути платформа, которая реализует возможность контейнеризация наших приложений. Грубо говоря, тула, чтобы мы могли реализовать концепции контейнеризации. 

### За счет чего происходит разделение ресурсов в docker?
Это благодаря Linux и его фишкам:
- namespaces - позволяют создать изолированные environments внутри операционной системы. Каждый контейнер имеет свой собственный namespace, включающий процесс, network, mount(ну диски, хранилища). namespace обеспечивает, что процесс, работающий внутри него может взаимодействовать только с ресурсами своего namespac-а.
- cgroups - control groups. С помощью namespace мы изолировали контейнеры, но нам еще нужен управляющий, который будет следить за тем, как контейнеры используют ресурсы. cgroups - адиминистраторы, который следят и ограничивают контейнеры в потреблении ресурсов(CPU, память, disk IO). Т.е. они нужны, чтобы какой-то контейнер не мог взять все ресурсы системы себе, например, CPU или оператива.

Но если это фишка linux, как оно работает на windows или mac? Когда мы устаналиваем докер, то ставится Docker Client, а также, если мы находимся на Windows или Mac, то ставится легковесная виртуальная машина с linux, куда уже ставится docker server(engine).

### [[Docker Components]]

### [[3 способа сгенерировать Docker Image]]

Чтобы запушить созданные контейнеры в dockerhub:
`docker image push docker.io/artifeexs/accounts:s4`

Docker compose нужен, чтобы запускать сразу множество микросервисов одной командой. 
![[Pasted image 20241129174639.png]]
Если мы хотим, чтобы контейнеры могли общаться, значит, нужно, чтобы они использовали общую сеть(по умолчанию у каждого своя). Поэтому нужно добавить еще одну настройку в docker-compose.yml:
![[Pasted image 20241129174836.png]]
Создаем саму сеть. bridge говорит о том, чтобы создался бридж, благодаря которому микросервисы смогут общаться.
![[Pasted image 20241129175021.png]]

### Основные Docker команды
![[Pasted image 20241129175704.png]]
![[Pasted image 20241129175829.png]]

С помощью Logs Explorer можно удобно смотреть логи по всем контейнерам
![[Pasted image 20241129180236.png]]

### Cloud native applications
Cloud native applications - это приложения, которые построены для их использования в различных environments - таких как public, private, hybrid облаках. Это позволяет строить слабосвязные системы(что позволяет более просто их тестировать и подменять, просто перенаправляя запросы), устойчивые(если что-то упало, то мы можем снова это поднять), расширяемые.

### Характеристики Cloud Native приложений
Характеристики cloud native applications. Если какое-то приложение им следует, то мы можем говорить с какой-то степенью уверенности, что это приложение является cloud native приложением.
![[Pasted image 20241202111344.png]]

### Различия Cloud и Traditional applications
![[Pasted image 20241202111738.png]]
- Predictable Behaviour - когда у нас монолит, то выяснить, где именно произошла ошибка довольно трудно. Нужно дебажить по-сути все приложение целиком. В случае же микросервисов благодаря логам мы можем понять в каком микросервисе произошла ошибка и судить поиск до микросервиса.
- OS abstraction - связано с тем, что в cloud приложениях используется docker. 
- Right-sized - т.к. микросервисы и не такая большая кодовая база. Также т.к. микросервисы, то меньше связности.
- Rapid recovery - связано с использованием Kubernetes и docker.

Но, чтобы получить все эти плюсы от использования cloud нам нужно следовать принципам:
[[12 Factors]]

### [[Configuration management]]

### [[Перейдем на MySQL БД в наших микросервисах]]

Правда после этого, чтобы не поднимать для каждого микросервиса по БД в докере для запуска приложения мы снова перешли на H2, чтобы хватило оперативки. 

### [[Service Discovery]]

### [[Gateway]]

### [[Microservice Resilience]]

### [[Observability And Monitoring]]

### [[Security in Microservices]]

### [[Event Driven microservices]]