Да, вы совершенно правы. Давайте уточним детали:

### По умолчанию

По умолчанию Spring Boot использует **один и тот же контекст** (`ApplicationContext`) для всех тестов в рамках одного набора (JUnit Test Suite). Это помогает значительно ускорить тестирование, так как загрузка контекста — это дорогостоящая операция.

Если тест изменяет состояние бина в этом общем контексте, то эти изменения будут видны другим тестам, которые используют тот же контекст. Это потенциально может привести к нестабильности тестов.

---

### Когда используется `@DirtiesContext`

Если вы добавляете `@DirtiesContext`:

1. **После теста с этой аннотацией контекст уничтожается и создается заново.**
    - Это гарантирует, что следующий тест или тестовый класс получит "чистый" контекст с начальным состоянием.
2. Если бин в таком тесте был изменен, это изменение больше не повлияет на другие тесты, так как будет создан новый контекст.

---

### Где можно применять `@DirtiesContext`

1. **На уровне метода**: Контекст будет уничтожен после выполнения конкретного тестового метода.
    
    ```java
    @Test
    @DirtiesContext
    public void testWithModifiedBean() {
        // Изменяем состояние бина
    }
    ```
    
2. **На уровне класса**: Контекст будет уничтожен после выполнения всех тестов в данном классе.
    
    ```java
    @DirtiesContext
    @SpringBootTest
    public class TestClass {
        @Test
        public void test1() {
            // Тест 1
        }
        
        @Test
        public void test2() {
            // Тест 2
        }
    }
    ```
    

---

### Как это работает:

- Когда тест с `@DirtiesContext` завершается, Spring помечает текущий `ApplicationContext` как "грязный" и удаляет его из кеша.
- Следующий тест, требующий контекст, инициирует загрузку нового контекста.

---

### Пример

#### Без `@DirtiesContext` (общий контекст):

```java
@Autowired
private SomeService service;

@Test
public void test1() {
    service.setValue("Test1");
    Assertions.assertEquals("Test1", service.getValue());
}

@Test
public void test2() {
    Assertions.assertEquals("Test1", service.getValue()); // состояние сохранено из test1
}
```

#### С `@DirtiesContext` (изолированный контекст):

```java
@Autowired
private SomeService service;

@Test
@DirtiesContext
public void test1() {
    service.setValue("Test1");
    Assertions.assertEquals("Test1", service.getValue());
}

@Test
public void test2() {
    Assertions.assertNull(service.getValue()); // новый контекст, бин в начальном состоянии
}
```

---

### Вывод

Да, если вы используете `@DirtiesContext`, новый контекст будет поднят после выполнения теста или тестового класса с этой аннотацией. Это позволяет изолировать изменения состояния бинов в контексте, но увеличивает время выполнения тестов, так как создание нового контекста — операция ресурсоемкая.