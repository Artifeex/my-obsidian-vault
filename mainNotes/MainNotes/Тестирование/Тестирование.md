Unit тест - это маленький блок кода, который тестирует какую-то одну функциональность.
![[Pasted image 20241125091056.png]]
JUnit предоставляет API для написания тестирования.
Само же тестирование состоит из того, что мы вызываем какой-то код и сравниваем ожидаемое значение с тем, что возвращает метод.

Пример Unit теста. Стандартный Unit тест состоит из 3-х частей.
- Инициализации
- Выполнения действия, которое тестируем
- Сравнение ожидаемого результата и что на самом деле получилось
![[Pasted image 20241125091625.png]]

Unit тесты быстрые, поскольку если они используют какие-то зависимости, например, вызывают HTTP метод, то мы на самом деле не выполняем HTTP метод, а заменяем этот вызов с помощью заранее запрограммированного фейкового объекта - mock, который мы программируем, какой результат он будет возвращать. И мы заменяем все зависимости на моки, поэтому тесты выполняются быстро.
![[Pasted image 20241125092009.png]]

### Зачем писать Unit тесты?
Мы же можем вручную проверить работу нашего приложения.
![[Pasted image 20241125092617.png]]
Наиболее важным как по мне является решение проблемы regression - это ситуация, когда мы написали код(или изменили) и после этого сломалась функциональность, которая раньше работала и была протестирована. 
Unit тесты решают эту проблему тем, что если мы изменили код и он что-то сломал, то мы узнаем это на этапе тестирования, а не в проде...

### F.I.R.S.T. Principle
Набор принципов, которым стараются следовать при написании Unit тестов.
- Fast - юнит тесты маленькие тесты, которые не работают с реальными объектами(например, БД) в отличие от интеграционных тестов.
- Self-validating - unit тест решает прошел тест или нет. Т.е. после того, как мы запустили unit тесты и получили результаты, то нам не нужно делать какого-то дополнительного ручного тестирования, чтобы проверить результаты тестов.
![[Pasted image 20241125093435.png]]

### Проблема изолированности тестов
Когда мы тестируем метод в юнит тесте в идеале, чтобы он был независимым и работал самостоятельно. Но на практике такое бывает редко, часто метод вызывает методы других классов. Но тогда возникает проблема. Рассмотрим пример. Пусть мы теастируем метод  из класса А, который в своей работе использует вызов метода из класса B. Но, что, если в методе, который вызывается в классе B - ошибка? Тогда юнит тест, который мы написали для тестирования метода из класса А не пройдет и мы будем считать, что неверно написан метод в классе А, а на самом деле ошибка была в классе B! 
Поэтому и важна изоляция! Но как мы можем это решить? С помощью mock объектов.
![[Pasted image 20241125093826.png]]

Когда наш класс зависит от каких-то других объктов, то мы можем использовать DI. И вот при DI мы можем вместо того, чтобы вставлять реальные объекты, вставлять Mock объекты, которые мы заранее запрограммируем и тогда методы реальных объектов не будут вызываться! А это значит, что мы добились изолированности, т.к. теперь реально написанный код не вызывается, а, значит, что мы застрахованы от ошибки в чужом коде! 
![[Pasted image 20241125094334.png]]

### Testing Pyramid
![[Pasted image 20241125095231.png]]
Unit tests - больше всего, они тестируют методы в изоляции от других зависимостей, используя fake объекты - mock, spy. Их проще всего писать и выполняются они быстрее всех, т.к. не требуют реального общение с внешними системами или реальной БД.
Integration tests - более сложные тесты. Они уже используют реальные объекты и цель таких тестов проверить как наша система работает уже в реальном взаимодействии с другими системами! Т.е. тут уже происходят реальные HTTP вызовы и реальная работа с БД.
End-To-End тесты - самые сложные и их меньше всего. Они уже тестируют конечную пользовательскую функциональность.

### Что такое JUNIT 5
Это комбинация 3 вещей
![[Pasted image 20241125095539.png]]
- JUnit Platform - платформа, которая управляем фундаментом тестирования на JVM. Т.е. по сути это сердце JUnit. Т.е. это платформа, на которой запускаются наши тесты.
![[Pasted image 20241125095632.png]]
- Jupiter - по сути это API для написания наших тестов. Набор аннотаций, asserts методы и т.д. Причем это именно в JUnit5.![[Pasted image 20241125095839.png]]
- Vintage
  ![[Pasted image 20241125095935.png]]

### Maven проект для тестов
Нужно добавить зависимость - 
```xml
<dependency>  
    <groupId>org.junit.jupiter</groupId>  
    <artifactId>junit-jupiter</artifactId>  
    <version>5.8.2</version>  
    <scope>test</scope>  
</dependency>
```
Surefire плагин - это плагин, который запускает тесты в maven lifecycle. Т.е. если мы не добавим этот плагин, то тесты запущены не будут, даже если мы вызоваем maven test.
В случае, если мы хотим сбилдить проект, но при этом не хотим, чтобы вызывались тесты, то используем:
![[Pasted image 20241125102433.png]]

А дальше в test директории создаем тестовый класс. Причем важно, чтобы класс, который тестирует, находился в том же пекедже, что и класс, который тестируем.

Видим, что и Calculator и CalculatorTest находятся в одном и том же пекедже - ru.sandr
![[Pasted image 20241125110106.png]]

Напишем первый тест:
```java
class CalculatorTest {  
  
    @Test  
    void integerDivision() {  
        Calculator calculator = new Calculator();  
        int result = calculator.integerDivision(4, 2);  
        assertEquals(4, result); //expected, actual  
    }  
}
```
И все Unit тестирование строится по такой схеме. В ней нет ничего сложного. Мы не должны понимать на 100%, как работает метод, который мы тестируем. Мы просто должны понимать, что он должен возвращать при определенных значениях параметров. 

Также мы можем добавлять к assert методам сообщение, которое будет выведено в том случае, если тест не будет пройден. Это полезно для того, чтобы дать какую-то доп информацию о том, почему тест зафейлился. Там может быть полезно передать параметры, которые были.
```java
assertEquals(2, result, "4/2 did not produce 2"); //expected, actual
```
Вот, где выведется сообщение:
![[Pasted image 20241125111148.png]]
Стоит сделать замечание - что те сообщения, которые мы можем добавить - замедляют выполнение тестов. Т.е. сообщение будет каждый раз создаваться(именно объект сообщения) и в случае, если тест прошел и если не прошел. Для маленьких приложений это будет незаметно, но на больших - заметно. Поэтому можно передавать не готовое сообщение, а lambda: () -> String, которая будет вызываться только в случае, если тест действительно не прошел и нужно вывести сообщение. Это дает буст по перформансу!
![[Pasted image 20241125112712.png]]
### Виды assertions
assertion методы - это на самом деле статические методы из jupiter:
`import static org.junit.jupiter.api.Assertions.*;` - вот такой импорт в нашем тестовом классе их и добавляет.
- assertEquals - для проверки равенства.
- fail("Message") - фейлит тест и выводит сообщение Message
- assertNotEquals - 
- assertTrue
- assertFalse
- assertNull
- assertNotNull
- assertThrows - для проверки того, что метод выбросит исключение
- assertDoesNotThrow

### Именование тестов
Конвенции зависят от команды, но есть некоторая наиболее часто встречающаяся конвенция именования.
test< System Under Test>_< Condition or state change>_< Expected Result>
Вот название теста в соотвествие с этой конвенцией:
```java
@Test  
void testIntegerDivision_WhenFourIsDividedByTwo_ShouldReturnTwo() {  
    Calculator calculator = new Calculator();  
    int result = calculator.integerDivision(4, 2);  
    assertEquals(2, result, "4/2 did not produce 2"); //expected, actual  
}
```
Еще примерчик для проверки деления на 0.
```java
@Test  
void testIntegerDivision_WhenDividendIsDividedByZero_ShouldThrowArithmeticException() {  
    }
```
Но минусом является то, что названия тестов становятся достаточно большими, хоть и хорошо описывают, что проверяет тест.
![[Pasted image 20241125113914.png]]
Для именования тестов мы можем использовать @DisplayName("name") аннотацию.
```java
@DisplayName("Test Math operations in Calculator class")  
class CalculatorTest {  
  
    @DisplayName("Test 4/2 = 2")  
    @Test  
    void testIntegerDivision_WhenFourIsDividedByTwo_ShouldReturnTwo() {  
        Calculator calculator = new Calculator();  
        int result = calculator.integerDivision(4, 2);  
        assertEquals(2, result, "4/2 did not produce 2"); //expected, actual  
    }  
  
    @DisplayName("Division by zero")  
    @Test  
    void testIntegerDivision_WhenDividendIsDividedByZero_ShouldThrowArithmeticException() {  
  
    }  
    @DisplayName("Test 7-2 = 5")  
    @Test  
    void integerSubtraction() {  
        Calculator calculator = new Calculator();  
  
        int result = calculator.integerSubtraction(7, 2);  
        assertEquals(5, result, "7 - 2 did not produce 5");  
    }  
}
```
Получим в выводе следующее:
![[Pasted image 20241125114908.png]]

### Паттерн для написания теста
AAA 
```java
@DisplayName("Test 4/2 = 2")  
@Test  
void testIntegerDivision_WhenFourIsDividedByTwo_ShouldReturnTwo() {  
    // AAA   
    // Arrange - настройка параметров и объекта для тестирования
    Calculator calculator = new Calculator();  
    int dividend = 4;  
    int divisor = 2;  
    int expectedResult = 2;  
      
    // Act  - выполнение действия, которое тестируем
    int actualResult = calculator.integerDivision(4, 2);  
      
    // Assert - проверка результатов
    assertEquals(expectedResult, actualResult, "4/2 did not produce 2"); 
}
```
### JUnit Test Lifecycle
При выполнении теста для каждого тестового метода создается свой instance тестового класса, причем порядок выполнения тестов не определен. Для каждого теста создать свой инстанс класса полезно, чтобы у каждого теста было отдельное состояние и чтобы результат выполнения теста не мог повлиять на результат выполнения другого теста из-за изменения какого-то поля в тестовом классе.
![[Pasted image 20241125115716.png]]
- @BeforeAll - вызывается перед выполнением всех тестов. Может быть полезен для инициализации ресурсов, которые будут использоваться всеми методами. Например, для создания тестовой БД.
- @BeforeEach - вызывается перед вызовом каждого тестового метода. В этот метод можно также вынести какую-то инициализацию ресурсов, чтобы не дублировать код в юнит тестах. Или, например, очищать БД, чтобы каждый юнит тест работал с чистым состоянием БД.
- @AfterEach - вызывается после вызова каждого тестового метода. Например, закрыть соединение с БД, которое использовалась в тесте. Или если мы пишем интеграционные тесты, то в этом методе можно вернуть БД в то состояние, в котором она была перед запуском метода.
- @AfterAll - после выполнения всех тестов. Например, очистить БД, которую создали в @BeforeAll.

Важно, что @BeforeAll и @AfterAll - static методы!

Если мы не будем вешать аннотацию @Test над нашим методом, то он не будет считаться тестовым и не будет вызван.

Если мы хотим отключить выполнение теста, то можем использовать @Disabled аннотацию
![[Pasted image 20241125121655.png]]

### Тестирование методов, которые выбрасывают исключение
```java
@DisplayName("Division by zero")  
@Test  
void testIntegerDivision_WhenDividendIsDividedByZero_ShouldThrowArithmeticException() {  
    // Arrange  
    int dividend = 4;  
    int divisor = 0;  
    String expectedExceptionMessage = "/ by zero";  
  
    // Act and Assert  
    ArithmeticException actualException = assertThrows(  
            ArithmeticException.class,  
            () -> calculator.integerDivision(dividend, divisor),  
            "Division by zero"  
    );  
  
    //сравним, что сообщение об ошибке соответствует тому, что мы ожидаем  
    assertEquals(expectedExceptionMessage, actualException.getMessage());  
}
```

### Научимся писать Unit тесты, которые принимают несколько параметров
Заметим, что ни один unit тест, который мы написали ранее не содержит input параметров. Это и логично, поскольку мы не вызываем тестовые методы, как мы делали это в Java.

Метод integerSubraction проверится дважды! С теми параметрами, которыми мы передали. Т.е. столько элементов, сколько элементов в стриме - столько раз будет вызван метод. А аргументы - это Arguments.of - они передадутся для каждого вызова теста.
```java
@DisplayName("Test integer subtraction [уменьшаемое], [вычитаемое], [разность]")  
@ParameterizedTest // т.к. это уже не обычный тест, а с параметрами, то так и пишем. Параметризованный тест.  
@MethodSource() // как параметр аннотации мы можем передать имя метода, который предоставит параметры  
//но если метод называется также, как и тот метод, что мы тестируем, то можно не указывать имя  
void integerSubtraction(int minuend, int subtrahend, int expectedResult) {  
  
    int actualResult = calculator.integerSubtraction(minuend, subtrahend);  
  
    assertEquals(expectedResult, actualResult);  
}  
  
//должен быть static!  
private static Stream<Arguments> integerSubtraction() {  
    return Stream.of(  
            Arguments.of(32, 1, 31),  
            Arguments.of(52, 52, 0)  
    );  
}
```
При выполнении написанного выше теста получим следующий вывод:
![[Pasted image 20241125124843.png]]

Может появиться вопрос, а зачем оно надо? Это может быть полезно, если мы, например, тестируем метод, который валидирует email. И чтобы рассмотреть множество вариантов - мы и можем использовать такую возможность.

Рассмотрим еще один способ предоставить аргументы в тестовый метод.
Для тех же нужд можем использовать @CsvSource.
![[Pasted image 20241125125202.png]]

Как передать строки? Схема та же.
1. Первая строка два полноценных параметра
2. Вторая строка. Второй параметр будет пустой строкой, но не null
3. Третья строка. Второй параметр null
![[Pasted image 20241125125424.png]]

Если мы не хотим хардкодить значения внутри @CsvSource, то можем использовать отдельный CSV файлик.
Для этого используем @CsvFileSource(resources = "/pathToFile.csv")

Создаем файлик в директории resources в нашей тестовой директории.
![[Pasted image 20241125130510.png]]
И указываем путь до этого файла @CsvFileSource
```java
@DisplayName("Test integer subtraction [уменьшаемое], [вычитаемое], [разность]")  
@ParameterizedTest  
@CsvFileSource(resources = "/integerSubtraction.csv")  
void integerSubtraction(int minuend, int subtrahend, int expectedResult) {  
    int actualResult = calculator.integerSubtraction(minuend, subtrahend);  
  
    assertEquals(expectedResult, actualResult);  
}
```

Рассмотрим еще одну аннотацию @ValueSource для передачи значений в тестовый метод.

Тест должен принимать 1 параметр, а потом передаем список значений, которые будет принимать наш метод для каждого теста. Т.е. на примере ниже тест выполнится 3 раза. Одни раз со значением Andrew, потом с Lev, потом с Alex
```java
@ParameterizedTest  
@ValueSource(strings = {"Andrew", "Lev", "Alex"})  
void valueSourceTest(String name) {  
    System.out.println(name);  
}
```
Тип параметра, который принимает тестовый метод может быть следующим:
![[Pasted image 20241125131119.png]]
### RepeatedTest
@RepeatedTest - повторить выполнение теста заданное количество раз. Тест ниже выполнится 5 раз:
![[Pasted image 20241125131734.png]]
Вывод будет следующим:
![[Pasted image 20241125131847.png]]
Каждый вызов repeated теста ничем не отличается от обычного теста. Т.е. все также вызываются @BeforeEach и @BeforeAll для каждого повторения.

Мы можем заинжектить в наш повторяющийся тест объект через который можно получить общее число повторений метода и номер текущего вызова.
Также можно заинжектить TestInformation и получить информацию по текущему запущенному тесту, например, имя теста.
![[Pasted image 20241125132441.png]]

Мы также можем указать шаблон выводы для repetition теста
![[Pasted image 20241125132618.png]]
Такой вывод получим
![[Pasted image 20241125132735.png]]

### Method Order
В идеале не нужно рассчитывать на порядок выполнения тестов. Но это может потребоваться при написании интеграционных тестов. Например, нужно, чтобы сначала выполнился тест, который записывает что-то в БД, потом тест, который забирает это что-то, потом, который удаляет.
Чтобы задать порядок вызова тестов мы используем аннотацию @TestMethodOrder и передаем внутрь один из вариантов:
![[Pasted image 20241125133033.png]]
- Random - запуск тестов в рандомном порядке.
- MethodName -  сортировка по имени метода.  
  ![[Pasted image 20241125133457.png]]
  ![[Pasted image 20241125133417.png]]
- OrderAnnotation
  ![[Pasted image 20241125134012.png]]
  ![[Pasted image 20241125134043.png]]
### Мы научились управлять последовательностью выполнения тестов внутри тестового класса. Но как задать порядок выполнения тестовых классов
Для этого используется та же аннотация @Order, но теперь вешаем над тестовым классом.
![[Pasted image 20241125145651.png]]
![[Pasted image 20241125145815.png]]
![[Pasted image 20241125145826.png]]
И чтобы включить сортировку тестовых классов по Order мы должны в resources создать файл junit-platfrom.properties
![[Pasted image 20241125150117.png]]
И в этом файлике добавить следующую строку`junit.jupiter.testclass.order.default=org.junit.jupiter.api.ClassOrderer$OrderAnnotation`
И можно использовать один из этих вариантов для наших тестовых классов(только вместо точки надо использовать $Random)
![[Pasted image 20241125150301.png]]
В этом же файле мы можем задать настройку для всех тестовых методов, как они будут сортироваться. Т.е. чтобы не писать @TestMethodOrder над каждым классом.
![[Pasted image 20241125150401.png]]

### @TestInstance(Lifecycle.PER_CLASS)
По дефолту lifecycle - per-method, т.е. для каждого тестового метода создается отдельный тестовый класс. И поэтому если мы даже как-то поменяем состояние поля в нашем тестовом классе, то в других тестовых методах этого изменения не будет видно, поскольку это уже другой объект тестового класса.
![[Pasted image 20241125151306.png]]

Если мы хотим изменить это поведение и чтобы создавался 1 объект нашего тестового класса для всех тестов, то используем @TestInstance(Lifecycle.PER_CLASS).
![[Pasted image 20241125151519.png]]
Это также может быть полезно для интеграционного тестирования. Когда тесты могут делиться состоянием полей тестового класса, т.е. изменения над полями тестового класса будут видны между тестами.

Когда мы используем PER_CLASS, то @BeforeAll и @AfterAll не статические.  
![[Pasted image 20241125153014.png]]
### TDD
Test Driven Development
![[Pasted image 20241125154913.png]]
В TDD мы перестаем писать тестовый метод, когда он перестает компилироваться.
Например, мы тестируем UserService. Сначала пишем тест, но сразу натыкаемся на то, что у нас нет UserService и тестовый метод не может скомпилироваться.
![[Pasted image 20241125155346.png]]
### Mockito
Mockito - это тестовый фреймворк для создания двойников объектов в юнит тестах. Т.е. нужен для того, чтобы в тестах использовать не настоящий объект, а его двойника.
Но зачем нам это нужно? Это нужно для решения проблемы изолированности тестов. Мы не хотим тестировать метод mySqlDao.save, а хотим тестировать метод createUser. Поэтому нам и нужен mock, чтобы не вызывался реальный метод из DAO. Плюс мы также можем программировать различные ситуации для результата выполнения save метода из DAO. Например, запрограммировать, что будет выброшено исключение или что вернется какой-то некорректный id и т.д. Т.е. благодаря Mock мы можем моделировать различные ситуации.
![[Pasted image 20241126101740.png]]

Для работы с Mockito нужно подключить зависимость mockit jupiter.

Над тестовым классом вешаем аннотацию @ExtendWith(MockitoExtension.class)
![[Pasted image 20241126103636.png]]

В тестовом классе UserServiceTest мы тестируем UserService методы. Сам userService имеет зависимость UserRepository, которая умеет сохранять пользователей. Но мы поняли, что мы не хотим тестировать функционал usersRepository в наших unit тестах, поэтому вместо usersRepository мы хотим использовать Mock объект(дублера). Для этого мы над полем в нашем тестовом классе вешаем @Mock аннотацию для зависимости. Тогда мокито встроится в жизненный цикл наших тестов и создаст Mock объект для UsersRepository. Он будет еще не настроенный, но уже Mock объект. И после этого мы можем как вручную передать в userService mock объект UsersRepository, либо снова попросить Mockito, используя аннотацию @InjectMocks, который создаст объект userService и в конструктор передаст mock объект usersRepository.
![[Pasted image 20241126103703.png]]

Пример теста с Mockito. Мы программируем наш @Mock объект - usersRepository, чтобы при вызове метода save на нем возвращалось true. В метод save нужно передать User объект, но т.к. нам в данном случае без разницы, что за User, то мы можем использовать Mockito.any(User.class). 
```java
@DisplayName("User object created")  
@Test  
void testCreateUser_whenUserDetailsProvided_returnUserObject() {  
    // Arrange  
    Mockito.when(usersRepository.save(Mockito.any(User.class))).thenReturn(true);  
  
    // Act  
    User user = userService.createUser(firstName, lastName, email, password, repeatPassword);  
  
    // Assert  
    assertNotNull(user, "createUser() should have returned null");  
    assertEquals(firstName, user.getFirstName(), () -> "User`s first name is incorrect");  
    assertEquals(lastName, user.getLastName());  
    assertEquals(email, user.getEmail());  
    assertNotNull(user.getId());  
}
```

Причем вот так сделать нельзя. Нужно использовать именно Mockito.any()
![[Pasted image 20241126104931.png]]

#### Проверка того, что метод на mock объекте вызвался нужное количество раз - для этого используется VerificationMode
Метод usersRepository.save() должен вызваться всего 1 раз при тестировании метода userService.createUser():
```java
Mockito.verify(usersRepository, Mockito.times(1))  
        .save(Mockito.any(User.class));
```

Есть другие методы у Mockito для проверки того, сколько раз вызвался метод. 
Mockito.atLeast(number) - метод должен быть вызван не менее number раз. И другие методы:
![[Pasted image 20241126110340.png]]

Если нас интересует строго 1 вызов какого-то метода, то для verify метода это поведение по умолчанию. Поэтому можем писать без передачи Mockito.times():
![[Pasted image 20241126110840.png]]

#### Exception Stubbing
```java
@DisplayName("If save() method causes RuntimeException, a UserServiceException is thrown")  
@Test  
void testCreateUser_whenSaveMethodThrowsException_thenThrowsUserServiceException() {  
    // Arrange  
    when(usersRepository.save(any(User.class)))  
            .thenThrow(RuntimeException.class);  
  
    // Act  
    assertThrows(UserServiceException.class,  
            () -> userService.createUser(firstName, lastName, email, password, repeatPassword));  
  
}
```

#### Если метод, который мы стаббим - void метод, то с ним нужно работать немного по-другому. Т.е. через when().then() с ним работать не получится.
when.then - работает только с теми методами, которые возвращают что-либо. Если мы используем void метод, то нужно использовать 
doThrow.when.methodCall:
```java
@DisplayName("EmailNotificationException is handled")  
@Test  
void testCreateUser_whenEmailNotificationExceptionThrown_throwsUserServiceException() {  
    // Arrange  
    when(usersRepository.save(any(User.class))).thenReturn(true);  
    // stubbing void method
    doThrow(EmailNotificationServiceException.class)  
            .when(emailVerificationService)  
            .scheduleEmailConfirmation(any(User.class));  
  
    // Act and Assert  
    assertThrows(UserServiceException.class,  
            () -> userService.createUser(firstName, lastName, email, password, repeatPassword));  
  
    verify(emailVerificationService).scheduleEmailConfirmation(any(User.class));  
}
```

#### Мы можем застаббить void метод, чтобы он ничего не делал
Для этого мы используем 
```java
 // stubbing void method
    doThrow(EmailNotificationServiceException.class)  
            .when(emailVerificationService)  
            .scheduleEmailConfirmation(any(User.class));  

doNothing().when(emailVerificationService)
.scheduleEmailConfirmation(any(User.clas))
```
И это поведение перепишет поведение, которое мы написали выше, где вызов метода scheduleEmailConfirmation должно выбросить исключение.

#### Mockito - call real method
Может быть полезно в том случае, когда мы как-то рефакторим код и хотим, чтобы после рефакторинга оно работало.
![[Pasted image 20241126114408.png]]

### Резюме
```java
// stubbing NON void method to return true
when(userRepository.save(any(User.class))).thenReturn(true);

// stubbing NON void method to throw exception
when(userRepository.save(any(User.class))).thenThrow(UserServiceException.class)

// stubbing void method to throw exception
doThrow(EmailServiceNotificationException.class)
	.when(emailServiceNotification)
	.scheduleEmail(any(User.class)) // вызов метода на объекте emailServiceNotif

// stubbing void method to do nothing
doNothing()
.when(emailServiceNotification)
.scheduleEmail(any(User.class))

// call real method
doCallRealMethod()
.when(emailServiceNotification)
.scheduleEmail(any(User.class))

// check how times method call
verify(userRepository, times(1))
.save(any(User.class))

```

### Code Coverage
Генерация отчетов по тому, насколько хорошо тесты покрывают наш код.
![[Pasted image 20241126120045.png]]
Процент покрытия говорит о том, сколько процентов методов вызываются при выполнении моих тестов, а не о том, что приложение 100% рабочее.
В реальном мире 100% покрытия добиться очень сложно, обычно команды довольны, когда покрытие кода 70-80%.

Как сгенерировать такой отчет?
Нажимаем правой кнопкой мыши в тестовом классе и выбираем:
![[Pasted image 20241126120334.png]]

### Как сгенерировать такой отчет в html:
![[Pasted image 20241126121031.png]]
![[Pasted image 20241126121125.png]]

### Генерация отчета, используя maven
Нужно добавить surefire-report-plugin и чтобы если тесты не прошли, то отчет все равно сгенерировался в configuration для surefire плагина добавляет testFailureIgnore = true.
```xml
<build>  
    <plugins>  
        <plugin>  
            <groupId>org.apache.maven.plugins</groupId>  
            <artifactId>maven-surefire-plugin</artifactId>  
            <version>3.3.1</version>  
            <configuration>                <testFailureIgnore>true</testFailureIgnore>  
            </configuration>  
        </plugin>  
        <plugin>            <groupId>org.apache.maven.plugins</groupId>  
            <artifactId>maven-surefire-report-plugin</artifactId>  
            <version>3.0.0-M6</version>  
            <executions>                <execution>  
                    <phase>test</phase>  
                    <goals>                        <goal>report</goal>  
                    </goals>  
                </execution>  
            </executions>  
        </plugin>  
    </plugins>  
</build>
```

Сгенерированный отчет будет находиться в target директории:
![[Pasted image 20241126122154.png]]
![[Pasted image 20241126122221.png]]
Но мы можем замеитть, что в этом отчете нет никакой информации о том, какое покрытие тестов. 

### Jacoco
Нужно добавить этот плагин для получения отчетов по покрытию тестами наших методов.
```xml
<plugin>  
    <groupId>org.jacoco</groupId>  
    <artifactId>jacoco-maven-plugin</artifactId>  
    <version>0.8.8</version>  
    <executions>        <execution>  
            <id>prepare-agent</id>  
            <goals>                <goal>prepare-agent</goal>  
            </goals>  
        </execution>  
        <execution>            <id>report</id>  
            <phase>test</phase>  
            <goals>                <goal>report</goal>  
            </goals>  
        </execution>  
    </executions>  
</plugin>
```

Сгенерированный отчет находится:
![[Pasted image 20241126123148.png]]
![[Pasted image 20241126123207.png]]
Missed Instructions - проверенные методы
Cov - процент покрытия
Missed Branches - покрытие случаев в if else 
cxty - complexity - чем больше if else и switch, тем она больше
missed - не протестированных строк lines - всего строк

### Testing Rest Controller
#### Unit тестирование
Когда мы выполняем Unit тестирование, то мы тестируем какой-то определенный метод, причем в изоляции от других зависимостей и их методов. Для этого используются mock объекты. Также никакие реальные HTTP запросы не выполняются. А также мы не поднимаем Spring Context для таких тестов!
![[Pasted image 20241126141801.png]]
### Integration Testing
Spring Framework позволяет тестировать слои по отдельности! Мы хотим протестировать web слой. Но Service и Repository мы не хотим тестировать, поэтому их мы также может заменить на Mock объекты. Но при этом мы хотим проверить наш веб слой, что вызов HTTP методы реально тригерит нужный нам метод. 
Spring при запуске тестов поднимет context и создаст бины только web слоя нашего приложения! Т.е. не будут созданы бины других слоев - это положительно сказывается на производительности! Такое тестирование называется интеграционным. Т.е. мы теперь тестируем не чисто какой-то метод, а уже целый слой и как он работает. Т.е. как он интегрирован в Spring и работает ли.
![[Pasted image 20241126142246.png]]
### Testing all layers
В таком виде тестов уже не создаются mock объекты, а происходит реальные вызовы! В таком случае нам нужно поднять уже полноценный Spring Context. Для таких тестов мы используем аннотацию @SpringBootTest
![[Pasted image 20241126142712.png]]

Пример теста, который тестирует UserController класс, а именно POST запрос:
```java
@WebMvcTest(controllers = UsersController.class,  
excludeAutoConfiguration = {SecurityAutoConfiguration.class}) //Так мы говорим Spring, что хотим протестировать только Web Layer. Тогда он будет сканировать наше приложение  
// и создаст бины только связанные с Web Layer.  
// controllers = UsersController.class - бины других контроллеров не будут созданы  
//excludeAutoConfiguration = {SecurityAutoConfiguration.class}) - делает то же самое, что и  
//@AutoConfigureMockMvc(addFilters = false)  
  
// Отключили Spring Security Configuration  
//@AutoConfigureMockMvc(addFilters = false)  
  
//@MockBean({UsersService.class}) // можем перечислить какие типы бинов нужно замокатьpublic class UsersControllerWebLayerTest {  
  
    @Autowired // Используется для выполнения вызовов, но при этом реальный HTTP метод не выполняется, а эмулируется спрингом  
    private MockMvc mockMvc;  
  
    //@Autowired // Заинжектится Mock UsersService, т.к. мы указали его в @MockBean  
  
    // @MockBean делает то же самое, что и @Mock, но созданный Mock объект кладет еще и в Application Context    @MockBean // вместо связки @Autowired + @MockBean({UsersService.class}) можно написать сразу над полем  
    UsersService usersService;  
  
    @Test  
    @DisplayName("User can be created")  
    void testCreateUser_whenValidUserDetailsProvided_returnsCreatedUserDetails() throws Exception {  
        // Arrange  
        UserDetailsRequestModel userDetailsRequestModel = new UserDetailsRequestModel();  
        userDetailsRequestModel.setFirstName("Andrew");  
        userDetailsRequestModel.setLastName("Smirnov");  
        userDetailsRequestModel.setEmail("andrew.smirnov@gmail.com");  
        userDetailsRequestModel.setPassword("123456789");  
        userDetailsRequestModel.setRepeatPassword("123456789");  
  
        UserDto userDto = new ModelMapper().map(userDetailsRequestModel, UserDto.class);  
        userDto.setUserId(UUID.randomUUID().toString());  
  
        when(usersService.createUser(any(UserDto.class))).thenReturn(userDto);  
  
        RequestBuilder requestBuilder = MockMvcRequestBuilders.post("/users")  
                .contentType(MediaType.APPLICATION_JSON)  
                .accept(MediaType.APPLICATION_JSON)  
                .content(new ObjectMapper().writeValueAsString(userDetailsRequestModel));  
  
        // Act  
        MvcResult mvcResult = mockMvc.perform(requestBuilder).andReturn();  
  
        String response = mvcResult.getResponse().getContentAsString();  
  
        UserRest createdUser = new ObjectMapper().readValue(response, UserRest.class);  
        // Assert  
        assertEquals(userDetailsRequestModel.getFirstName(), createdUser.getFirstName());  
        assertEquals(userDetailsRequestModel.getLastName(), createdUser.getLastName());  
        assertEquals(userDetailsRequestModel.getEmail(), createdUser.getEmail());  
        assertFalse(createdUser.getUserId().isEmpty());  
    }  
}
```
Пример метода, тестирующего, что наше приложение проверяет firstName переданного пользователя и в случае ошибки выбрасывает 400 ошибку:
```java
@DisplayName("First name is not empty")  
@Test  
void testCreateUser_whenFirstNameIsNotProvided_returns400StatusCode() throws Exception {  
    // Arrange  
    defaultUserDetails.setFirstName("");  
  
    RequestBuilder requestBuilder = MockMvcRequestBuilders.post("/users")  
            .contentType(MediaType.APPLICATION_JSON)  
            .accept(MediaType.APPLICATION_JSON)  
            .content(new ObjectMapper().writeValueAsString(defaultUserDetails));  
  
    // Act  
    MvcResult mvcResult = mockMvc.perform(requestBuilder).andReturn();  
  
    // Assert  
    assertEquals(HttpStatus.BAD_REQUEST.value(),  
            mvcResult.getResponse().getStatus(),  
            "Incorrect HTTP Status code returned");  
}
```

### Тестирование всех слоев сразу
Т.е. уже работаем с интеграционными тестами, когда мы реально будем вызывать методы реальных объектов, записывать в БД и все такое. Т.е. никаких Mock объектов не будет.
По дефолту, когда мы просто используем @SpringBootTest аннотацию, то на самом деле использует webEnvironmen = MOCK. Это значит, что создадутся только бины с web layer, причем servlet container будет замокан и на самом деле не будет поднят embedded tomcat. Т.е. для тестирования мы снова будем использовать MockMvc объект.
![[Pasted image 20241127095451.png]]

Но это не то, что нам нужно. Мы хотели протестировать наше приложение полноценно. Чтобы поднялись все бины, tomcat и мы делали реальные запросы.
Для этого нам нужно использовать другой webEnvironment - DEFINED_PORT или RANDOM_PORT. 
![[Pasted image 20241127095803.png]]
Если выбрали DEFINED_PORT, то как задать этот port? В application.properties файле:
![[Pasted image 20241127095935.png]]
Второй вариант внутри аннотации @SpringBootTest перезаписать значение этого же property из файла:
![[Pasted image 20241127100130.png]]

#### При тестировании нам часто нужно запустить наше приложение с другой конфигурацией. Например, на другом порту или подключиться к другой тестовой БД
Как это сделать?
Для этого можно использовать @TestPropertySource:
Мы указываем путь до файла из которого будем также забирать настройки конфигурации. Т.е. у нас будут загружаться настройки конфигурации из application.properties и application-test.properties, причем application-test.properties имеет приоритет над обычным application.properties. И за счет этого мы и можем изменить конфигурацию для наших тестов и подключаться к другой БД на время тестирования.
![[Pasted image 20241127101103.png]]
![[Pasted image 20241127101249.png]]

Но лучше для интеграционных тестов использовать RANDOM_PORT, чтобы не было конфликтов портов при запуске сразу нескольких интеграционных тестов одновременно.
![[Pasted image 20241127101325.png]]
Как узнать порт?
![[Pasted image 20241127101543.png]]

Пример тестирования метода POST по созданию пользователя:
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)  
//@TestPropertySource(locations = "/application-test.properties")  
public class UsersControllerIntegrationTest {  
  
    @Autowired  
    private TestRestTemplate restTemplate;  
  
    @LocalServerPort  
    private int localServerPort;  
    @Autowired  
    private TestRestTemplate testRestTemplate;  
  
    @Test  
    @DisplayName("User can be created")  
    void testCreateUser_whenValidDetailsProvided_returnsUserDetails() throws JSONException {  
        //Arrange  
        // Создаем JSON объект, чтобы потом методом toString создать из него
        // уже строковое представление JSON и передать как тело запроса
        JSONObject userDetailsRequestJson = new JSONObject();  
        userDetailsRequestJson.put("firstName", "Andrey");  
        userDetailsRequestJson.put("lastName", "Smirnov");  
        userDetailsRequestJson.put("email", "andrey.smirnov@gmail.com");  
        userDetailsRequestJson.put("password", "123456789");  
        userDetailsRequestJson.put("repeatPassword", "123456789");  

        HttpHeaders headers = new HttpHeaders();  
        headers.setContentType(MediaType.APPLICATION_JSON);  
        headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));  

		// Создаем запрос. Запрос состоит из хедеров и тела - это мы и передаем
        HttpEntity<String> request = new HttpEntity<>(userDetailsRequestJson.toString(), headers);  
  
        // Act  
        ResponseEntity<UserRest> createdUserDetailsEntity = testRestTemplate.postForEntity("/users",  
                request,  
                UserRest.class); // можем попросить testRestTemplate сконвертировать JSON строку, которая вернетс в указанный тип UserRest.class
  
        UserRest createdUserDetails = createdUserDetailsEntity.getBody(); // получаем тело респонса  
  
        Assert        assertEquals(HttpStatus.OK, createdUserDetailsEntity.getStatusCode());  
        assertEquals(userDetailsRequestJson.getString("firstName"),  
                createdUserDetails.getFirstName(),  
                "Returned user`s first name seems to be incorrect");  
        assertEquals(userDetailsRequestJson.getString("lastName"),  
                createdUserDetails.getLastName(),  
                "Returned user`s last name seems to be incorrect");  
        assertEquals(userDetailsRequestJson.getString("email"),  
                createdUserDetails.getEmail(),  
                "Returned user`s email seems to be incorrect");  
        assertFalse(createdUserDetails.getUserId().isEmpty(), "User id should not be empty");  
  
    }  
}
```
И это уже полноценный интеграционный тест. У нас реально поднялся контекст и запустился встроенный Tomcat и мы делаем реальный запрос, а не мокаем его. Также у нас работают все слои.

### При интеграционном тестировании у нас также начинает работать Security! 
Поэтому, если мы используем, например, JWT то нам также нужно будет работать с токенами!
Давайте напишем тест, который проверит, что наш Controller требует аутентификацию и авторизацию и возвращает 403 статус(forbidden).

```java
@Test  
@DisplayName("GET /users requires JWT")  
void testGetUsers_whenMissingJWT_returns403() {  
    // Arrange  
    HttpHeaders headers = new HttpHeaders();  
    headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));  
    // Т.к. делаем GET запрос, то body пустое  
    HttpEntity requestEntity = new HttpEntity<>(null, headers);  
  
    // Act  
    ResponseEntity<List<UserRest>> response = testRestTemplate.exchange("/users",  
            HttpMethod.GET,  
            requestEntity,  
            new ParameterizedTypeReference<List<UserRest>>() {  
    });  
  
    // Assert  
    assertEquals(HttpStatus.FORBIDDEN, response.getStatusCode());  
  
}
```

### Напишем тест, который проверит возможность залогиниться
Но тут появляется проблема. Мы должны для логина передать какого-то действующего юзера, но где его взять ? А тут на помощь приходит последовательность выполнения тестов. Мы можем выполнить сначала тест, который создаст нам пользователя, потом выполнить тест, который авторизуется за этого пользователя и получит JWT. И потом выполнить тест, который будет получать доступ к какому-то ресурсу для которого требуется JWT.

Стоит заметить, что к текущему моменту мы используем H2 БД. Т.е. после окончания выполнения тестов данные автоматически стираются, поэтому если мы еще раз запустим тест по созданию пользователя с теми же данными, то он пройдет, поскольку результат прошлого выполнения тестов забылся.

Приведем пример класса, который также предоставляет тест по возможности залогиниться. Стоит обратить внимание на то, что используется @TestMethodOrder
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)  
//@TestPropertySource(locations = "/application-test.properties")  
@TestMethodOrder(MethodOrderer.OrderAnnotation.class) // нам важен порядок тестов  
public class UsersControllerIntegrationTest {  
  
    @Autowired  
    private TestRestTemplate restTemplate;  
  
    @LocalServerPort  
    private int localServerPort;  
    @Autowired  
    private TestRestTemplate testRestTemplate;  
  
    @Order(1)  
    @Test  
    @DisplayName("User can be created")  
    void testCreateUser_whenValidDetailsProvided_returnsUserDetails() throws JSONException {  
        //Arrange  
        JSONObject userDetailsRequestJson = new JSONObject();  
        userDetailsRequestJson.put("firstName", "Andrey");  
        userDetailsRequestJson.put("lastName", "Smirnov");  
        userDetailsRequestJson.put("email", "andrey.smirnov@gmail.com");  
        userDetailsRequestJson.put("password", "123456789");  
        userDetailsRequestJson.put("repeatPassword", "123456789");  
  
        HttpHeaders headers = new HttpHeaders();  
        headers.setContentType(MediaType.APPLICATION_JSON);  
        headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));  
  
        HttpEntity<String> request = new HttpEntity<>(userDetailsRequestJson.toString(), headers);  
  
        // Act  
        ResponseEntity<UserRest> createdUserDetailsEntity = testRestTemplate.postForEntity("/users",  
                request,  
                UserRest.class); // можем попросить testRestTemplate сконвертировать JSON строку, которая вернетс в нужный нм объект  
  
        UserRest createdUserDetails = createdUserDetailsEntity.getBody(); // получаем тело респонса  
  
        // Assert        assertEquals(HttpStatus.OK, createdUserDetailsEntity.getStatusCode());  
        assertEquals(userDetailsRequestJson.getString("firstName"),  
                createdUserDetails.getFirstName(),  
                "Returned user`s first name seems to be incorrect");  
        assertEquals(userDetailsRequestJson.getString("lastName"),  
                createdUserDetails.getLastName(),  
                "Returned user`s last name seems to be incorrect");  
        assertEquals(userDetailsRequestJson.getString("email"),  
                createdUserDetails.getEmail(),  
                "Returned user`s email seems to be incorrect");  
        assertFalse(createdUserDetails.getUserId().isEmpty(), "User id should not be empty");  
  
    }  
  
    @Test  
    @DisplayName("GET /users requires JWT")  
    @Order(2)  
    void testGetUsers_whenMissingJWT_returns403() {  
        // Arrange  
        HttpHeaders headers = new HttpHeaders();  
        headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));  
        // Т.к. делаем GET запрос, то body пустое  
        HttpEntity requestEntity = new HttpEntity<>(null, headers);  
  
        // Act  
        ResponseEntity<List<UserRest>> response = testRestTemplate.exchange("/users",  
                HttpMethod.GET,  
                requestEntity,  
                new ParameterizedTypeReference<List<UserRest>>() {  
        });  
  
        // Assert  
        assertEquals(HttpStatus.FORBIDDEN, response.getStatusCode());  
    }  
  
    @Test  
    @DisplayName("/login works")  
    @Order(3)  
    void testUserLogin_whenValidCredentialsProvided_returnsJWNinAuthorizationHeader() throws JSONException {  
        // Arrange  
        JSONObject loginCredentials = new JSONObject();  
        loginCredentials.put("email", "andrey.smirnov@gmail.com");  
        loginCredentials.put("password", "123456789");  
  
        HttpEntity<String> request = new HttpEntity<>(loginCredentials.toString());  
  
        // Act  
        ResponseEntity response = testRestTemplate.postForEntity("/users/login", request, null);  
  
        // Assert  
        // Проверили статус        assertEquals(HttpStatus.OK, response.getStatusCode());  
        // Проверили, что в ответе есть header Authorization:  
        assertNotNull(response.getHeaders().getValuesAsList(SecurityConstants.HEADER_STRING).get(0),  
                "Response should contain Authorization header with JWT token");  
        assertNotNull(response.getHeaders().getValuesAsList("UserID").get(0),  
                "Response should contain UserID header");  
  
    }
```

### Напишем тест, который использует JWT токен и вызывает какой-то метод, который защищен security
Здесь весь код нашего тестового класса. Метод, который описан в заголовке самый последний. Из интересного используем @TestInstance(TestInstance.Lifecycle.PER_CLASS) чтобы мы могли сохранить в переменную private String authorizationToken;  токен, который получили при выполнении теста логина.

Также из интересного, что наш тест, который используем этот токен имеет @Order(4), чтобы запуститься после выполнения логина.
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)  
//@TestPropertySource(locations = "/application-test.properties")  
@TestMethodOrder(MethodOrderer.OrderAnnotation.class) // нам важен порядок тестов  
@TestInstance(TestInstance.Lifecycle.PER_CLASS) // т.к. должны сохранить authorizationToken между тестом login и get  
public class UsersControllerIntegrationTest {  
  
    private String authorizationToken;  
  
    @Autowired  
    private TestRestTemplate restTemplate;  
  
    @LocalServerPort  
    private int localServerPort;  
    @Autowired  
    private TestRestTemplate testRestTemplate;  
  
    @Order(1)  
    @Test  
    @DisplayName("User can be created")  
    void testCreateUser_whenValidDetailsProvided_returnsUserDetails() throws JSONException {  
        //Arrange  
        JSONObject userDetailsRequestJson = new JSONObject();  
        userDetailsRequestJson.put("firstName", "Andrey");  
        userDetailsRequestJson.put("lastName", "Smirnov");  
        userDetailsRequestJson.put("email", "andrey.smirnov@gmail.com");  
        userDetailsRequestJson.put("password", "123456789");  
        userDetailsRequestJson.put("repeatPassword", "123456789");  
  
        HttpHeaders headers = new HttpHeaders();  
        headers.setContentType(MediaType.APPLICATION_JSON);  
        headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));  
  
        HttpEntity<String> request = new HttpEntity<>(userDetailsRequestJson.toString(), headers);  
  
        // Act  
        ResponseEntity<UserRest> createdUserDetailsEntity = testRestTemplate.postForEntity("/users",  
                request,  
                UserRest.class); // можем попросить testRestTemplate сконвертировать JSON строку, которая вернетс в нужный нм объект  
  
        UserRest createdUserDetails = createdUserDetailsEntity.getBody(); // получаем тело респонса  
  
        // Assert        assertEquals(HttpStatus.OK, createdUserDetailsEntity.getStatusCode());  
        assertEquals(userDetailsRequestJson.getString("firstName"),  
                createdUserDetails.getFirstName(),  
                "Returned user`s first name seems to be incorrect");  
        assertEquals(userDetailsRequestJson.getString("lastName"),  
                createdUserDetails.getLastName(),  
                "Returned user`s last name seems to be incorrect");  
        assertEquals(userDetailsRequestJson.getString("email"),  
                createdUserDetails.getEmail(),  
                "Returned user`s email seems to be incorrect");  
        assertFalse(createdUserDetails.getUserId().isEmpty(), "User id should not be empty");  
  
    }  
  
    @Test  
    @DisplayName("GET /users requires JWT")  
    @Order(2)  
    void testGetUsers_whenMissingJWT_returns403() {  
        // Arrange  
        HttpHeaders headers = new HttpHeaders();  
        headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));  
        // Т.к. делаем GET запрос, то body пустое  
        HttpEntity requestEntity = new HttpEntity<>(null, headers);  
  
        // Act  
        ResponseEntity<List<UserRest>> response = testRestTemplate.exchange("/users",  
                HttpMethod.GET,  
                requestEntity,  
                new ParameterizedTypeReference<List<UserRest>>() {  
        });  
  
        // Assert  
        assertEquals(HttpStatus.FORBIDDEN, response.getStatusCode());  
    }  
  
    @Test  
    @DisplayName("/login works")  
    @Order(3)  
    void testUserLogin_whenValidCredentialsProvided_returnsJWNinAuthorizationHeader() throws JSONException {  
        // Arrange  
        JSONObject loginCredentials = new JSONObject();  
        loginCredentials.put("email", "andrey.smirnov@gmail.com");  
        loginCredentials.put("password", "123456789");  
  
        HttpEntity<String> request = new HttpEntity<>(loginCredentials.toString());  
  
        // Act  
        ResponseEntity response = testRestTemplate.postForEntity("/users/login", request, null);  
  
        // Assert  
        // Проверили статус        assertEquals(HttpStatus.OK, response.getStatusCode());  
  
        authorizationToken = response.getHeaders().getValuesAsList(SecurityConstants.HEADER_STRING).get(0);  
        // Проверили, что в ответе есть header Authorization:  
        assertNotNull(authorizationToken,  
                "Response should contain Authorization header with JWT token");  
        assertNotNull(response.getHeaders().getValuesAsList("UserID").get(0),  
                "Response should contain UserID header");  
  
    }  
  
    @Test  
    @DisplayName("GET /users works")  
    @Order(4)  
    void testGetUsers_whenValidJWTProvided_returnsUsers() {  
        // Arrange  
        HttpHeaders headers = new HttpHeaders();  
        headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));  
        headers.setBearerAuth(authorizationToken);  
  
        HttpEntity requestEntity = new HttpEntity<>(headers);  
        // Act  
        ResponseEntity<List<UserRest>> response = testRestTemplate.exchange("/users",  
                HttpMethod.GET,  
                requestEntity,  
                new ParameterizedTypeReference<List<UserRest>>() {});  
  
        // Assert  
        assertEquals(HttpStatus.OK, response.getStatusCode(), "HTTP status code should be 200");  
        assertTrue(response.getBody().size() == 1,  
                "There should be exactly 1 user in the list");  
  
    }
```


### Testing Data Layer
На этом уровне в изоляции можно протестировать Entity и Repository
### Testing Entity
На самом деле тестирование Entity происходит довольно редко, поскольку разработчики считают, что если с Entity имеются проблемы, то не пройдут тесты, которые тестируют Repository.
![[Pasted image 20241127134526.png]]
Например, можем проверить, что мы не можем иметь дубликатов в userId.
Я не стал конспектировать, если интересно - смотри раздел 12.
### @DataJpaTest
Для написания тестов Data layer используется аннотация @DataJpaTest. Она делает:
- Создает ApplicationContext  и бины только связанные с JPA
- Каждый тестовый метод по дефолту - Transactional и он выполняет rollback
- По дефолту используется in-memory db
![[Pasted image 20241127134747.png]]

### Testing JPA Repository
Что будем тестировать?
Мы не будем тестировать методы, которые нам достались при наследовании от JpaRepository, например. Т.е. не будет тестирования методов save, delete и т.д. Мы доверяем фреймворку в этом плане.
Мы будем тестировать собственные написанные методы в репозитории. Например, там где мы решили написать нативный запрос в нашем репозитории или там, где использовали возможности спринга по созданию SQL запросов из названия методов репозитория(например findByEmail)
![[Pasted image 20241127142204.png]]

Пример тестирования:
```java
@DataJpaTest  
public class UsersRepositoryTest {  
@Autowired  
UsersRepository usersRepository;  
  
String userId1 = UUID.randomUUID().toString();  
String userId2 = UUID.randomUUID().toString();  
  
String email1 = "andrew1.smirnov@gmail.com";  
String email2 = "andrew2.smirnov@gmail.com";  
  
@Autowired  
private TestEntityManager testEntityManager;  
  
@BeforeEach  
void setup() {  
    UserEntity userEntity1 = new UserEntity();  
    userEntity1.setFirstName("Andrew");  
    userEntity1.setLastName("Smirnov");  
    userEntity1.setEmail(email1);  
    userEntity1.setUserId(userId1);  
    userEntity1.setEncryptedPassword("123456789");  
    testEntityManager.persistAndFlush(userEntity1);  
  
    UserEntity userEntity2 = new UserEntity();  
    userEntity2.setFirstName("Andrew");  
    userEntity2.setLastName("Smirnov");  
    userEntity2.setEmail(email2);  
    userEntity2.setUserId(userId2);  
    userEntity2.setEncryptedPassword("123456789");  
    testEntityManager.persistAndFlush(userEntity2);  
}  
  
@Test  
@DisplayName("findByEmail is correct")  
void testFindByEmail_whenGivenCorrectEmail_returnsUserEntity() {  
    // Act  
    UserEntity storedUser = usersRepository.findByEmail(email1);  
  
    // Assert  
    assertEquals(email1, storedUser.getEmail());  
}  
  
@Test  
@DisplayName("findByUserId is correct")  
void testFindByUserId_whenGivenCorrectUserId_returnsUserEntity() {  
    // Act  
    UserEntity storedUser = usersRepository.findByUserId(userId2);  
    // Assert  
    assertNotNull(storedUser);  
    assertEquals(userId2, storedUser.getUserId());  
} 
}
```

### Testcontainers
![[Pasted image 20241127153620.png]]
Причем в Testcontainers мы можем запускать не только БД, но и любые другие приложения, которые можно запустить в докере. Например, kafka.

Для подключения мы должны подключить драйвер той БД, с которой хотим работать, а также testcontainers на сайте springbootinitializer. Если уже существующий проект, то есть кнопка explore на этом сайте, где можно посмотреть pom, в котором будут находиться зависимости, которые можно будет скопировать в свой pom.xml.

Пример тестового класса, который поднимает контейнер.
Также стоит заметить, что мы используем статическую переменную для объекта контейнера, чтобы несмотря на то, что для каждого теста создается свой инстанс тестового класса, контейнер был поднят всего один. 
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)  
@Testcontainers // говорим Spring что наш класс использует Testcontainers, чтобы он искал @Container и потом поднимал контейнер  
public class UsersControllerWithTestcontainersTest {  
  
    @Container  
    private static MySQLContainer mysqlContainer = new MySQLContainer("mysql:8.4.0")  
            .withDatabaseName("photo_app") // указываем имя БД  
            .withUsername("andrey") // указываем пользователя  
            .withPassword("123456789"); // указываем пароль  
  
    @DynamicPropertySource // т.к. по дефолту используется application.properties, а там будут production значения для подключения, то мы  
    // должны переопределить значения по этим ключам, узнав значения из контейнера, который подняли    private static void overrideProperties(DynamicPropertyRegistry registry) {  
        registry.add("spring.datasource.url", mysqlContainer::getJdbcUrl);  
        registry.add("spring.datasource.username", mysqlContainer::getUsername);  
        registry.add("spring.datasource.password", mysqlContainer::getPassword);  
    }  
  
    @Test  
    @DisplayName("The MySQL container is created and is running")  
    void testContainerIsRunning() {  
        assertTrue(mysqlContainer.isCreated(), "MySQL container was not created");  
        assertTrue(mysqlContainer.isRunning(), "MySQL container was not running");  
    }  
}
```

Вместо переписывания пропертей из application.properties в @DynamicPropertySource мы можем использовать аннотацию @ServiceConnection, которая сделает все за нас. 
![[Pasted image 20241127163422.png]]

Причем если нам не важно ни название БД, не credentials для подключения, то мы можем вообще это не указывать:
![[Pasted image 20241127163544.png]]

Если мы хотим использовать аннотацию @Order для наших тестов, то нужно дополнительно в static блоке инициализации вручную запустить контейнер - это нужно для того, чтобы обеспечить, что сначала будет поднят контейнер, а только после этого начнут выполняться тесты. Странно, что до использования ORder такой проблемы не было и мы могли и так запускать тесты, хотя по сути не было какого-то подтверждения того, что тест запустится после того, как контейнер будет поднят.

Также, т.к. теперь мы стартуем контейнер вручную, то может убрать аннотацию @Container. Но даже если оставить, то все будет работать.
![[Pasted image 20241127165659.png]]

### PostgreSQL Testcontainers configuration
Postgresdriver:
```xml
1. <dependency>
2. <groupId>org.postgresql</groupId>
3. <artifactId>postgresql</artifactId>
4. <scope>runtime</scope>
5. </dependency>
```

Spring Boot Test Dependency:
```xml
1. <dependency>
2. <groupId>org.springframework.boot</groupId>
3. <artifactId>spring-boot-starter-test</artifactId>
4. <scope>test</scope>
5. </dependency>
```
Testcontainers for Postgres:
```java
<dependency>
 <groupId>org.springframework.boot</groupId>
 <artifactId>spring-boot-testcontainers</artifactId>
<scope>test</scope>
 </dependency>
 <dependency>
 <groupId>org.testcontainers</groupId>
 <artifactId>junit-jupiter</artifactId>
 <scope>test</scope>
 </dependency>
<dependency>
 <groupId>org.testcontainers</groupId>
 <artifactId>postgresql</artifactId>
 <scope>test</scope>
 </dependency>
```

Поле в тестовом классе:
```java
 @Container
 @ServiceConnection
private static PostgreSQLContainer<?> postgreSQLContainer = new PostgreSQLContainer<>("postgres:latest");
```
