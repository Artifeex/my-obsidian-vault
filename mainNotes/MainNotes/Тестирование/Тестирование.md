Unit тест - это маленький блок кода, который тестирует какую-то одну функциональность.
![[Pasted image 20241125091056.png]]
JUnit предоставляет API для написания тестирования.
Само же тестирование состоит из того, что мы вызываем какой-то код и сравниваем ожидаемое значение с тем, что возвращает метод.

Пример Unit теста. Стандартный Unit тест состоит из 3-х частей.
- Инициализации
- Выполнения действия, которое тестируем
- Сравнение ожидаемого результата и что на самом деле получилось
![[Pasted image 20241125091625.png]]

Unit тесты быстрые, поскольку если они используют какие-то зависимости, например, вызывают HTTP метод, то мы на самом деле не выполняем HTTP метод, а заменяем этот вызов с помощью заранее запрограммированного фейкового объекта - mock, который мы программируем, какой результат он будет возвращать. И мы заменяем все зависимости на моки, поэтому тесты выполняются быстро.
![[Pasted image 20241125092009.png]]

### Зачем писать Unit тесты?
Мы же можем вручную проверить работу нашего приложения.
![[Pasted image 20241125092617.png]]
Наиболее важным как по мне является решение проблемы regression - это ситуация, когда мы написали код(или изменили) и после этого сломалась функциональность, которая раньше работала и была протестирована. 
Unit тесты решают эту проблему тем, что если мы изменили код и он что-то сломал, то мы узнаем это на этапе тестирования, а не в проде...

### F.I.R.S.T. Principle
Набор принципов, которым стараются следовать при написании Unit тестов.
- Fast - юнит тесты маленькие тесты, которые не работают с реальными объектами(например, БД) в отличие от интеграционных тестов.
- Self-validating - unit тест решает прошел тест или нет. Т.е. после того, как мы запустили unit тесты и получили результаты, то нам не нужно делать какого-то дополнительного ручного тестирования, чтобы проверить результаты тестов.
![[Pasted image 20241125093435.png]]

### Проблема изолированности тестов
Когда мы тестируем метод в юнит тесте в идеале, чтобы он был независимым и работал самостоятельно. Но на практике такое бывает редко, часто метод вызывает методы других классов. Но тогда возникает проблема. Рассмотрим пример. Пусть мы теастируем метод  из класса А, который в своей работе использует вызов метода из класса B. Но, что, если в методе, который вызывается в классе B - ошибка? Тогда юнит тест, который мы написали для тестирования метода из класса А не пройдет и мы будем считать, что неверно написан метод в классе А, а на самом деле ошибка была в классе B! 
Поэтому и важна изоляция! Но как мы можем это решить? С помощью mock объектов.
![[Pasted image 20241125093826.png]]

Когда наш класс зависит от каких-то других объктов, то мы можем использовать DI. И вот при DI мы можем вместо того, чтобы вставлять реальные объекты, вставлять Mock объекты, которые мы заранее запрограммируем и тогда методы реальных объектов не будут вызываться! А это значит, что мы добились изолированности, т.к. теперь реально написанный код не вызывается, а, значит, что мы застрахованы от ошибки в чужом коде! 
![[Pasted image 20241125094334.png]]

### Testing Pyramid
![[Pasted image 20241125095231.png]]
Unit tests - больше всего, они тестируют методы в изоляции от других зависимостей, используя fake объекты - mock, spy. Их проще всего писать и выполняются они быстрее всех, т.к. не требуют реального общение с внешними системами или реальной БД.
Integration tests - более сложные тесты. Они уже используют реальные объекты и цель таких тестов проверить как наша система работает уже в реальном взаимодействии с другими системами! Т.е. тут уже происходят реальные HTTP вызовы и реальная работа с БД.
End-To-End тесты - самые сложные и их меньше всего. Они уже тестируют конечную пользовательскую функциональность.

### Что такое JUNIT 5
Это комбинация 3 вещей
![[Pasted image 20241125095539.png]]
- JUnit Platform - платформа, которая управляем фундаментом тестирования на JVM. Т.е. по сути это сердце JUnit. Т.е. это платформа, на которой запускаются наши тесты.
![[Pasted image 20241125095632.png]]
- Jupiter - по сути это API для написания наших тестов. Набор аннотаций, asserts методы и т.д. Причем это именно в JUnit5.![[Pasted image 20241125095839.png]]
- Vintage
  ![[Pasted image 20241125095935.png]]

### Maven проект для тестов
Нужно добавить зависимость - 
```xml
<dependency>  
    <groupId>org.junit.jupiter</groupId>  
    <artifactId>junit-jupiter</artifactId>  
    <version>5.8.2</version>  
    <scope>test</scope>  
</dependency>
```
Surefire плагин - это плагин, который запускает тесты в maven lifecycle. Т.е. если мы не добавим этот плагин, то тесты запущены не будут, даже если мы вызоваем maven test.
В случае, если мы хотим сбилдить проект, но при этом не хотим, чтобы вызывались тесты, то используем:
![[Pasted image 20241125102433.png]]

А дальше в test директории создаем тестовый класс. Причем важно, чтобы класс, который тестирует, находился в том же пекедже, что и класс, который тестируем.

Видим, что и Calculator и CalculatorTest находятся в одном и том же пекедже - ru.sandr
![[Pasted image 20241125110106.png]]

Напишем первый тест:
```java
class CalculatorTest {  
  
    @Test  
    void integerDivision() {  
        Calculator calculator = new Calculator();  
        int result = calculator.integerDivision(4, 2);  
        assertEquals(4, result); //expected, actual  
    }  
}
```
И все Unit тестирование строится по такой схеме. В ней нет ничего сложного. Мы не должны понимать на 100%, как работает метод, который мы тестируем. Мы просто должны понимать, что он должен возвращать при определенных значениях параметров. 

Также мы можем добавлять к assert методам сообщение, которое будет выведено в том случае, если тест не будет пройден. Это полезно для того, чтобы дать какую-то доп информацию о том, почему тест зафейлился. Там может быть полезно передать параметры, которые были.
```java
assertEquals(2, result, "4/2 did not produce 2"); //expected, actual
```
Вот, где выведется сообщение:
![[Pasted image 20241125111148.png]]
Стоит сделать замечание - что те сообщения, которые мы можем добавить - замедляют выполнение тестов. Т.е. сообщение будет каждый раз создаваться(именно объект сообщения) и в случае, если тест прошел и если не прошел. Для маленьких приложений это будет незаметно, но на больших - заметно. Поэтому можно передавать не готовое сообщение, а lambda: () -> String, которая будет вызываться только в случае, если тест действительно не прошел и нужно вывести сообщение. Это дает буст по перформансу!
![[Pasted image 20241125112712.png]]
### Виды assertions
assertion методы - это на самом деле статические методы из jupiter:
`import static org.junit.jupiter.api.Assertions.*;` - вот такой импорт в нашем тестовом классе их и добавляет.
- assertEquals - для проверки равенства.
- fail("Message") - фейлит тест и выводит сообщение Message
- assertNotEquals - 
- assertTrue
- assertFalse
- assertNull
- assertNotNull
- assertThrows - для проверки того, что метод выбросит исключение
- assertDoesNotThrow

### Именование тестов
Конвенции зависят от команды, но есть некоторая наиболее часто встречающаяся конвенция именования.
test< System Under Test>_< Condition or state change>_< Expected Result>
Вот название теста в соотвествие с этой конвенцией:
```java
@Test  
void testIntegerDivision_WhenFourIsDividedByTwo_ShouldReturnTwo() {  
    Calculator calculator = new Calculator();  
    int result = calculator.integerDivision(4, 2);  
    assertEquals(2, result, "4/2 did not produce 2"); //expected, actual  
}
```
Еще примерчик для проверки деления на 0.
```java
@Test  
void testIntegerDivision_WhenDividendIsDividedByZero_ShouldThrowArithmeticException() {  
    }
```
Но минусом является то, что названия тестов становятся достаточно большими, хоть и хорошо описывают, что проверяет тест.
![[Pasted image 20241125113914.png]]
Для именования тестов мы можем использовать @DisplayName("name") аннотацию.
```java
@DisplayName("Test Math operations in Calculator class")  
class CalculatorTest {  
  
    @DisplayName("Test 4/2 = 2")  
    @Test  
    void testIntegerDivision_WhenFourIsDividedByTwo_ShouldReturnTwo() {  
        Calculator calculator = new Calculator();  
        int result = calculator.integerDivision(4, 2);  
        assertEquals(2, result, "4/2 did not produce 2"); //expected, actual  
    }  
  
    @DisplayName("Division by zero")  
    @Test  
    void testIntegerDivision_WhenDividendIsDividedByZero_ShouldThrowArithmeticException() {  
  
    }  
    @DisplayName("Test 7-2 = 5")  
    @Test  
    void integerSubtraction() {  
        Calculator calculator = new Calculator();  
  
        int result = calculator.integerSubtraction(7, 2);  
        assertEquals(5, result, "7 - 2 did not produce 5");  
    }  
}
```
Получим в выводе следующее:
![[Pasted image 20241125114908.png]]

### Паттерн для написания теста
AAA 
```java
@DisplayName("Test 4/2 = 2")  
@Test  
void testIntegerDivision_WhenFourIsDividedByTwo_ShouldReturnTwo() {  
    // AAA   
    // Arrange - настройка параметров и объекта для тестирования
    Calculator calculator = new Calculator();  
    int dividend = 4;  
    int divisor = 2;  
    int expectedResult = 2;  
      
    // Act  - выполнение действия, которое тестируем
    int actualResult = calculator.integerDivision(4, 2);  
      
    // Assert - проверка результатов
    assertEquals(expectedResult, actualResult, "4/2 did not produce 2"); 
}
```
### JUnit Test Lifecycle
При выполнении теста для каждого тестового метода создается свой instance тестового класса, причем порядок выполнения тестов не определен. Для каждого теста создать свой инстанс класса полезно, чтобы у каждого теста было отдельное состояние и чтобы результат выполнения теста не мог повлиять на результат выполнения другого теста из-за изменения какого-то поля в тестовом классе.
![[Pasted image 20241125115716.png]]
- @BeforeAll - вызывается перед выполнением всех тестов. Может быть полезен для инициализации ресурсов, которые будут использоваться всеми методами. Например, для создания тестовой БД.
- @BeforeEach - вызывается перед вызовом каждого тестового метода. В этот метод можно также вынести какую-то инициализацию ресурсов, чтобы не дублировать код в юнит тестах. Или, например, очищать БД, чтобы каждый юнит тест работал с чистым состоянием БД.
- @AfterEach - вызывается после вызова каждого тестового метода. Например, закрыть соединение с БД, которое использовалась в тесте. Или если мы пишем интеграционные тесты, то в этом методе можно вернуть БД в то состояние, в котором она была перед запуском метода.
- @AfterAll - после выполнения всех тестов. Например, очистить БД, которую создали в @BeforeAll.

Важно, что @BeforeAll и @AfterAll - static методы!

Если мы не будем вешать аннотацию @Test над нашим методом, то он не будет считаться тестовым и не будет вызван.

Если мы хотим отключить выполнение теста, то можем использовать @Disabled аннотацию
![[Pasted image 20241125121655.png]]

### Тестирование методов, которые выбрасывают исключение
```java
@DisplayName("Division by zero")  
@Test  
void testIntegerDivision_WhenDividendIsDividedByZero_ShouldThrowArithmeticException() {  
    // Arrange  
    int dividend = 4;  
    int divisor = 0;  
    String expectedExceptionMessage = "/ by zero";  
  
    // Act and Assert  
    ArithmeticException actualException = assertThrows(  
            ArithmeticException.class,  
            () -> calculator.integerDivision(dividend, divisor),  
            "Division by zero"  
    );  
  
    //сравним, что сообщение об ошибке соответствует тому, что мы ожидаем  
    assertEquals(expectedExceptionMessage, actualException.getMessage());  
}
```

### Научимся писать Unit тесты, которые принимают несколько параметров
Заметим, что ни один unit тест, который мы написали ранее не содержит input параметров. Это и логично, поскольку мы не вызываем тестовые методы, как мы делали это в Java.

Метод integerSubraction проверится дважды! С теми параметрами, которыми мы передали. Т.е. столько элементов, сколько элементов в стриме - столько раз будет вызван метод. А аргументы - это Arguments.of - они передадутся для каждого вызова теста.
```java
@DisplayName("Test integer subtraction [уменьшаемое], [вычитаемое], [разность]")  
@ParameterizedTest // т.к. это уже не обычный тест, а с параметрами, то так и пишем. Параметризованный тест.  
@MethodSource() // как параметр аннотации мы можем передать имя метода, который предоставит параметры  
//но если метод называется также, как и тот метод, что мы тестируем, то можно не указывать имя  
void integerSubtraction(int minuend, int subtrahend, int expectedResult) {  
  
    int actualResult = calculator.integerSubtraction(minuend, subtrahend);  
  
    assertEquals(expectedResult, actualResult);  
}  
  
//должен быть static!  
private static Stream<Arguments> integerSubtraction() {  
    return Stream.of(  
            Arguments.of(32, 1, 31),  
            Arguments.of(52, 52, 0)  
    );  
}
```
При выполнении написанного выше теста получим следующий вывод:
![[Pasted image 20241125124843.png]]

Может появиться вопрос, а зачем оно надо? Это может быть полезно, если мы, например, тестируем метод, который валидирует email. И чтобы рассмотреть множество вариантов - мы и можем использовать такую возможность.

Рассмотрим еще один способ предоставить аргументы в тестовый метод.
Для тех же нужд можем использовать @CsvSource.
![[Pasted image 20241125125202.png]]

Как передать строки? Схема та же.
1. Первая строка два полноценных параметра
2. Вторая строка. Второй параметр будет пустой строкой, но не null
3. Третья строка. Второй параметр null
![[Pasted image 20241125125424.png]]

Если мы не хотим хардкодить значения внутри @CsvSource, то можем использовать отдельный CSV файлик.
Для этого используем @CsvFileSource(resources = "/pathToFile.csv")

Создаем файлик в директории resources в нашей тестовой директории.
![[Pasted image 20241125130510.png]]
И указываем путь до этого файла @CsvFileSource
```java
@DisplayName("Test integer subtraction [уменьшаемое], [вычитаемое], [разность]")  
@ParameterizedTest  
@CsvFileSource(resources = "/integerSubtraction.csv")  
void integerSubtraction(int minuend, int subtrahend, int expectedResult) {  
    int actualResult = calculator.integerSubtraction(minuend, subtrahend);  
  
    assertEquals(expectedResult, actualResult);  
}
```

Рассмотрим еще одну аннотацию @ValueSource для передачи значений в тестовый метод.

Тест должен принимать 1 параметр, а потом передаем список значений, которые будет принимать наш метод для каждого теста. Т.е. на примере ниже тест выполнится 3 раза. Одни раз со значением Andrew, потом с Lev, потом с Alex
```java
@ParameterizedTest  
@ValueSource(strings = {"Andrew", "Lev", "Alex"})  
void valueSourceTest(String name) {  
    System.out.println(name);  
}
```
Тип параметра, который принимает тестовый метод может быть следующим:
![[Pasted image 20241125131119.png]]
### RepeatedTest
@RepeatedTest - повторить выполнение теста заданное количество раз. Тест ниже выполнится 5 раз:
![[Pasted image 20241125131734.png]]
Вывод будет следующим:
![[Pasted image 20241125131847.png]]
Каждый вызов repeated теста ничем не отличается от обычного теста. Т.е. все также вызываются @BeforeEach и @BeforeAll для каждого повторения.

Мы можем заинжектить в наш повторяющийся тест объект через который можно получить общее число повторений метода и номер текущего вызова.
Также можно заинжектить TestInformation и получить информацию по текущему запущенному тесту, например, имя теста.
![[Pasted image 20241125132441.png]]

Мы также можем указать шаблон выводы для repetition теста
![[Pasted image 20241125132618.png]]
Такой вывод получим
![[Pasted image 20241125132735.png]]

### Method Order
В идеале не нужно рассчитывать на порядок выполнения тестов. Но это может потребоваться при написании интеграционных тестов. Например, нужно, чтобы сначала выполнился тест, который записывает что-то в БД, потом тест, который забирает это что-то, потом, который удаляет.
Чтобы задать порядок вызова тестов мы используем аннотацию @TestMethodOrder и передаем внутрь один из вариантов:
![[Pasted image 20241125133033.png]]
- Random - запуск тестов в рандомном порядке.
- MethodName -  сортировка по имени метода.  
  ![[Pasted image 20241125133457.png]]
  ![[Pasted image 20241125133417.png]]
- OrderAnnotation
  ![[Pasted image 20241125134012.png]]
  ![[Pasted image 20241125134043.png]]
### Мы научились управлять последовательностью выполнения тестов внутри тестового класса. Но как задать порядок выполнения тестовых классов
Для этого используется та же аннотация @Order, но теперь вешаем над тестовым классом.
![[Pasted image 20241125145651.png]]
![[Pasted image 20241125145815.png]]
![[Pasted image 20241125145826.png]]
И чтобы включить сортировку тестовых классов по Order мы должны в resources создать файл junit-platfrom.properties
![[Pasted image 20241125150117.png]]
И в этом файлике добавить следующую строку`junit.jupiter.testclass.order.default=org.junit.jupiter.api.ClassOrderer$OrderAnnotation`
И можно использовать один из этих вариантов для наших тестовых классов(только вместо точки надо использовать $Random)
![[Pasted image 20241125150301.png]]
В этом же файле мы можем задать настройку для всех тестовых методов, как они будут сортироваться. Т.е. чтобы не писать @TestMethodOrder над каждым классом.
![[Pasted image 20241125150401.png]]

### @TestInstance(Lifecycle.PER_CLASS)
По дефолту lifecycle - per-method, т.е. для каждого тестового метода создается отдельный тестовый класс. И поэтому если мы даже как-то поменяем состояние поля в нашем тестовом классе, то в других тестовых методах этого изменения не будет видно, поскольку это уже другой объект тестового класса.
![[Pasted image 20241125151306.png]]

Если мы хотим изменить это поведение и чтобы создавался 1 объект нашего тестового класса для всех тестов, то используем @TestInstance(Lifecycle.PER_CLASS).
![[Pasted image 20241125151519.png]]
Это также может быть полезно для интеграционного тестирования. Когда тесты могут делиться состоянием полей тестового класса, т.е. изменения над полями тестового класса будут видны между тестами.

Когда мы используем PER_CLASS, то @BeforeAll и @AfterAll не статические.  
![[Pasted image 20241125153014.png]]
### TDD
Test Driven Development
![[Pasted image 20241125154913.png]]
В TDD мы перестаем писать тестовый метод, когда он перестает компилироваться.
Например, мы тестируем UserService. Сначала пишем тест, но сразу натыкаемся на то, что у нас нет UserService и тестовый метод не может скомпилироваться.
![[Pasted image 20241125155346.png]]
