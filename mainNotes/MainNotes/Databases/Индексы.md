**Индекс (англ. index) — объект базы данных, создаваемый с целью повышения производительности поиска данных.**

**Существует два типа индексов: кластерные и некластерные. При наличии кластерного индекса строки таблицы упорядочены по значению ключа этого индекса. Если в таблице нет кластерного индекса, таблица называется кучей. Некластерный индекс, созданный для такой таблицы, содержит только указатели на записи таблицы. Кластерный индекс может быть только одним для каждой таблицы, но каждая таблица может иметь несколько различных некластерных индексов, каждый из которых определяет свой собственный порядок следования записей**


Когда мы делали SELECT FROM или ставили условие where мы не задумывались о том, как БД делает все это, как она делает джоины, а ведь это трудозатратные операции.

В реальных приложениях БД состоят из миллионов записей и нам нужно как-то сделать так, чтобы операции выполнялись как можно быстрее.

Например: хотим найти полет с id = 16. Придется идти по файлику, который хранится на компьютере и БД сравнивает значения по строчно, что очень долго. Если записей миллион, то это миллион сравнений! Поэтому и придумали индексы! Чтобы ускорить выборку и поиск по БД. Они бывают самыми разными.

B-Tree Indexes - это как раз тот тип индексов, который использует постгрес по умолчанию. Различие с бинарным деревом в том, что в бинарном дереве в узле одно значение, а в B-Tree в узле сразу множество значений.
![[Pasted image 20240927123145.png]]
В B-Tree количество потомков ≤ (количеству значений, храняющихся в узле + 1). Поиск начинается от корня нашего дерева. Поиск ускоряется как раз за счет того, что наши id хранятся в виде такой структуру дынных B-tree, что сильно увеличивает скорость поиска.

Например, мы захотели найти 23. Начинаем с корня. 10 > 23 ? Нет, значит, идем дальше. 20> 23 ? Нет, дальше. 30 > 23? Да, поэтому идем по левой стрелке для значения 30. 22 > 23? Да, дальше. 23 = 23. Конец.

Зачем так? Самым долгим в операции поиска является считывание с жесткого диска данных. Значения в узлах находятся так, чтобы все они находились в одном сегменте жесткого диска(жесткий диск делится на сегменты). Тогда мы считываем сразу весь сегмент и у нас уже есть все значения, с которыми надо будет сравнить на этом уровне дерева, так не надо будет для каждого сравнения бегать в жесткий диск и считывать данные. На самом деле, важно, чтобы всегда узел помещался в сегмент(или несколько узлов).

Т.е. B-Tree рассчитана так, чтобы минимизировать количество считываний данных из жесткого диска в оперативную память.
![[Pasted image 20240927123401.png]]

В узле хранится еще и ссылка(возможно, смещение кол-ва байт от начала файла) на запись в таблице. Причем индекс - это отдельный файл и таблица - это отдельный файл. Если зайдем в директорию, где БД хранит свои данные, то увидим, что для одной таблицы может быть несколько отдельных файлов, в которых хранятся индексы нашей таблицы(т.к. у одной таблицы мы можем задавать несколько индексов).

Чтобы минимизировать походы в разные файлы(один с индексом, другой с таблицей) существуют еще и кластерные индексы, которые хранят и индекс и всю строку таблицы.
На одну таблицу может быть только 1 кластерный индекс.
### Когда мы создаем первичный ключ, то автоматически создается b-tree индекс(т.е. отдельный файл, в котором будут хранится наши значения первичных ключей)

Когда мы делаем SELECT * FROM WHERE id = 3; если данных мало, то СУБД, скорее всего, сделает полный поиск. Т.е. сразу считает весь файл с нашей таблицей и найдет строку, у которой id = 3. Это происходит из-за того, что данных мало и это будет быстрее, чем сначала открыть файл с b-tree индексом, найти там нужное значение, потом взять у него ссылку, открыть файл с таблицей и уже по этой ссылке найти строку - вот это будет происходить, если СУБД решит искать, используя b-tree index.

Если мы ищем не по столбцу, для которого есть индекс, то происходит full scan(т.е. просто построчная проверка).

Создание индекса по двум полям:
![[Pasted image 20240927123701.png]]

Если нужна уникальность(т.е. будет говорить и проверять, уникальные значения или нет).
![[Pasted image 20240927123748.png]]
Т.е. если мы создали обычный индекс и в таблице было бы 2 записи с таким индексом, то он ссылался бы на эти 2 записи и при поиске по нему возвращал бы эти две записи. Но если мы такого не хотим, то используем UNIQUE.
UNIQUE INDEX - работает быстрее чем обычный INDEX, потому что нет никакой доп фильтрации на строки.

Поиск в данном случае будет по индексу только в том случае, если мы ищем именно по комбинации flight_id + seat_no. Если, например, только по seat_no, то поиск будет медленным и не по индексу. Вот такой запрос задействует index(зависит от оптимизатора):
![[Pasted image 20240927123856.png]]

Селективность - это доля уникальности значений столбца. Т.е. количество уникальных значений / на общее количество элементов. Чем ближе значение к 1, тем лучше селективность и тем больше шансов, что оптимизатор БД будет использовать индекс для этого столбца, а не прямой поиск.

Удаление или добавление трудозатратные операции еще и по тому, что требует обновления индексов.

Мы можем анализировать, как БД делает запросы, использует индексы или нет. Для этого используется [[План выполнения запросов]].
