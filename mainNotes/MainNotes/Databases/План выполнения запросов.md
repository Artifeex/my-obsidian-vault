Чтобы получить то, как БД выполнила запрос, можно использовать ключевое слово explain.
![[Pasted image 20240927124240.png]]
Возвращается следующая строчка:
![[Pasted image 20240927124258.png]]
- seq scan = full scan = т.е. полностью считали таблицу от первой строчки до последней.
- cost = оптимизатор использует это значение, чтобы понять, как более оптимизированно выполнить тот или иной запрос
- rows = примерное количество строк, которое вернется
- width = среднее количество байт на одну строку


Сейчас используется cost-based(стоимостной) оптимизатор. Он основывается на стоимости каждой операции.(Стоимостной оптимизатор использует таблицу со статистикой по каждой таблице, которая называется pg_stats и собирается по некоторой выборке нашей таблицы)

Стоимость формируется: 1.0 - столько тратится на чтение одной страницы с жесткого диска в оперативную память(как узнать, сколько страниц занимает наша таблица?). 0.01 - такая стоимость обработки процессором одной строчки.

Поэтому стоимость операции select * from ticket; = 1 + 55(строк) * 0.01 = 1.55

В pg_catalog(схема) хранятся таблицы для статистики по каждой нашей таблице и на основании этой статистики стоимостной оптимизатор и определяет план выполнения нашего запроса. pg_class - интересующая нас таблица. В ней есть столбец relpages = сколько страниц требуется для нашей таблицы.


### Как читать план запросов?
План запросов нужно читать от самой вложенной строчки и наверх
![[Pasted image 20241113120828.png]]

### План выполнения запроса и индексы
Сделаем такой запрос:
![[Pasted image 20241113120904.png]]
![[Pasted image 20241113120911.png]]
Выполнился Seq Scan, а не по индексу. Почему?
Почему в запросе выше Seq scan, а не по индексу? Потому что стоитмость такого запроса 1.69, а если бы мы делали поиск по индексу, то уже пришлось бы потратить 2 считывания(1 для самой таблицу, другой для индекса), что уже дает cost = 2. Поэтому оптимизатор выбрал full scan. Если бы данных было больше, например, таблица занимала бы 3 страницы, то тогда только на считывание таблицы был бы cost = 3, а в случае поиска по индексу, мы бы cost = 1 потратили на индекс, нашли бы там нужный элемент, ссылку на строку таблицы и тогда считали бы не всю таблицу, а только ту страницу, в которой находится нужная нам строка, что давало бы нам стоимость cost = 2 + (сколько_то из-за ЦПУ). В таком случае, выгоднее было бы искать по индексу, а не делать полный поиск.


Создадим два индекса:
![[Pasted image 20241113121016.png]]

```SQL
analyze test1; - чтобы постгрес создал таблицу со статистикой
```
Статистика по созданной выше таблице test1;
![[Pasted image 20241113121103.png]]
![[Pasted image 20241113121110.png]]
relkind - тип. r - строки, S - serial, i - индекс. relpages - сколько страниц занимает. reltuples - сколько записей каждого типа.

Теперь, если сделать запрос и при фильтрации использовать индекс, то теперь будет использоваться индекс скан, а не фул скан, как раньше:
![[Pasted image 20241113121144.png]]В такое случае будет фул скан, так как нет смысла использовать индекс длс number1, если все равно нужно будет проверить каждую строку таблицу и посмотреть на ее value:
![[Pasted image 20241113121221.png]]Если мы выбираем только индекс, и никак не используем другие данныз таблицы, то запрос будет очень оптимальным, так как все данные которые нам были нужны для SELECT хранятся в нашем индексе и не нужно дополнительно идти и считывать данные из таблицы по этому индексу, т.е. не требуется доп чтение таблицы.

Index Only:
![[Pasted image 20241113121301.png]]

### Вариации Scan
Какие сканы бывают?
- Index Only - самый лучший. Когда задействуем только индекс, т.е. все необходимые данные хранятся в индексе и нам не нужно дополнительно запрос в таблицу со всеми данными. Индекс хранит номер страницы, в которой находится запись таблицы, с которой он связан.
- Index scan - дополнительно идем еще в таблицу, чтобы получить доп данные из таблицы, которых нет в индексе.
- bitmap scan(index scan, heap scan). Сначала использует index scan, чтобы определить какие страницы нам нужны для считывания. Как происходит ? Создается bitmap - т.е. просто множество 0 и 1: 000000000000000000000 - битов столько, сколько страниц занимает наша табличка. Далее благодаря index scan, 0 заменяются на 1 для тех номеров страниц, для которых значение number1 удовлетворяет условию(number1 же индекс, который хранит номер страницы по которому лежит запись в таблице). Далее на основе этой бит мап мы знаем какие номера страниц нужно считать и считываем их не по одному, а сразу батчем(т.е. множеством). Далее считываются страницы и происходит recheck(т.е. перепроверка, так как bitmap вернуло только страницы, в которых множество записей и часть из них может и не удовлетворять условию, поэтому происходит доп фильтрация).
![[Pasted image 20241113121435.png]]
Зачем это ? Чтобы избавиться от full scan и использовать наши индексы по максимуму. А почему бы не использовать просто index scan? Из-за того, что приходилось бы очень много раз обращаться к памяти, а тут за счет batch считывания(один раз считали все нужные данные) не нужно много раз обращаться.

### Мы разобрались с планом выполнения запросов при SELECT, но теперь давайте разберемся с планом выполнения запросов для JON

explain - только строит план выполнения, но не выполняет, но если мы хотим еще и выполнить, то добавляем analyze:
![[Pasted image 20241113121624.png]]
Вернется: Planning time - сколько времени планировщик потратил на планирование запроса, Execution time - сколько реально выполнялся запрос
![[Pasted image 20241113121645.png]]

### Что вернет explain analize для JOIN
![[Pasted image 20241113121758.png]]
Сначала выполнился Index Scan для таблицы на которую мы ссылаемся c помощью foreign key. Для таблицы test2 использовался full scan.

Дальше использовался Nested Loop, которы использовал таблицу test2 и индексы из таблицы test1.

Nested Loop и занимался связыванием наших таблиц.

Есть 3 варианта:

- Nested Loop - срабатывает, когда мало данных(например, LIMIT 100). Считывает одну таблицу полностью, а для второй использует индексы и связывает.
- Hash Join - считывает полностью и первую и вторую таблицу, но по одной из них строит HashMap и потом связывает.
- Merge Join - работает только на основании отсортированных ключей. Связка происходит как раз за счет того, что в обоих таблицах ключи отсортированы и можно идти по ключам и сравнивать их друг за другом.
    (Это для Merge Join)Сравниваем значение сверху и значение снизу и если равны, вот мы и нашли нашу связку для наших таблиц. Если снизу значение меньше, чем сверху, то значение снизу смещается на один элемент влево(т.е. 7 в данном случае уходит и на ее место встает 9, которая уже сравнивается с 8, дальше 8 уйдет. Две 9 будут равны = вот нашли еще одну сваязь и т.д.) Часто для того, чтобы срабатывал merge join создают индексы еще и на внешние ключи.
	![[Pasted image 20241113122031.png]]


Что делает Nested Loop ? Он идет по просканированной таблицы test2 по порядку. Взял первую строку, потом посмотрел на значение внешнего ключа, пошел в таблицу test1 и по этому ключу(индексу) нашел соответствующий id.

Если не ограничивать через LIMIT 100, то Nested Loop уже не используется:
![[Pasted image 20241113122158.png]]
Кратко, как работает: берет 1 таблицу полностью ее сканит и создает из нее Hash Таблицу(чтобы делать быстрый поиск). Затем берет вторую таблицу и тоже полностью ее сканит. И потом благодаря быстрому поиску по хеш-таблице он быстро может найти значения ключей для связки.

merge join - самый лучший вариант - срабатывает, когда все ключи в join отсортированы.