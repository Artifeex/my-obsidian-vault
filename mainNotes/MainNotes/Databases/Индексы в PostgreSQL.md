![[Pasted image 20241112140648.png]]
![[Pasted image 20241112140856.png]]
OLAP - для ML. Запросы в БД могут выполняться и часами.
### Команда для создания индекса 
![[Pasted image 20241112141005.png]]
![[Pasted image 20241112141222.png]]
Причем они настолько вошли в нашу жизнь, что в postgres при создании pk всегда создается индекс и мы не можем никак не создать его(это все под капотом делается).
![[Pasted image 20241112142151.png]]
Обычно соотношение операций чтения и записи 80% чтения и 20% записи. Поэтому замедление на вставку не так критично(замедление происходит из-за того, что нужно еще и в индексы также вставить запись, а это может быть бинарном дерево, например. Зависит от типа индекса). Причем, если у нас соотношение идет в другую сторону, т.е. записи больше, чем чтения, то лучше вообще не использовать реляционные БД, а смотреть на какие-то другие виды БД.

Дисковое пространство - индексы могут занимать больше места на диске, чем вся основная таблица. Это плохо, в идеале, чтобы они занимали половину объема таблицы или меньше.

bloat - пухнуть. В postgres, когда мы меняем данные они не мгновенно заменяются физически на диске. На самом деле создается просто новая версия данных и когда приходит время, то старые записи стираются и заменяются новыми. Это хорошо работает для таблиц, но вот индексы в этом плане не очень работают. Они не переиспользуют стертое пространство(т.е. те пустые места, которые остаются). Поэтому нужно пересоздавать индексы иногда.

![[Pasted image 20241112142730.png]]
- Тестовые окружения не соотвествуют реальности - может получиться так, что на тестовых данных запрос хуже работает, чем в реальности из-за каких-то особенностей.
- Обладать статистикой нагрузки - это важно, поскольку не всегда плохая работы с БД может быть из-за долгих запросов. Возможно, проблема в быстрых запросах, которых очень много.
- Иметь примеры запросов с параметрами
![[Pasted image 20241112143544.png]]
В БД есть планировщик и executor. Executor - берет и выполняет запрос. А планировщик на основе информации о наших таблицах, которая хранится в pg_stats по каждой таблице перебирает различные алгоритмы выполнения запроса.
В pg_stats много разных колонок, но нас сильнее всего будут интересовать 5 из них:
- n_distinct - уникальных значения в колонке.
- correlation - упорядоченность. Насколько упорядоченно по этой колонке идут значения. 
- null_frac - количество пустых значений в колонке. 
- most_common_vals и most_common_freqs - частые значения. Два массива, у которых в первом массиве по индексу "k" будет значение, а во втором по индексу "k" будет частота этого значения. 

БД собирает на самом деле не полную статистику по таблицу, а только по некоторому кусочку. Например, в postgres этот кусочек всего 30к записей. Его можно настраивать для каждой таблички отдельно. Это важно, поскольку может быть ситуация, что статистика была собрана по крайне неудачному sample данных, а т.к. планировщик запросов использует эту статистику, то все может начать работать плохо, хотя до этого работало хорошо. Это событие крайней редкое. Т.е. важно помнить о том, что статистика строится не по всей таблице!

### Типы индексов
![[Pasted image 20241112143740.png]]
Наиболее распространенный тип индексов, есть даже БД, в которых только btree индексы. Довольно старый! Он крут тем, что из-за того, что старый, то он вылизан практически до идеала и оптимизации, которые с ним происходят с каждым релизом очень незначительны(и то в угловых случаях). 


![[Pasted image 20241112143937.png]]
hash - медленнее btree, поэтому нет смысла его использовать. hash - только операции равенства, а раз нет операций сравнения, то никакой сортировки по hash индексу не сделать.


![[Pasted image 20241112144045.png]]
gist - в оснвоном полезен для тех, кто работает с геометрией. Расстояние посчитать, пересечения площадей и т.д.
pg_trgm - позволяет индексировать запросы поиска подстроки с помощью like. Т.е. можно делать быстрый поиск подстроки в строке с помощью этого расширения. Другие индексы такого не позволяют!
btree_gist - когда хотим положить на БД задачу создания каких-то расписаний и не хотим, чтобы интервалы этих расписаний пересекались. 

![[Pasted image 20241112144403.png]]
sp_gist - нигде не практике не встречался.

![[Pasted image 20241112144444.png]]
gin - может сильно просадить скорость записи на диск. Самый главный плюс - поиск значений внутри json. Т.е. мы можем хранить в БД по какому-то столбцу JSON и сделать очень быстрый поиск по этим значениям в JSON. 

![[Pasted image 20241112144727.png]]
Очень большое количество данных и они упорядочены по какому-то полю. То в таком случае, почти все движки БД достают данные блоками, а не строчка по строчке. И в таком индексе индексируется только индекс начала и индекс конца в этом блоке. А т.к. данные отсортированы, то, например, если мы ищем id = 3, а у нас есть блок, в котором начало id = 2 и конец id = 6, то между 2 и 6, скорее всего, будет id = 3(но это не точно, поэтому нужно будет сделать доп проверку). Т.е. мы не можем точно проверить, есть ли такой элемент или нет, но при этом это очень быстро, т.к. мы очень быстро можем определить блок, в котором нужно посмотреть, а сам блок не очень большой и уже внутри блока нам не составит труда пройти 5-10 записей и посмотреть на их id.

### Indexes null or not null
![[Pasted image 20241112145218.png]]
![[Pasted image 20241112145322.png]]
Хотим удалить из этой таблички запись с id = 10, по которому у нас есть btree индекс.
![[Pasted image 20241112145402.png]]
Мы можем заметить, что у нас поиск по index scan занял всего 0.043, но при этом самым долгим оказалась выполнения trigger, который проверяет, нет ли по foreign key какой-то записи(или другие constraint проверки).

Поэтому нужно не забывать создавать индексы и для FK(они по умолчанию не создаются):
![[Pasted image 20241112145919.png]]

Теперь для foreign_key также используется index
![[Pasted image 20241112150035.png]]
И большинство разработчиков на этом ускопоится, т.к. все стало работать хорошо.
Но мы можем вспомнить, что нам посмотреть посмотреть статистику:
![[Pasted image 20241112150235.png]]
null_frac - 93% практически для поля foreign key. И это то, за что мы должны зацепиться. Мы можем при создании индекса указать, что индекс нужно создать только для не null значений. Скорость работы это не улучшит, но уменьшит размер индекса.
![[Pasted image 20241112150347.png]]
В таком случае будет применен индекс:
![[Pasted image 20241112150923.png]]

![[Pasted image 20241112151141.png]]
На больших объемах еще и разница будет по времени для null и is not null индексах.


Вывод: то условие where при создании индексов может очень сильно улучшить работу и уменьшить размер индексов на диске + само время поиска из-за того, что банально индекс меньше и по меньшему числу данных нужно ходить.

### Indexes partial
Тот пример с where - это создание частичного индекса.
Пусть у нас теперь в табличке есть какое-то поле у записи - статус и мы часто будем хотеть ходить в табличку и работать с записями только с определенным статусом.
![[Pasted image 20241112151647.png]]
![[Pasted image 20241112151838.png]]

Иногда могут создавать такие странные индексы, думая, что он будет частичным. Но тут на самом деле индекс создается по результату выполнения операции state = 'ожидает'. Т.е. индекс будет по значению true, false, null. И для поиска это никак не поможет!
![[Pasted image 20241112152117.png]]

![[Pasted image 20241112152253.png]]
Причем надо обратить внимание на порядок. created_at - сначала идет, поскольку это поле имеет много уникальных значений и в таком случае это большой плюс для btree, т.е. оно лучше ложится на эту структуру.
![[Pasted image 20241112152312.png]]
![[Pasted image 20241112152332.png]]
![[Pasted image 20241112152400.png]]
Мы увидели в статистике, что обработано - занимает почти 90% записей. Но при этом мы с этими записями будем работать не очень часто, т.к. в основном мы будем вытаскивать для работы те записи, с которыми произошла ошибка или те, что ожидают выполнения. Поэтому мы сделаем частичный индекс по полю state из которого исключим все записи со значением "обработано".
![[Pasted image 20241112152631.png]]


В PostgreSQL существует несколько типов индексов, которые применяются для ускорения различных типов запросов. Индексы в базе данных создаются для того, чтобы делать поиск и сортировку данных более эффективными, но важно помнить, что они занимают место и замедляют операции вставки и обновления, так как эти операции требуют обновления индексов. Рассмотрим основные типы индексов, их применение и особенности.

### 1. B-Tree индексы
**Тип по умолчанию**. Этот тип индекса используется в большинстве случаев и поддерживает сравнения `=`, `<`, `<=`, `>`, `>=`. 

#### Применение
- Поиск по точным значениям: например, поиск по первичному ключу или по уникальному значению.
- Диапазонные запросы: например, запрос на выборку всех записей, где возраст от 20 до 30 лет.

#### Устройство
B-Tree (сбалансированное дерево) организует данные в виде древовидной структуры. Все узлы дерева отсортированы, и каждый узел имеет ссылки на "листья", которые содержат данные. Поиск по индексу происходит быстро, так как можно проходить дерево, пропуская незначимые для поиска узлы. 

### 2. Hash индексы
Этот тип индекса основан на хеш-таблице. В PostgreSQL Hash индексы поддерживают только операции `=` (равенство) и используются гораздо реже, чем B-Tree.

#### Применение
- Подходят для поиска по точному совпадению значений.
- Применимы, когда необходимо искать конкретное значение (например, по идентификатору или уникальному коду).

#### Устройство
Хеш-индекс организован как массив, где каждое значение проходит через хеш-функцию, которая определяет его позицию. В отличие от B-Tree, Hash индексы не поддерживают диапазонные запросы, так как значения не упорядочены, а распределены случайным образом. 

### 3. [[GiST]] индексы (Generalized Search Tree)
Этот индекс предназначен для более сложных типов данных и запросов. GiST индексы можно применять для работы с географическими, текстовыми и другими специализированными типами данных.

#### Применение
- Работа с географическими и геометрическими данными (поиск по близости).
- Поиск по текстам (например, индекс полнотекстового поиска).
- Сложные запросы с нетривиальными условиями (например, работа с диапазонами значений).

#### Устройство
GiST представляет собой обобщенную структуру, где каждый узел может включать любое количество значений и иметь свои правила сопоставления (включения/пересечения диапазонов). Он позволяет создавать индексы на основе кастомных правил и, по сути, является гибкой платформой для построения индексов под нестандартные запросы.

### 4. [[GIN]] индексы (Generalized Inverted Index)
GIN используется для индексации многозначных данных, таких как массивы или текстовые документы. 

#### Применение
- Полнотекстовый поиск (например, поиск слов в документе).
- Индексация массивов (например, если у нас есть массив тегов и мы хотим найти все записи, содержащие конкретный тег).

#### Устройство
GIN индекс строится по принципу инвертированного списка. Он создает индекс для каждого уникального элемента (например, каждого слова в тексте), а затем хранит ссылки на документы, в которых этот элемент содержится. Такой подход делает GIN идеальным для полнотекстового поиска и индексирования структур данных, в которых каждое поле может содержать несколько значений.

### 5. SP-GiST индексы (Space-Partitioned Generalized Search Tree)
SP-GiST предназначен для работы с данными, имеющими пространственную природу и разреженную структуру.

#### Применение
- Географические данные (например, поиск объектов на карте).
- Иерархические и сетевые структуры данных (например, деревья, графы).

#### Устройство
SP-GiST работает по принципу разбиения пространства (пространственная сегментация), где данные разделяются на части по специфическим правилам (например, на квадранты). Такой подход позволяет строить более эффективные индексы для пространственно разреженных данных.

### 6. [[BRIN]] индексы (Block Range INdex)
BRIN индексы применимы к очень большим таблицам, где данные расположены в порядке (например, по дате). Они эффективны для работы с временными данными.

#### Применение
- Работа с большими таблицами, где данные отсортированы по ключу.
- Доступ к данным, распределенным по блокам (например, индексация по временным меткам или порядковым номерам).

#### Устройство
BRIN индекс работает с блоками данных, а не с отдельными строками. Он хранит минимум и максимум значений для каждого блока. Это позволяет значительно экономить пространство, но может быть менее точным, чем другие индексы. BRIN индекс выполняет поиск быстро на больших объемах данных, где все значения находятся близко друг к другу.

### Примеры использования
Допустим, у нас есть таблица `employees` с полями `id`, `name`, `age`, `location` и `skills`.

- **B-Tree**: `CREATE INDEX ON employees(id);` — используется для поиска сотрудника по уникальному `id`.
- **Hash**: `CREATE INDEX ON employees USING hash(id);` — альтернативный способ создать индекс по `id`, но только для операций равенства.
- **GiST**: `CREATE INDEX ON employees USING gist(location);` — подходит для поиска ближайших сотрудников по географическому расположению.
- **GIN**: `CREATE INDEX ON employees USING gin(skills);` — если поле `skills` — массив, это ускорит поиск по содержимому массива.
- **SP-GiST**: `CREATE INDEX ON employees USING spgist(location);` — используется, если у нас сложная структура данных для `location`.
- **BRIN**: `CREATE INDEX ON employees USING brin(age);` — если в таблице много сотрудников, отсортированных по `age`, это ускорит диапазонные запросы по возрасту.

### Выбор типа индекса
Выбор индекса зависит от типов запросов и структуры данных:
- **B-Tree** — если требуется универсальный индекс для поиска по ключу.
- **Hash** — если нужен только поиск по точному совпадению.
- **GiST и SP-GiST** — если данные сложной структуры, например, географические.
- **GIN** — если нужно искать по множеству значений, например, текст или массивы.
- **BRIN** — для больших таблиц с отсортированными данными.

### Заключение
Каждый тип индекса имеет свои особенности, и их выбор зависит от целей и типов данных. В PostgreSQL индексы гибко настраиваются для улучшения производительности в конкретных задачах, и правильный выбор индексации может существенно улучшить скорость запросов и снизить затраты на вычисления.