https://habr.com/ru/companies/postgrespro/articles/333878/

GiST — сокращение от «generalized search tree». Это сбалансированное дерево поиска, точно так же, как и рассмотренный ранее b-tree.  
  
В чем же разница? Индекс b-tree жестко привязан к семантике сравнения: поддержка операторов «больше», «меньше», «равно» — это все, на что он способен (зато способен очень хорошо!). Но в современных базах хранятся и такие типы данных, для которых эти операторы просто не имеют смысла: геоданные, текстовые документы, картинки…  
  
Тут на помощь и приходит индексный метод GiST. Он позволяет задать принцип распределения данных произвольного типа по сбалансированному дереву, и метод использования этого представления для доступа по некоторому оператору. Например, в GiST-индекс можно «уложить» R-дерево для пространственных данных с поддержкой операторов взаимного расположения (находится слева, справа; содержит и т. п.), или RD-дерево для множеств с поддержкой операторов пересечения или вхождения.

### Устройство

GiST — сбалансированное по высоте дерево, состоящее из узлов-страниц. Узлы состоят из индексных записей.  
  
Каждая запись листового узла (листовая запись) содержит, если говорить в самом общем виде, некий _предикат_ (логическое выражение) и ссылку на строку таблицы (TID). Индексированные данные (ключ) должны удовлетворять этому предикату.  
  
Каждая запись внутреннего узла (внутренняя запись) также содержит _предикат_ и ссылку на дочерний узел, причем все индексированные данные дочернего поддерева должны удовлетворять этому предикату. Иными словами, предикат внутренней записи _включает_ в себя предикаты всех дочерних записей. Это важное свойство, заменяющее индексу GiST простую упорядоченность B-дерева.  
  
Поиск в дереве GiST использует специальную _функцию согласованности_ (consistent) — одну из функций, определяемых интерфейсом, и реализуемую по-своему для каждого поддерживаемого семейства операторов.  
  
Функция согласованности вызывается для индексной записи и определяет, «согласуется» ли предикат данной записи с поисковым условием (вида «_индексированное-поле оператор выражение_»). Для внутренней записи она фактически определяет, надо ли спускаться в соответствующее поддерево, а для листовой записи — удовлетворяют ли индексированные данные условию.  
  
Поиск, как обычно в дереве, начинается с корневого узла. С помощью функции согласованности выясняется, в какие дочерние узлы имеет смысл заходить (их может оказаться несколько), а в какие — нет. Затем алгоритм повторяется для каждого из найденных дочерних узлов. Если же узел является листовым, то запись, отобранная функцией согласованности, возвращается в качестве одного из результатов.  
  
Поиск производится в глубину: алгоритм в первую очередь старается добраться до какого-нибудь листового узла. Это позволяет по возможности быстро вернуть первые результаты (что может быть важно, если пользователя интересуют не все результаты, а только несколько).  
  
Еще раз обратим внимание, что функция согласованности не должна иметь какое-либо отношение к операторам «больше», «меньше» или «равно». Ее семантика может быть совершенно иной, и поэтому не предполагается, что индекс будет выдавать значения в каком-то определенном порядке.

Дальше мы рассмотрим несколько примеров индексов для разных типов данных и полезные свойства GiST:  
  

- точки (и другие геометрические объекты) и поиск ближайших соседей;
- интервалы и ограничения исключения;
- полнотекстовый поиск.
## R-дерево для точек

  
Продемонстрируем сказанное выше на примере индекса для точек на плоскости (похожие индексы можно построить и для других геометрических объектов). Обычное B-дерево не подходит для такого типа данных, так как для точек не определены операторы сравнения.  
  
Идея R-дерева состоит в том, что плоскость разбивается на прямоугольники, которые в сумме покрывают все индексируемые точки. Индексная запись хранит прямоугольник, а предикат можно сформулировать так: «искомая точка лежит внутри данного прямоугольника».  
  
Корень R-дерева будет содержать несколько самых крупных прямоугольников (возможно, даже пересекающихся). Дочерние узлы будут содержать меньшие по размеру прямоугольники, вложенные в родительский, в совокупности охватывающие все нижележащие точки.  
  
Листовые узлы, по идее, должны содержать индексируемые точки, однако тип данных во всех индексных записях должен совпадать; поэтому хранятся все те же прямоугольники, но «схлопнутые» до точек.  
  
Чтобы представить себе такую структуру наглядно, ниже приведены рисунки трех уровней R-дерева; точки представляют координаты аэропортов (аналогично таблице airports демо-базы, но здесь взято больше данных с сайта [openflights.org](https://openflights.org/data.html)).
![[Pasted image 20241113142007.png]]
_Первый уровень; видны два больших пересекающихся прямоугольника._
![[Pasted image 20241113142014.png]]
_Второй уровень; большие прямоугольники распадаются на области поменьше._
![[Pasted image 20241113142035.png]]
_Третий уровень; каждый прямоугольник содержит столько точек, чтобы они помещались на одну страницу индекса._

Рассмотрим теперь подробнее совсем простой «одноуровневый» пример:
![[Pasted image 20241113142046.png]]
postgres=# create table points(p point);  
CREATE TABLE  
postgres=# insert into points(p) values  
  (point '(1,1)'), (point '(3,2)'), (point '(6,3)'),  
  (point '(5,5)'), (point '(7,8)'), (point '(8,6)');  
INSERT 0 6  
postgres=# create index on points using gist(p);  
CREATE INDEX
![[Pasted image 20241113142104.png]]
Созданный индекс может использоваться для ускорения, например, такого запроса: «найти все точки, входящие в заданный прямоугольник». Это условие формулируется так: `p <@ box '(2,1),(6,3)'` (оператор `<@` из семейства points_ops означает «содержится в»):

![[Pasted image 20241113142215.png]]
Поиск начинается с корневого узла. Прямоугольник (2,1)-(7,4) пересекается с (1,1)-(6,3), но не пересекается с (5,5)-(8,8), поэтому во второе поддерево спускаться не нужно.
![[Pasted image 20241113142221.png]]

Придя в листовой узел, перебираем три содержащиеся там точки и две из них возвращаем в качестве результата: (3,2) и (6,3).