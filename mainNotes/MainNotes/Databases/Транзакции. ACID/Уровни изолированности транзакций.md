Данные уровни решают проблемы, связанные с [[Проблемы изолированности транзакции]].
![[Pasted image 20240927134313.png]]
Т.е. уровни изоляции:
- SERIALIZABLE
- REPEATABLE READ
- READ COMMITED - видим в другой транзакции только те данные, которые закоммичены. Т.е. Другая транзакция, если сделала обновления, но не сделала commit, то мы не увидим эти обновления.
- READ UNCOMMITED

Каждый последующий уровень изоляции решает те же проблемы, что и предыдущий + свои. Т.е. когда мы откроем, например, транзакцию с уровнем изоляции READ COMMITED, то у нас никогда не будет проблем с “Грязным” чтением.

Каждый новый уровень изоляции все сильнее ограничивает многопользовательское обращение к нашим БД, что будет влиять на производительность и работать будет медленнее.
В случае Serializable мы в принципе не можем работать с одной таблицей из разных клиентов в один момент времени. Блокируем полностью всю таблицу на которой делаем чтение.

В постгресс определены только 3 уровня изолированности. В нем нет READ UNCOMMITED уровня, т.е. по дефолту используется READ COMMITED. Поэтому невозможно получить проблему изолированности [[Lost Update]].
![[Pasted image 20240927134609.png]]

Для старта транзакции в консоли нужно написать begin.
`show transation isolation level` показывает текущий уровень изолированности транзакций.

### Работаем с Read Commited
![[Pasted image 20240927135229.png]]
Сначала выполнили то, что слева: изменили данные внутри транзакции, но еще не закомитили их. Потом во второй консоли тоже открываем транзакцию и видим, что “грязное” чтение **не** произошло, считались старые данные и то, что мы сделали обновление в транзакции слева никак не повлияло на данные полученные транзакцией справа.
### Получение проблемы Nonrepeatable Read
![[Pasted image 20240927135344.png]]
Прочитали данные в транзакции справа 1 раз. Потом обновили данные в транзакции слева и сделали commit. Повторное чтение на транзакции справа вернуло другие данные. Вот и воспроизвели проблему.

Для решения проблемы мы просто должны поднять уровень изолированности до Repeatable Read
![[Pasted image 20240927135421.png]]

![[Pasted image 20240927135443.png]]Теперь при повторном чтении, несмотря на изменения в транзакции слева, в транзакции справа читаются те же данные, что и до обновления, таким образом, мы решили эту проблему.

Для решения этой проблемы на уровне repeatable read происходит snapshot изоляция, т.е. берется копия тех данных, которые считывались в текущей транзакции и в последующем селекте мы видим копию этих данных. Чем больше данных мы выбрали в рамках текущей транзакции, тем больше копий произошло. Следовательно, не нужно делать больших транзакций с большим количеством изменений, потому что это затратно.

### Non repeatable read with last win
Non repeadable read with last win решается так же(напомню, что проблема состоит в том, что прав должен быть тот, кто первым сделал коммит, а не тот, кто последним,т.е. последний коммит не должен перетирать первый).
![[Pasted image 20240927135744.png]]
После commit на первой транзакции, на транзакции 2(справа) вылазит ошибка. И все что остается, так это делать ROLLBACK.

### Фантомное чтение
![[Pasted image 20240927135846.png]]
Внутри одной транзакции разное количество записей.
Решение: открывать транзакцию на уровне изоляции serializable:
![[Pasted image 20240927135927.png]]
Здесь так же используются snap shot.

Более того, вместо повышения уровня изоляции транзакций мы можем использовать row level lock - мы можем заблокировать строки, которые у нас вернулись с помощью селкета с помощью row level lock. Бывают и другого уровня lockи, например, на всю таблицу(просто нужно об этом знать, но используются нечасто).
Благодаря этому, все транзакции, которые захотят обновить данные строки будут ожидать.
![[Pasted image 20240927140002.png]]

