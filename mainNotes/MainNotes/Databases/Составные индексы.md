Составные индексы предоставляют возможность объединить в одной структуре несколько столбцов таблицы, оптимизируя таким образом доступ к данным при фильтрации по нескольким полям. Вот простой пример создания составного индекса в SQL:
`CREATE INDEX idx_compound ON tablename (column1, column2);`

Порядок колонок важен, поскольку он влияет на эффективность поисков, но при этом, даже если мы создали индекс по столбцам (a, b, c), но в запросе использовали только (b,c) или еще какое-либо подмножество (a,b,c), то составной индекс выполнится, но при этом будет не очень эффективным.  Это справедливо в том случае, если составной индекс - это B-tree.
Индекс является наиболее эффективным в ограничениях при поиске по левым колонкам. Т.е. в идеале, чтобы в фильтрующих запросах участвовал наиболее левый столбец, т.к. как я понял, такие индексы строятся следующим образом:
Например, создаем составной индекс:
CREATE INDEX idx_compout ON index_table (a, b, c):
1. Строится B-Tree по столбцу а(в идеале столбец а должен обладать большой селективностью, чтобы индекс был эффективным)
2. Внутри B-tree индекса по столбцу "а", у каждого листочка дерева будет ссылка на B-tree дерево, которое будет построено по столбцу "b". 
Но еще важно, что при запросе при фильтрации нужно, чтобы элементы индекса соединялись через оператор AND. 
