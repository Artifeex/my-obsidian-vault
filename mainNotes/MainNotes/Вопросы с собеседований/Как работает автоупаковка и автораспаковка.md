Автоупаковка (**autoboxing**) и автораспаковка (**unboxing**) — это автоматические преобразования между примитивными типами (например, `int`, `double`) и их объектными обертками (`Integer`, `Double` и т.д.), которые добавили в Java начиная с версии 5. Эти механизмы упрощают код и делают его более читаемым, устраняя необходимость в явных вызовах конструкторов или методов.

---

### **1. Автоупаковка (Autoboxing)**

Автоупаковка происходит, когда примитивный тип автоматически преобразуется в объектную обертку. Это удобно, например, при добавлении примитивных значений в коллекции, такие как `List<Integer>`.

**Пример:**

```java
int x = 10;
Integer y = x; // Автоупаковка: примитив int упаковывается в объект Integer
```

**Что происходит под капотом:**

- Компилятор преобразует код с автоупаковкой в эквивалентный код, где используется метод **`valueOf`** обертки.
- Пример кода выше компилируется как:
    
    ```java
    Integer y = Integer.valueOf(x);
    ```
    
- Метод **`valueOf`** использует кэш для значений от `-128` до `127`. Для этих значений возвращается уже существующий объект из кэша, что улучшает производительность.

---

### **2. Автораспаковка (Unboxing)**

Автораспаковка происходит, когда объектная обертка автоматически преобразуется в примитивный тип. Это полезно, например, при выполнении математических операций с объектами-обертками.

**Пример:**

```java
Integer y = 10;
int x = y; // Автораспаковка: объект Integer распаковывается в примитив int
```

**Что происходит под капотом:**

- Компилятор преобразует код с автораспаковкой в эквивалентный код, где вызывается метод **`intValue`** (или аналогичный метод для других типов).
- Пример кода выше компилируется как:
    ```java
int x = y.intValue();
    ```
### **Итог**
Автоупаковка и автораспаковка работают через вызовы методов оберток (`valueOf`, `intValue`, и т.д.). Они делают код более читаемым, но могут влиять на производительность и создавать некоторые логические ловушки (например, при работе с `null` или использованием `==`). Важно понимать, как они работают, чтобы избегать ошибок и оптимизировать код.
