Хотим заинжектить значение в поле в классе, который сам по себе как раз и включает возможность инжекта через @Value(этим занимается PropertySourcePlaceholderConfigurer)
![[Pasted image 20241028210827.png]]
В таком варианте все будет работать, но, что будет, если убрать static в методе объявления бина PropertySourcePlaceholderConfigurer.

Не сработает PostConstruct и никакие другие аннотации. Почему? Потому что PropertySourcePlaceholderConfigurer - это BeanFactoryPostProcessor, т.е. это такой бин, который создается в самом начале запуска приложения. А как мы можем вызвать НЕСТАТИЧЕСКИЙ метод configurer(), который и занимается созданием BeanFActory? Никак, нужно сначала создать бин Conf. Но создается он в самом начале, когда еще нет вообще ничего, т.к. он создаваться начал только из-за PropertySourcePlaceholderConfigurer, поскольку он является BeanFactoryPostProcessor. Поэтому никакие аннотации Spring для Conf не будут работать! А вот когда мы объявляли этот метод как static, то все хорошо, т.к. для создания бина PropertySourcePlaceholderConfigurer мы можем использовать статический метод и не нужно создавать бин для Conf, чтобы вызвать нестатический метод, как это было в ситуации выше!

Но уже необязательно создавать бин для PropertySourcePlaceholderConfigurer(начиная со Spring 4.3)

Но информация о статических бинах все равно актуальная! 
### Вывод - для каких-то бинов внутри Config класса, которые являются BeanFactoryPostProcessors нужно использовать static методы


### Новый способ создания Listenerov:
![[Pasted image 20241028212916.png]]


