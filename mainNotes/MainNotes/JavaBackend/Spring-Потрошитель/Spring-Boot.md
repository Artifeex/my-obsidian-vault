Spring-Boot решает конфликты версий. 
![[Pasted image 20241029092618.png]]
Внутри spring-boot-dependencies находится блок dependencyManagement. При помощи него можно указать версии, которые будет использоваться в том случае, если мы явно не указываем версию. 

SpringBoot работает со своими стартерами. Идея стартера в том, что мы ставим на него зависимость и он агрегирует те зависимости, которые нужны для того мира из которого он пришел. Например, если мы хотим Security, то стартер будет включать в себя все необходимые зависимости для работы с Security.

### Настройка контекста
До SpringBoot нам нужно было настроить в @Configuration файле кучу различных инфраструктурных бинов. Например, для Hibernate нужен был EntityManagerFactoryBean, Datasource и т.д. И все это нужно было настраивать руками.

 Теперь же мы просто пишем такой main:
![[Pasted image 20241029093357.png]]
Но где контекст? 
![[Pasted image 20241029093439.png]]
![[Pasted image 20241029093515.png]]

### Виды контекстов
![[Pasted image 20241029093744.png]]
![[Pasted image 20241029093810.png]]

В SpringBoot же всего 2 вида контекста: ![[Pasted image 20241029093824.png]]
![[Pasted image 20241029093915.png]]
Что будет внутри контекста?
Внутри уже будет приличное количество созданных конфигурационных бинов.
Откуда они взялись? Как раз из стартеров, которым требуются какие-то конфигурационные бины. 

### Написание своего стартера
Задача: хотим, чтобы при поднятии контекста в консоль выводилось "отправляем ворона"
1. Создадим отдельный модуль для нашего стартера(просто модуль).
2. Создадим Listener, который будет слушать RefreshedEvent и он и будет выводить эту информацию.
   ![[Pasted image 20241029094841.png]]
3. Создадим Configuration класс в котором создадим Bean для нашего Listenera.
   ![[Pasted image 20241029094857.png]]
Теперь появляется вопрос, а как при подключении нашего модуля в зависимостях автоматически создался IronConfiguration, а, следовательно, и RavenListener?

Для этого будем использовать spring.factories - в нем указываем соответствие интерфейсов и их имплементаций. Интерфейсов и того, что нужно подгрузить. 
![[Pasted image 20241029095330.png]]
Содержимое spring.factories:
![[Pasted image 20241029095356.png]]

После этого в dependency добавляем зависимость и все заработает.
### Как это работает?
Все работает благодаря @SpringBootApplication
До SpringBoot, когда мы создавали контекст, то мы передавали внутрь либо XML, либо какой-то другой класс, который помечен аннотацией @Configuration.

Со SpringBoot мы делаем тоже самое, когда запускаем SpringBoot.run(class) мы передаем наш класс, который помечен аннотацией @SpringBootApplication. А внутри она как раз является @Configuration. 
![[Pasted image 20241029095839.png]]
Также внутри @SpringBootApplication есть @ComponentScan, которая сканирует все пакеты и все подпакеты. Поэтому работают все сканирования.

И также тут появляется интересное, чего не было в нашем обычном приложении без @SpringBoot - это @EnableAutoConfiguration.
![[Pasted image 20241029100019.png]]

Так что же делает аннотация @EnableAutoConfiguration
![[Pasted image 20241029100046.png]]
Главная ее задача сделать @Import класса.
![[Pasted image 20241029100207.png]]
![[Pasted image 20241029100253.png]]Т.е. этот класс ImportSelector протаскивает все зависимости подключенных стартеров в наш контекст. Т.е. как раз этот ImportSelector ищет класс spring.factories и смотрит, что передано в строке EnableAutoConfiguration внутри этого файла. Там мы как раз для нашего личного стартера прописали наш класс @Configuration.

Как раз для того, чтобы читать файлик spring.factories внутри ImportSelectora есть SpringFactoriesLoader, который этим и занимается.
![[Pasted image 20241029100500.png]]

Т.е. подводим небольшой итог. В каждом стартере есть класс spring.factories, который описывают, что этот стартер несет(какие конфигурации). А в SpringBoot есть механизм, который умеет ходить по подключенным стартерам, смотреть spring.factories и то, что в нем написано подключать в наш проект.

Внутри spring.factories может быть много строчек с подключением AutoConfiguration
![[Pasted image 20241029100807.png]]

Тогда сразу поялвяется вопрос, раз есть так много AutoConfigurations, которые будут автоматически создаваться, то это же жесть. Зачем мне, например, RabbitAutoConfiguration(она в spring-boot-autoconfigure), если я не собираюсь ей пользоваться? Но тут на помощью приходит @Conditional, который как раз поможет откинуть часть ненужных автоконфигураций, которые автоматически тянутся при использовании spring-boot-autoconfigure.
![[Pasted image 20241029101104.png]]

Например, ставим условие, что RavenListener Bean должен создаться только при некотором условии. Тогда создаем аннотацию и вешаем ее над методом создания бина:
![[Pasted image 20241029101729.png]]
![[Pasted image 20241029101846.png]]
![[Pasted image 20241029101922.png]]

Т.е. чтобы написать свой @Conditional нам нужно создать класс, который реализует интерфейс Condition, в котором он и решает - создавать или нет. И передать этот класс в @Conditional аннотацию.

А сколько раз вызывается проверка на Conditional? Т.е. если мы нашу Conditional аннотацию, которую мы создали навесили несколько раз на разных бинах в разных классах.
![[Pasted image 20241029102340.png]]
Правильный ответ - 300 или 400. 
![[Pasted image 20241029102539.png]]

### При написании стартера еще возникает потребность уметь настроить бины через application.properties. Т.е. когда мы создаем bean, например, Datasource. То нужно откуда-то взять информацию для подключения БД(из как раз application.prorepties), а если такой информации там нет, то какие-то дефолтные значения
А чем написанный нами стартер хуже? Мы тоже хотим иметь такую возможность.
![[Pasted image 20241029103130.png]]
![[Pasted image 20241029103158.png]]
![[Pasted image 20241029103207.png]]
@ConditionalOnProperty - нужен как раз для того, чтобы Bean создался в том случае, если есть какая-то конкретная property(значение или в целом просто есть).

Создаем класс для @ConfigurationProperties и указываем какой в application.yaml будет root для задания значения для полей(т.е. чтобы задать значения для куда нужно ворон.куда: )
![[Pasted image 20241029103735.png]]
Включаем возможность автоконфигураций для нашего IronConfiguration(С помощью EnableConfigurationProperties мы по сути говорим Spring создать Bean, используя RavenProperties, который заполняется из application.yaml)
![[Pasted image 20241029103531.png]]

И теперь можем добавить COnditionalOnProperty в котором как раз прописать, что должно быть задано property ворон.куда, иначе мы не будем создавать Bean RavenListener.![[Pasted image 20241029105130.png]]


### Если нам не нравится тот bean, который нам приносит стартер, то мы можем сделать условие, что наш bean из стартера будет создаваться в том случае, если такого bean еще нет в контексте. Это позволит пользователю, который подключает наш стартер иметь возможность написать свой bean определенного класса, а если он не хочет и ему достаточно того, что мы предложили, то использовать его. Для этого и нужно @ConditionalOnMissingBean![[Pasted image 20241029105353.png]]

 ![[Pasted image 20241029105716.png]]
 
### В объект Environment собираются всевозможные различые проперти. Этот объект Environment - это единственное, что существует на этапе, когда SpringBoot начинает строить контекст. 
 ![[Pasted image 20241029113315.png]]

Сначала строится Environment, который обрабатывается EnvironmentPostProcessors, каждый из которых может докидывать в него необходимое. Потом может выполнятся ApplicationContextInitializer, в который передается контекст, в котором пока нет никаких бинов, но есть Environment, который сформировался ранее через EnvironmentPostProcessors. И мы можем внутри этого ApplicationContextInitializer проверить, есть ли в Environment какие-то поля, например, профили. 

![[Pasted image 20241029120145.png]]
Как видим - жизненный цикл Spring приложения - это всего лишь часть SpringBoot.
Таким образом, мы нажали запуск приложения, вызвался Event ApplicationStartingEvent, его отловил слушатель и начал вызывать EnvironmentPostProcessors, которые должны были сконфигурировать Environment. Например, можно в Environment добавить в EnvironmentPostProcessors активные профайлы по каким-то условиям. После того, как все EnvironmentPostProcessors отработали, то работают ApplicationContextInitializers - к ним приходит ApplicationContext, в котором пока что нет ни бинов, ни beanfactory, ни beanDefinitions. В нем есть только Environment. И мы внутри этих ApplicationContextInitializers может что-то делать с Environment, например, проверять активность каких-то профайлов и в том случае, если нет какого-то нужного активного нам профайла, то остановить поднятие контнейнера, выбросив исключение. После этого, когда отработали все ApplicationContextInitializers уже начинает работать жизненный цикл бинов.
### Как запускать?
![[Pasted image 20241029120444.png]]
![[Pasted image 20241029121237.png]]

![[Pasted image 20241029121312.png]]
![[Pasted image 20241029121353.png]]
![[Pasted image 20241029121441.png]]Тот Spring-maven-plugin помимо создания самого jar прописывает в Manifest MAIN-ClAss, который как раз нужен для того, чтобы можно было запустить наше приложение. А это некоторый JarLauncher, у которого 2 задачи: запустить наш main, в котором мы писали @SpringBootApplication, а также прописать classpath, откуда взять все зависимости. Ведь, чтобы можно было запустить jar с помощью java -jar нам нужен jar, в котором будут зависимости.
В BOOT-INF есть libs и classes(здесь находятся классы, которые мы написали в нашем приложении). Все остальные зависимости спринга падают в BOOT-INF/libs.

![[Pasted image 20241029122032.png]]

Таким образом, SpringBoot решает проблемы:
1. Зависимости
2. Конфигурации
3. Запуск
