### Обработка аннотаций Spring в наследниках
![[Pasted image 20241028133628.png]]
Правильный ответ - E.
Аннотации при наследовании не переходят! Это задача фреймворка решить, где он будет их искать. 
В данном случае будет вызвано 2 метода(метод init в Son не переопределяет родительский, поскольку private методы переопределить нельзя. Их тупо не видно. А вот если какой-нибудь protected, а мы потом переопределили до public, то переопределение будет). Почему? Потому что Spring решил, что рекурсивно будет идти от потомка до класса Object, получать все объявленные поля и смотреть их аннотации. И в данном случае, он пошел по иерархии вверх и вызвал два метода с @PostConstruct.


### Если мы в BeanPostProcessor в методе postProcessBeforeInitialization вернем proxy, то, т.к. это другой класс уже(прокси), а не наш изначальный, то информация об аннотациях будет потеряна, поэтому @PostConstruct не сработает, т.к. данный метод вызывается после всех PostProcessBeforeInitialization
![[Pasted image 20241028135325.png]]

### Есть еще такой контракт в Spring, что init метод(@PostConstruct) должен работать уже с полностью готовым объектом, в котором есть все зависимости. Т.е. если BeanPostProcessor настраивает Bean, то используем beforeInitialization, а если добавляет какое-то поведение через proxy, то afterInitialization

### Вложенные транзакции
![[Pasted image 20241028140853.png]]
![[Pasted image 20241028140827.png]]
Правильный ответ - А. 

Объяснение на более простом примере:
![[Pasted image 20241028141121.png]]
Будет всего одна транзакция, несмотря на то, что вызывается метод infomAboutPayment с @Transaction(REQUIRED_NEW)
Это происходит потому что вызов метода informAboutPayment происходит не через proxy, который мы создали. Вызов метода pay происходит через Proxy, поэтому транзакция открылась, А ДАЛЬШЕ вызвался метод уже оригинального объекта!!! Т.е. уже вызывается метод pay, которые никак не проксирован, это прям тот метод, который мы написали. И внутри нашего метода мы вызываем еще один наш метод(не прокси!!! А именно наш, поскольку мы итак находимся внутри нашего метода). И получается, что вызов второго метода был не через proxy! Поэтому и не открылась еще одна транзакция, т.к. не было вызова через proxy, который обрабатывал бы нашу аннотацию @Transactional.
![[Pasted image 20241028141412.png]]

И это не только касается транзакия, например, в AOP может быть такое, что мы хотим добавить функционал, который будет бенчмаркать метод, и внутри этого метода вызывается еще один метод объекта, который также должен бенчмаркаться. И вот бенчмарка второго метода не произойдет, поскольку он также не был вызван через proxy, а был вызван внутри оригинального метода.

### Как починить???
Сделать self-inject(создать поле в нашем классе, в которое должен заинжектиться я, но на самом деле уже не я, а прокси, который создастся) и через вот этот мой же прокси я хочу вызвать нужный мне метод.  
Для этого напишем свою аннотацию @SelfAutowired: ![[Pasted image 20241028142353.png]]
![[Pasted image 20241028142424.png]]
Напишем BeanPostProcessor, который будет обрабатывать нашу аннотацию:
![[Pasted image 20241028142711.png]]
![[Pasted image 20241028143138.png]]
И еще важно, чтобы наш BeanPostProcessor выполнился самым последним, т.к. мы же хотим работать уже с самым последним proxy. Т.к. каждый прокси добавляем функционал и если мы сделаем selfInject не самого последнего прокси, то какой-то функционал может быть не выполнен.
Поэтому реализуем у BeanPostProcessor еще и интерфейс Ordered, в котором указываем значение такое, чтобы выполниться самым последним в списке BeanPostProcessors:
![[Pasted image 20241028143351.png]]

Начиная со Spring 4.3 Self-Inject можно делать через @Autowired.

### Разогревание кэша
Хотим, чтобы при создании JokerConfService у нас разогрелся кэш(т.е. сходилось в БД и что-то положилось в кэш, чтобы потом уже, когда приложение полноценно начнет работу, то кэш уже был разогрет). Поэтому еще дополнительно навешана аннотация @Transactional(мы же хотим поработать с БД)
![[Pasted image 20241028143424.png]]
![[Pasted image 20241028143711.png]]
Почему? Потому что когда вызвался init(), то по контракту со спрингом мы договорились, что никаких прокси еще не будет(они будут уже после init при вызове postProcessAfterInitialization). А мы знаем, что именно через proxy мы и реализовывали функционал открытия транзакций при использовании @Transactional.

Решение - создать свою аннотацию и реализовать самим. 
![[Pasted image 20241028144056.png]]
Для этого создаем свой Listener, который будет слушать RefreshedEvent(события, которые происходят с ApplicationContext(подробнее в [[Spring-потрошитель]])). 
ContextRefreshedEvent - происходит, когда ApplicationContext полностью построился и рефрешнулся. 
![[Pasted image 20241028144145.png]]
Так мы делаем, если хотим, чтобы метод был после proxy, но при этом типо init методы.


![[Pasted image 20241028144755.png]]
Почему нет? Потому что мы не можем понять, что вернет метод, пока его не вызовем. Т.е. мы никак не можем узнать, что вернется String. Мы же могли потенциально и наследника вернуть!!! И это проблема только Java Configa. В остальных вариантах написания BeanDefinition(XML, Annotations) все будет хорошо.

Вот как можем починить! В BPP можем засунуть класс бина, он ведь уже был создан. 
![[Pasted image 20241028145408.png]]

### Почему нужно использовать интерфейсы?
У Spring при создании Proxy - два варианта. Либо использовать dynamic proxy, либо cglib(наследование). Spring не любит cglib proxy(final классы от которых нельзя наследоваться, работает в 2.5 раза медленнее, чем dynamic proxy, объекты cglib занимают много места в памяти). 

Как Spring решает, что использовать? Если в классе есть хотя бы 1 интерфейс, в котором есть хотя бы 1 метод, то будет использоваться dynamic proxy! При этом важно, чтобы был хотя бы 1 метод в интерфейсе!!! Если, например, использовать Serializable, то там нет методов в интерфейсе, поэтому Spring будет использовать cglib для proxy. А вот если добавить какой-нибудь Comparable, в котором уже есть метод для переопределения, то Spring создаст dynamic proxy.

Так почему нужно использовать интерфейсы? Потому что в один момент может получиться, что нам потребуется реализовать какой-то интерфейс, а это приведет к тому, что Spring создаст dynamic proxy, а это, значит, что мы уже не сможем через appilcationContext.getBean() найти наш bean, т.к. наш класс потеряется, поскольку использовался dynamic proxy, который просто создал еще один класс у которого интерфейсы, как у оригинального объекта, который оборачивается proxy. 
![[Pasted image 20241028150531.png]]

### Создаем один bean в 3-х различных местах. В XML, через аннотацию, через Configuration
![[Pasted image 20241028151035.png]]
Правильный ответ - B
Потому что мы в XML не указали id бина, поэтому там возьмется в качестве id полный путь до класса#0. В аннотации @Service мы также не написали id, но там уже возьмется по имени класса с маленькой буквы, поэтому id в классе с @Service не совпадет с id из XML. Поэтому создается еще один бин. А вот уже в третий раз, где мы в Config написали @Bean, то там уже совпадет id с из @Service. Поэтому Bean не будет создан.

Также стоит заметить, что XML сильнее Annotation.

 
 
 ![[Pasted image 20241028153547.png]]
 Правильный вариант - D![[Pasted image 20241028153803.png]]
 Методы PostConstruct не могут ничего принимать. Поэтому метод гретьВоду все поломает.
 
 Убираем теперь PostConstruct над методом гретьВоду![[Pasted image 20241028153943.png]]
 Правильный вариант - А.![[Pasted image 20241028154118.png]]
 Метод с @Autowired срабатывает, поскольку Bean использует эту аннотацию для инжекта. А мы можем инжектить в поле, в конструктор и в сеттер. Вот и считается, что как будто произошел вызов сеттера, Spring не смотрит, что название метода не начинается на set.

![[Pasted image 20241028161359.png]]


Exception будет из-за @Autowired с @JekaQualifier. Он будет искать все бины с типом String и @JekaQualifier. Но бинов типа String нет, есть только List< String> с таким @JekaQualifier.
![[Pasted image 20241028162143.png]]

![[Pasted image 20241028162913.png]]

![[Pasted image 20241028163512.png]]Причина - Spring воспринимает Qualifier как &. Т.е. если мы в Autowired указали несколько Qualifier, то заинжектится только то, что удовлетворяет сразу всем переданным Qualifier.
![[Pasted image 20241028163733.png]]Когда вы создаёте свою собственную аннотацию и помечаете её как `@Qualifier`, вы фактически создаёте именованный квалификатор для бинов, что позволяет упростить выбор конкретного бина при автосвязывании и повысить читаемость кода.

### Как это работает?

Аннотация `@Qualifier` не обязательно должна использоваться в коде напрямую. Вместо этого вы можете создать свою аннотацию, которая будет включать `@Qualifier`, и затем использовать её, чтобы маркировать бины. Это полезно в следующих случаях:

1. **Упрощение читаемости и организации кода**. Вместо использования строкового идентификатора вы создаёте более семантичную аннотацию, которая ясно указывает, для чего предназначен бин.
2. **Избежание магических строк**. Так как в `@Qualifier` обычно передаётся имя бина в виде строки, использование собственной аннотации помогает избежать ошибок, связанных с ошибками в строковых идентификаторах.
3. **Повторное использование конфигурации**. Если один и тот же бин используется в разных местах, ваша аннотация позволяет избежать повторения `@Qualifier` с одинаковым значением.

### Пример реализации

Предположим, что у нас есть аннотация `@DogQualifier`, которая используется для пометки конкретных бинов типа `Animal`.

#### Создание аннотации

```java
import org.springframework.beans.factory.annotation.Qualifier;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Qualifier
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
public @interface DogQualifier {
}
```

Здесь:
- `@Qualifier` делает вашу аннотацию квалификатором.
- `@Target` указывает, что аннотацию можно использовать над полями, параметрами методов и классами.
- `@Retention(RetentionPolicy.RUNTIME)` говорит, что аннотация должна быть доступна во время выполнения.

#### Применение аннотации к классу бина

Теперь можно использовать `@DogQualifier` над классом бина:

```java
@DogQualifier
@Component
public class Dog implements Animal {
    @Override
    public void speak() {
        System.out.println("Woof!");
    }
}
```

#### Использование аннотации при автосвязывании

Когда необходимо внедрить бин, помеченный `@DogQualifier`, используем эту аннотацию в месте внедрения:

```java
@Component
public class AnimalService {

    private final Animal animal;

    @Autowired
    public AnimalService(@DogQualifier Animal animal) {
        this.animal = animal;
    }
}
```

Здесь Spring использует `@DogQualifier`, чтобы понять, что нужно внедрить бин `Dog`, даже если в контексте приложения есть другие бины типа `Animal`.

### Преимущества подхода

1. **Читаемость** — код становится более семантичным и легко читаемым.
2. **Избежание магических строк** — уменьшает вероятность ошибок, связанных с использованием строковых идентификаторов.
3. **Легкость в сопровождении** — изменения квалификатора в одном месте автоматически распространяются по коду, где эта аннотация используется.

Таким образом, использование кастомной аннотации с `@Qualifier` над классом позволяет добиться более чистого и поддерживаемого кода.

