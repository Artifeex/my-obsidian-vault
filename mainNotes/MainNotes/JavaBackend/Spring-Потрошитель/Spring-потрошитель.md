![[Pasted image 20241028090403.png]]

### XmlBeanDefinitionReader 
Внутренний компонент Spring, используя для сканирования xml и все, что мы в нем пишем переводит в BeanDefinition.

Создаем ClassPathXmlApplicationContext, который поднимает ApplicationContext, используя XmlBeanDefinitionReader.
![[Pasted image 20241028091111.png]]
Мы написали описание бинов в XML, после этого прилетает XmlBeanDefinitionReader и считывает XML и создаем на его основе BeanDefinitions, которые описывают то из какого класса создавать бин, значения для полей и т.д. И кладет все это в BeanFactory в Map, где id - это ключ, а значение - beanDefinition.

И потом BeanFactory на основе BeanDefinition создает объекты и складывает бины в IoC Container. Важно знать, что все singleton бины создаются при поднятии контейнера и кладутся в контейнер. А prototype создаются в тот момент, когда они нужны(когда попросили) и НЕ кладутся в контейнер.
Это важно для Destroy методов, потому что они вызываются только у singleton бинов, т.е. при окончании работы контейнера Spring проходится по списку бинов, которые сохранены в контейнере и вызывает у них destroy метод(если его добавили). А т.к. prototype бины не хранятся в IoC, то у них и не вызывается destroy метод.

### BeanPostProcessor
Позволяет настраивать бины до того, как они попали в IoC Container. Здесь задействован паттерн ChainOfResponsibility.

Например, в нашем проекте все по-разному получают случайные числа. Кто-то один метод, кто-кто другой. А мы решили, что давайте сделаем аннотацию @InjectRandomInt, которую будем вешать над field, в который нужно заинжектить рандомный int. И обучим Spring, чтобы он обрабатывал данную аннотацию. Для этого как раз и можно использовать BeanPostProcessor для донастройки бина.
![[Pasted image 20241028092024.png]]
 ![[Pasted image 20241028092414.png]]
 
 Есть некоторая конвенция по названию BeanPostProcessor. Например, PostProcessor, который занимается обработкой аннотации Autowired называется AutowiredAnnotaionBeanPostProcessor.

Для обработки созданной аннотации создаем класс и реализуем интерфейс BeanPostProcessor.
![[Pasted image 20241028092640.png]]
У интерфейса BeanPostProcessor есть два метода:
```java
//Вызывается до init()(который @PostConstruct) метода
Object postProcessBeforeInitialization(Object bean, String beanName);
//Вызывается после init() метода
Object postProcessAfterInitialization(Object bean, String beanName);
```
В метод придет bean и его имя. И в этом методе можно вернуть объект(причем мы можем вернуть не тот, который нам передали).

Теперь напишем реализацию для метода postProcessBeforeInitialization. Из интересного - он используется ReflectionUtils, чтобы не писать try catch, т.к. ReflectionApi в методе set, который как раз задает значение для field выбрасываем checked exception, который мы должны обрабатывтаь. А ReflectionUtils позволяет не отлавливать такие исключения явно.
![[Pasted image 20241028093326.png]]
Осталось только создать bean этого класса, например, через xml.
![[Pasted image 20241028093750.png]]
### Зачем нужны init методы, если есть конструктор?
Мы написали beanDefinition в xml, его прочитал XmlBeanDefinitionReader, создал BeanDefinitions, дальше Spring, используя ReflectionApi вызвал конструктор и создал бин. И вот только теперь Spring можно начать настраивать наш bean. Т.е. например, BeanPostProcessors начнут отрабатывать уже после конструктора, поэтому, например, поле repeat из прошлого примера в конструкторе еще не будет задано и в нем будет 0.

Поэтому, если мы в констуркторе обращаемся к вещам, которые должен был настроить Spring, то получим null или 0 или false(дефолтные значения для полей).

При этом, если мы добавим аннотацию @PostConstuct, то она по дефолту не будет работать! Т.к. мы же теперь знаем, что за аннотации отвечает BeanPostProcessor, а, значит, и для этой аннотации есть PostProcessor - CommonAnnotationBeanPostProcesor. И мы сначала должны создать bean этого класса и только после этого у нас заработает обработка аннотаций.

Но учить название каждого PostProcessora для каждой аннотации - тяжело. Поэтому есть namespace в XML, например, annotation-config, который внутри себя содержит бины для BeanPostProcessors, которые обрабатывают популярные аннотации.

BeanPostProcessors - это такие же бины, поэтому, когда XmlBeanDefinitionReader создал BeanDefinitions и beanFactory сначала выбрала из этих BeanDefintions сначала BeanPostProcessors(просто посмотрела, что эти классы реализуют интерфейс BeanPostProcessor). Создала их бины и положила в сторонку. И потом уже начала создавать наши пользовательские бины и для их настройки использовать BeanPostProcessors, которые создала заранее.

Как теперь выглядит жизненный цикл?
XmlBeanDefinitionReader прочитал XML, создал BeanDefinitions, передал их в BeanFactory. BeanFactory создала объекты этих бинов и потом начала передавать их в BeanPostProcessors вызвав метод postProcessBeforeInitialization. Так она сделала для каждого бина, передав его в каждый BeanPostProcessor. После этого вызвался @PostConstruct метод, потом beanFactory еще раз передала объект во все BeanPostProcessors, вызвав уже postProcessAfterInitialization. 
Но возникает вопрос, а зачем postProcessAfterInitialization?
Это нужно для механики proxy(есть dynamic, когда реализуются интерфейсы такие же и cglib, когда наследование. Но наследование не всегда хорошо, поскольку не от всех классов можно наследовать + методы могут быть final, в общем, мы ограничены). По договоренности мы считаем, что в postProcessorBeforeInitialization мы работаем всегда с настоящим объектом, он не обернут никаким proxy и поэтому мы можем рассчитывать на метаинформацию, которая есть в оригинальном объекте(когда мы используем proxy, метаинформация пропадает, т.е. не будет никаких аннотаций). 

Но нам нужно иметь возможность оборачивать бины в прокси, чтобы добавлять какой-то функционал дополнительный, например, @Transactional, мы должны перед вызовом метода, который помечен такой аннотацией создать транзакцию, вызвать оригинальный метод и потом завершить. А добавить такой функционал можно только через proxy. И вот поэтому и нужен postProcessAfterInitialization. В нем уже мы как раз и можем оборачивать объект, который нам пришел в proxy(причем не забываем, что к нам уже также может прийти не оригинальный объект, т.к. другой BeanPostProcessor мог уже обернуть наш объект).

beanName - никогда не меняется. Это нужно использовать! Т.к. тот Object bean, который приходит к нам в postProcess метод при получении его класса мы уже можем получить не оригинальный класс, а обернутый proxy. А вот имя бина - сохраняется. 

Поэтому частая практика создать map, в которой сохранить как ключ имя бина, которое как раз не изменяется и class оригинального бина(это мы добавим в методе postProcessBeforeInitialization). И потом уже в postProcessAfterInitialization мы сможем по имени бина получить его оригинальный класс и получить метаинформацию.
![[Pasted image 20241028100821.png]]

Создали свою аннотацию @Profiling, в которой хотим замерять время работы каждого метода в классе, который помечен @Profiling. И вот мы как раз на этапе postProcessorBeforeInitialization мы запоминаем класс бина, у которого такая аннотация есть и его имя. А в postProcessAfterInitialization мы по beanName сможем проверить, есть ли этот класс в map, в котором мы сохраняли все beanName, у которых есть такая аннотация.
![[Pasted image 20241028101021.png]]

Создаем динамическое прокси, используя Proxy.newProxyInstance, передав туда ClassLoader, который загрузит прокси(а прокси - это просто класс, который сгенерируется на лету с теми же интерфейсами(мы их также передаем)), интерфейсы, которые должен реализовывать прокси и hander. handler - это как раз то, где мы добавляем новый функионал. По сути это то - чем будут обернуты каждый из методов. 
method.invoke(bean, args) - это мы вызываем оригинальный метод и получаем его возвращаемое значение и возвращаем это значение.
contoller - это чисто дополнение, которое либо включает, либо выключает профилирование и его значение мы можем задать перед запуском приложения.
![[Pasted image 20241028102349.png]]

### Важно, что при getBean нужно делать поиск по интерфейсу, а не по классу, т.к. из-за Proxy класс у бина может измениться и мы его не найдем.

### ApplicationListener
![[Pasted image 20241028103253.png]]
Listener - умеет слушать контекст спринга(ивенты, которые могут происходить с контектстом)
- ContextRefreshedEvent - самый интересный. Он вызывается, когда контекст сформировался и готов к работе. Это по сути последний этап, когда мы можем еще как-то поработать с бином и донастроить его. Когда все прокси создались и обернулись и уже реально все готово к работе, то тогда вызывается этот RefreshedEvent. Это можно назвать 3-ей фазой конструкирования(первая - констуктор, вторая - @PostConstruct и эта третья).

![[Pasted image 20241028105023.png]]

### BeanFactoryPostProcessor
Позволяет настраивать BeanDefinitions до того, как создаются бины.
BeanFactoryPostProcessor - работают раньше, чем BeanPostProcessors.

Например, есть BeanFactoryPostProcessor, который обрабатывает ${password} - которое мы могли использовать в XML или используя аннотацию @Value над полем. И вот на этапе, когда создался BeanDefinition, чтобы заменить вот это вот ${password}  на реальное значение из файлика с пропертями может использоваться BeanFactoryPostProcessors.

Кроме того, BeanFactoryPostProcessors могут подкрутить и другие BeanFactory(мы можем задавать порядок, как и в случае с BeanPostProcessor(есть аннотация @Ordered)).
![[Pasted image 20241028110505.png]]
И видим, что у нас внутри метода postProcessBeanFactory передается beanFactory, в которой как раз хранятся beanDefinitions, которые мы и можем подкрутить.

Пример использования - напишем свою аннотацию @DeprecatedClass, которая будет добавляться над Deprecated классами и в ней есть свойство, в котором нужно указать новый класс, который лучше использовать вместо Deprecated. И дальше мы хотим, чтобы все бины, которые используют Deprecated класс, их классы были заменены на тот, который мы указали как свойство. Тут нам как раз поможет BeanFactoryPostProcessors. Т.е. мы хотим, чтобы еще до создания бинов, т.е. на этапе beanDefinitions мы можем в beanDefinition взять и изменить класс бина на новый!

### @Component
Можем вешать над нашими классами, чтобы создавались бины.
Для включения сканирования и поиска @Component(кто-то же должен их искать):
![[Pasted image 20241028111859.png]]

Приходит ClassPathBeanDefinitionScanner и сканирует пакет и ищет все бины, которые аннотированы @Component. Сканер - не BeanPostProcessor и не BeanFactoryPostProcessor!
![[Pasted image 20241028112156.png]]

В Spring 3 появилась возможность конфигурировать бины в Java файле. 
![[Pasted image 20241028112420.png]]
AnnotatedBeanDefinitionReader - находится внутри AnnotationConfigApplicationContext и он занимается тем, что регистрирует JavaConfing(@Config).
![[Pasted image 20241028112519.png]]
А кто обрабатывает внутренности JavaConfig(добавляет beanDefinitions, у которых над методами есть @Bean.) - этим занимается ConfigurationClassPostProcessor. Его особенность в том, что он добавляет новые beanDefinitions, а не обрабатывает уже готовые.
 ![[Pasted image 20241028113337.png]]
 
### Как обновить prototype в Singleton?
У нас же класс Singleton и в него мы заинжектили поля один раз и все, но, что, если мы хотим, чтобы при повторном получении Singleton у него обновились prototype поля?

1. Для этого мы объявляем класс бина как абстрактный. В нем создаем абстрактный метод, который и должен будет получать бин, который является prototype. И потом в JavaConfig мы при создании бина нашего абстрактного класса реализуем абстрактный метод и в нем вызываем внутри JavaConfing создание бина с prototype.
2. Использовать @Scope(value="prototype", proxyMode = ScopedProxyMode.TARGET_CLASS) - создаст proxy поверх нашего бина и тогда, когда мы будем просить Singleton, то будет обновляться и поле с такой аннотацией, причем будет создан новый объект. Не подойдет, когда нужно обновлять эту prototype переменную по какому-то условию.
3.  Создать Supplier, заинжектить его внутрь нашего Singleton. И потом уже Singleton использовать его тогда, когда захотим.
	![[Pasted image 20241028171331.png]]
### Можно создавать кастомные скопы
Для этого нужно создать сам объект скопа, который реализует интерфейс Scope. В нем переопределить методы. И потом зарегестрировать в ApplicationContext, используя BeanFactoryPostProcessor, который как раз нужен для донастройки как Context, так и beanDefinitions.

Например, это может быть полезно, когда у нас есть куча бинов с валютами. И мы хотим раз в какой-то перидо их обновлять, для этого создаем скоп через который и будем получать бины и при получении как раз обновлять информацию.

### Аспекты стоит делать с узкоспециализированными методами
Поскольку аспекты очень сильно тормозят вызовы методов.
![[Pasted image 20241028123455.png]]
AspectJ - намного лучше работает аспектов.
