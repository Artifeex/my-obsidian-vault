![[InputFiles/image 50 3.png|image 50 3.png]]

Состояние Transient - сущность ни с какой сессией не ассоциирована. Т.е. мы просто создали нашу сущность через какой-нибудь конструктор. Чтобы сохранить сущность в персистенс конексте всегда нужно, чтобы вызвался какой-то метод, который бы связал данную сущность с персистенс конекстом. В случае новой сущности мы должны вызвать внутри сессии метод save или saveOrUpdate(). Тогда из transient состояние сущности переходит в состояние Persistent - это значит, что сущность связана с persistent контекстом нашей сессии. Именно той сессии, в которой вызвали метод save. Т.е. если есть параллельно еще какая-то сессия и в ней мы не вызывали метод save для нашей сущности, то для другой сессии сущность будет находиться в состоянии transient, а для нашей сессии, в которой мы вызвали save будет находиться в состоянии persistent.

Еще в персистент состояние сущности могут перейти, если мы их получаем сразу же из БД, вызовет get на сессии. Так же неявно сущности попадают в персистенс состояние, например, когда вызываем метод update, то, чтобы понять, есть ли такая сущность или нет в БД hibernate под капотом вызовет метод get, чтобы попытаться получить сущность.

Далее мы могли вызвать session.delete(entity) и тогда наша сущность удаляется из персистенс контекста нашей сессии и из БД. delete так же мгновенно не исполняется, так как отложенное выполнение запросов, но если все-таки хотим, чтобы сразу выполнилось, то вызываем session.flush().

detached - состояние, в котором можно попасть только вызовом методов evict, clear, close, которые мы в прошлый раз рассматривали. Т.е. мы удаляем сущность из нашего пересистенс контекста.

detached отличается от transient тем, что если сущность имеет состояние detached, значит, она когда-то была в персистенс контексте, но удалилась из него. А transient никогда не была в нем.

Так же из detached состояния мы можем вернуться обратно в persistent если вызовем saveOrUpdate, update, merge(но в любом случае под капотом вызовется get, из-за чего сущность и попадает обратно в persistent context).
### Влияние persist на Entity
1) Если статус Entity new, то он меняется на managed и объект будет сохранен в базу при commit’е транзакции или в результате flush операций,
2) Если статус уже managed, операция игнорируется, однако зависимые Entity могут поменять статус на managed, если у них есть аннотации каскадных изменений,
3) Если статус removed, то он меняется на managed,
4) Если статус detached, будет выкинут exception сразу или на этапе commit’а транзакции.
### Влияние remove на Entity
1) Если статус Entity new, операция игнорируется, однако зависимые Entity могут поменять статус на removed, если у них есть аннотации каскадных изменений и они имели статус managed,
2) Если статус managed, то статус меняется на removed и запись объект в базе данных будет удалена при commit’е транзакции (также произойдут операции remove для всех каскадно зависимых объектов),
3) Если статус removed, то операция игнорируется,
4) Если статус detached, будет выкинут exception сразу или на этапе commit’а транзакции.
### Влияние merged на Entity
1) Если статус detached, то либо данные будет скопированы в существующей managed entity с тем же первичным ключом, либо создан новый managed в который скопируются данные,
2) Если статус Entity new, то будет создана новый managed entity, в который будут скопированы данные прошлого объекта,
3) Если статус managed, операция игнорируется, однако операция merge сработает на каскадно зависимые Entity, если их статус не managed,
4) Если статус removed, будет выкинут exception сразу или на этапе commit’а транзакции.

### Влияние refresh на Entity
1) Если статус Entity managed, то в результате операции будут востановленны все изменения из базы данных данного Entity, также произойдет refresh всех каскадно зависимых объектов,
2) Если статус new, removed или detached, будет выкинут exception.
### Влияние detach на Entity
1) Если статус Entity managed или removed, то в результате операции статус Entity (и всех каскадно-зависимых объектов) станет detached.
2) Если статус new или detached, то операция игнорируется.
