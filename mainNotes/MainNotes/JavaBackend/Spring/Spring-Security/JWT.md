![[Pasted image 20241030103422.png]]
JWT токен состоит из 3-х частей. 
- HEADER - какая-то мета информация о токене. 
- PAYLOAD - полезная нугрузка, в ней как раз и передается какая-то информация. 
- И последнее - подпись. Она нужна для того, чтобы проверить, что тот JWT, который к наш пришел был выдан нами или нет? 
Любой желающий может раскодировать токен! Поэтому в payload не надо передавать какую-то секретную информацию.  

Подпись создается на основе ключа шифрования, который есть только у того, кто и генерирует JWT. Подпись основывается как на ключе шифрования так и на данных в payload. Поэтому тот, кто получит JWT хоть и может расшифровать информацию в нем, но изменить ее не сможет из-за подписи!

Но и PAYLOAD можно также шифровать, тогда в нем можно будет передавать какие-то секретные данные. Но в таком случае будет 5 блоков информации в JWE(json web encription. Шифрованные ключи).

### 2 ключа доступа
Обычно предоставляется 2 ключа доступа.
- Access Token - для доступа к защищенным ресурсам. Имеет время жизни небольшое(около минуты, но можем сами настраивать). Смысл в том, чтобы если злоумышленник перехватил JWT токен, то он не смог им долго пользоваться. 
- Refresh Token - токен для получения Access Token. Он имеет значительный срок жизни! Например, неделя. Почему дольше живет? Потому что большинство запросов к защищенным ресурсам будет с Access Token, а Refresh будет фигурировать в запросах не так часто, поэтому и перехватить его сложнее.

Для работы с jwt используется библиотека nimbus-jose-jwt(для создания jwt).
Имеем такую БД:
![[Pasted image 20241030104652.png]]
Конфигурационный файлик:
![[Pasted image 20241030104913.png]]
В jwt как раз указаны те секретные части ключа, которые и нужны для создания подписи! И один для создания подписи для access токена, а второй для refresh токена.

Создадим класс для описания токена. Обычно на практике создают 2 отдельных класса - один для Access, другой для Refresh. Но мы напишем один. UUID
![[Pasted image 20241030105408.png]]
- UUID id - у каждого токена должен быть уникальный идентификатор. И тут приходит на помощь класс [[UUID]] из Java.
- subject - логин пользователя
- authorities - права
- createdAt - когда создали token
- expiresAt - когда токен просрочится 

Теперь нужно создать фабрику, которая будет создавать Token(это фабрика для REFRESH токена!).
Сама фабрика:
![[Pasted image 20241030112112.png]]
Из интересного - мы по дефолту любому токену добавляем 2 authority - JWT_REFRESH - это для REFRESH токена. Мы должны для такого Refresh токена иметь доступ на получения нового ACCESS токена. И JWT_LOGOUT - для логаута. И ко всему этому дополнительно добавляем все Authorities пользователя, добавив префикс GRANT. Для чего префикс? Чтобы мы могли разделять authorities пользователя, полученные из Spring-Security и authorities токена. 

Почему принимает Authentication? Потому что мы будем проводить аутентификацию, используя Spring-Security, например, basic аутентификацию. Она вернет нам заполненный authentication. И потом уже мы после успешного прохождения аутентификации создадим токены и вернем его!

Теперь создадим фабрику для Access токена:
Особенность в том, что будет принимать Refresh токен и создавать AccessToken! ![[Pasted image 20241030113120.png]]
- id для access токена будет напрямую связано c refresh токеном через который будет создан access токен.
- Дальше мы забираем остальную информацию, которую сохранили в refresh токене и стоит заметить, что для authorities мы забираем только те права, которые были у пользователя и не добавляем права REFRESH токена. А также убираем префикс GRANT_

Можем заметить, что в токенах нет никакого упоминания JWT. Это всего лишь формат для сериализации токена. 
И вот напишем как раз сериализатор, который будет получать токен и возвращаеть уже строку с JWT токеном. Для этого нам нужен jwtSigner для подписи и алгоритм для сериализации. Напишем такой сериалазатор для Access токена, причем напишем JWS - это JWT, который подписан, но при этом payload никак не шифруется.
![[Pasted image 20241030113917.png]]
И вот сам метод:
![[Pasted image 20241030114616.png]]
jwsHeader - header. В него можем дополнительно что-то добавлять, если захотим.
claimsSet - это payload.
И должны не забыть подписать наш JWT.

Теперь напишем еще один сериалайзер, но уже для Refresh токена. И важно, что мы будем писать JWE, т.е. мы помимо подписи еще и зашифруем Payload!
![[Pasted image 20241030114917.png]]
Сам метод:
![[Pasted image 20241030115100.png]]

Теперь напишем класс, JSON которого и будем возвращать пользователю.
![[Pasted image 20241030125246.png]]

Теперь создаем фильтр:
![[Pasted image 20241030125703.png]]
Реализуем метод фильтра:
![[Pasted image 20241030130742.png]]
Таким образом, мы написали фильтр, который будет возвращать Access и Refresh токены. 
Сначала мы проверяем тот запрос, который пришел в фильтр удовлетворяет матчеру или нет(в матчере мы написали, что фильтр будет работать для POST запросов по URL /jwt/tokens). Если не удовлетворяет, значит, мы ничего не делаем и просто пусть дальше фильтры отрабатывают. А если удовлетворяет, то проверяем SecurityContext. 

SecurityContext в Spring Security — это объект, содержащий информацию о текущей аутентификации. Он включает данные о пользователе, который инициировал запрос, и о его полномочиях (роль и права доступа)
**SecurityContextHolder**: это контейнер, который управляет `SecurityContext` и предоставляет глобальный доступ к контексту безопасности в приложении.
Каждый запрос, обрабатываемый приложением Spring, имеет доступ к своему экземпляру `SecurityContext`. Это достигается через `SecurityContextHolder`, который позволяет получить текущий контекст безопасности для каждого запроса. Например, при входе пользователя в систему, `Authentication` сохраняется в `SecurityContext`, и каждый последующий запрос будет использовать тот же `SecurityContext`, пока сессия активна.
`SecurityContextRepository` — это интерфейс в Spring Security, который отвечает за сохранение и загрузку `SecurityContext` (контекста безопасности) в хранилище. Его основная задача — обеспечить хранение информации о текущей аутентификации между запросами, чтобы при каждом новом HTTP-запросе данные о пользователе могли быть восстановлены.

### Зачем нужен SecurityContextRepository?

Spring Security по умолчанию сохраняет данные о текущем пользователе и его правах в `SecurityContext`, который управляется через `SecurityContextHolder`. Однако для того, чтобы данные о пользователе были доступны в каждом запросе, `SecurityContext` нужно где-то хранить между запросами (например, в HTTP-сессии). Вот тут и появляется необходимость в `SecurityContextRepository`, который управляет сохранением и восстановлением `SecurityContext` из выбранного хранилища.

### Основные функции SecurityContextRepository

1. **Загрузка SecurityContext**: когда приходит новый HTTP-запрос, `SecurityContextRepository` проверяет, существует ли `SecurityContext` для текущего запроса, и если да, то загружает его. Это позволяет приложению «вспоминать» пользователя между запросами.
2. **Сохранение SecurityContext**: после успешной аутентификации пользователя, `SecurityContext` сохраняется, чтобы он был доступен для последующих запросов.
3. **Удаление SecurityContext**: при завершении сессии, выходе пользователя из системы или при сбросе аутентификации, `SecurityContext` удаляется из хранилища.


Такая схема взаимодействия для какого-то нативного приложения, которое может сохранить информацию с JWT надежно
![[Pasted image 20241030130234.png]]
