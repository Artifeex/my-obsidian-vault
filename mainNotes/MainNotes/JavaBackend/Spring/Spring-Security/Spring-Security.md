Состоит из 3-х этапов.
### 1. Идентификация пользователя
Это поиск пользователя в системе по какому-нибудь идентифкатору(уникальному в рамках системы). Например, это может быть почта, телефон, логин и т.д.
### 2. Подтверждение подлинности пользователя(аутентификация)
Это делается с помощью передачи в систему какой-то секретной информации(пароль, одноразовый пароль(google authenticator), код из СМС и т.д.).

### 3. Определение прав доступа(авторизация)
Может ли пользователь иметь доступ к какому-то ресурсу. 
Можно реализовать:
- Можно предоставлять доступ на основе ролей.
- Вместо ролей есть правила, которые может совершать пользователь(сложнее, но более гибкая)

### Поговорим подробнее про аутентификацию
Spring-Security интегрируется в систему через систему фильтров. Запрос проходит через эту цепочку фильтров перед тем, как попасть в сервлет. 

Реализовать аутентификацию можно также несколькими способами:
### Basic Authentification
Все начинается с того, что пользователь посылает запрос на получение некоторого ресурса. Его запрос прежде чем попасть в сервлет проходит через цепочку фильтров. Т.е. цепочка фильтров SpringSecurity будет посещена запросом. 

После этого Spring-Security должен проверить, имеет ли доступ к этой странице(происходит параллельно еще и авторизация). Когда пользователь впервые пришел, то Spring-Security попытается выполнить авторизацию, чтобы проверить, есть доступ к странице или нет, а т.к. пользователь анонимный(он же в первый раз пришел), то Spring-Security требует от пользователя пройти аутентификацию.
Как он это делает? Он отвечает пользователю с ответом 401(Unaouthorized) и с помощью заголовка WWW-Authenticate: Basic Realm="my realm".

После этого в браузере появится окошко для ввода логина и пароля. И после ввода браузер снова повторит запрос, но добавит к нему заголовок Authorization: Basic ...(токен). 

После этого Spring Security выполняет аунтентификацию на основе этих данных, то если пользователь был успешно аутентифицирован, то уже можно делать авторизацию и разрешать либо запрещать доступ.

Общая схема:
![[Pasted image 20241029165006.png]]

Basic Authentification - обычно используется, где есть HTTP. Больше ориентирована на системы, которые не хранят данные о пользователе между запросами. Браузер будет хранить данные по Basic Authentification пока сессия не закончится, потом, если мы закроем браузер и по новой попытаемся обратиться, то снова придется вводить пароль. 

### Реализация в Spring
![[Pasted image 20241029165501.png]]
Создаем Bean типа SecurityFiltherChain через который как раз и будет проходить запрос. В нем мы пишем настройки. В данном случае мы указали, что будем использовать как раз Basic Authorization(httpBasic), затем настраиваем права доступа(authorizeHttpRequests) и говорим, что любой запрос должен быть аутентифицирован. И вот такой настроенный FilterChain мы и возвращаем в SpringSecurityFilterChain.

После этого в директории resources создаем директорию static и в ней файлик hello.html. Тогда с помощью GET запроса мы можем попытаться получить этот файлик, но благодаря Spring Security:
![[Pasted image 20241029170157.png]]
Если мы введем данные правильно, то получим страничку(Spring создает дефолтного пользователя с именем user и пароль генериует и выводит в консоли, поэтому мы можем пока по этим данным войти).
При этом если мы обновим страничку, то уже никакой пароль и логин вводить не нужно. Браузер сохранил информацию с логином и паролем в виде строки base64(закодирована) и передает ее на сервер в хедере Authorization: Basic < base64 строка>(на скрине ниже они синим выделена).
![[Pasted image 20241029170306.png]]

### Теперь рассмотрим другой вариант аутентификации, но теперь в виде формы (а не в виде появляющихся в браузере полей для имени и пароля)
В таком случае пользователя редиректнет на URL с получением странички для ввода логина и пароля. Также в момент отправки запроса с перенаправлением будет установлена сессионная кука.
После этого отправляются данные в POST запросе с данными пользователя, Spring-Security проводит аутентификацию и если все хорошо, то снова 302(redirect) на уже ту страницу, на которую пользователь изначально хотел попасть(можем настраивать) + устанавливается новая сессионная кука(уже авторизованного пользователя).
Итоговая схема:
![[Pasted image 20241029171307.png]]

Такой вариант чаще всего используется в вебе. Он активно используется в системах, которые сохраняют состояние пользователя между запросами. Т.е. даже когда пользователь закроет браузер, то куки продолжают храниться(у них есть expired time) и потом мы по этой куке JSESSION сможем восстановить сессию пользователя и пользователь сможет не вводить пароль и логин.

Реализация в Spring - нам не нужно даже писать никаких Бины(как в случае с Base аутентификацией). Это как раз вариант по умолчанию для Spring-Security.

![[Pasted image 20241029172034.png]]

### Компоненты аунтентификации в Spring-Security
Разберем из каких компонентов состоит и что происходит в Spring-Security?

Первыми запрос принимают фильтры. Они нужны для того, чтобы из запроса получить информацию для аутентификации и формирования запроса на аутентификацию.
Например, если у нас Base аутентификация, то нужно взять header Authorization, взять строку в base64, декодировать ее и получить из нее пароль и логин. И вот как раз фильтры читают эти данные из запроса и создают объект Authentication, в котором и складывают эти данные, которые потом будут использоваться для аутентификации.

![[Pasted image 20241029211048.png]]
Principal - в нем можно получить имя пользователя.
Какие есть методы у Authentication?
![[Pasted image 20241029211239.png]]
- getAuthorities - для получения прав пользователя
- getCredentials - пароль
- getDetails - дополнительные атрибуты запроса, не являющиеся обязательными. 
- getPrincipal - получение пользователя
- isAuthenticated - возвращает true, если это результат аутентификации(успешной) и false - если запрос на аутентификацию.

Запрос аутентификации теперь нужно обработать. Фильтр аутентификации передает запрос аутентификации(Authentication объект) в AuthenticationManager.authenticate(authentication)

В AuthenticationManager - один метод authenticate, которые возвращает Authentication в том случае, если аутентификация прошла успешно, а если нет, то выбрасывает исключение AuthentcationException.
![[Pasted image 20241029211753.png]]

В документации даже написано, какие нужны исключения кидать:
![[Pasted image 20241029211910.png]]
Основой реализацией интерфейс AuthenticationManager является ProviderManager, у которого есть список AuthenticationProviders. Т.е. он сам не реализует аутентификацию, а ищет провайдер для запрошенного типа аутентификации
![[Pasted image 20241029212115.png]]
Почему так сделано? Потому что в приложении может быть несколько вариантов аутентификации! И тогда нужно просто предоставить несколько AuthenticationProviders.

Вот, что внутри AuthenticaionProvider(еще есть метод supports, который проверяет, поддерживать ли провайдер переданный тип Authentication)
![[Pasted image 20241029212846.png]]
DaoAuthenticationProvider - это реализация абстрактного класса AbstractUserDetailsAuthenticationProvider(он используется по умолчанию для Base и form аутентификации).

И внутри этого DaoAuthenticationProvider есть доп проверки(как и в други провайдерах), в которых, например, сравнивается credetials, которые прислали с теми, которые в БД. Но как DaoAuthenticationProvider получит данные из БД? Он использует UserDetailsService - интерфейс:
![[Pasted image 20241029213126.png]]
А где он берет реализацию этого интерфейса? А вот тут как раз мы ее и должны написать, а потом Spring с помощью DI внедрит ее в DaoAuthenticationProvider!!!
Получаем такую схему:
![[Pasted image 20241029213515.png]]
Про 9 шаг - нужно сохранить в контексе безопасноти, чтобы потом этот сформированный объект Authentication можно было использовать в других фильтрах или компонентах Spring-Security. Запрос аутентификации и результат аутентификации - это два разных объекта! Т.е. для результата обязательно создавать новый объект Authentication.

Что за интерфейс UserDetails?
![[Pasted image 20241029213858.png]]
![[Pasted image 20241029213915.png]]
В SpringSecurity есть класс User, который реализует UserDetails, т.е. нам не нужно создавать своего User, конкретно для аутентификации, а сможем воспользоваться спринговым.
![[Pasted image 20241029213954.png]]

А вот такая реализация интерфейса Authentication используется для Basic и через форму аутентификацию:
![[Pasted image 20241029214113.png]]
У него есть 2 важных метода(другие тоже есть):
- unauthenticated - создает запрос на аутентифацию. Этот метод вызываем BasicAuthenticationConverter, который извлекает из Basic токена имя пользователя и пароль и кладет как раз в UsernamePassowrdAuthenticationToken.
- aunthenticated - создает результат аутентификации.
Вот эти два метода:
![[Pasted image 20241029214538.png]]

### Как получить информацию об аутентифицированном пользователе?
Например, хотим в контроллере для пользователя, который аутентифицирован вывести привествие с его именем.
Первый и самый популярный способ - через SecurityContextHolder, куда Filter после успешной аутентификации сохраняет пользователя.
![[Pasted image 20241029220307.png]]

Второй вариант более прикольный, по сути эта аннотация под капотом делает ровно то же самое, что и делали мы. Т.е. она берет из SecurityContextHolder текущий Principal, который в нем лежит и кастит в UserDetails.
![[Pasted image 20241029220620.png]]
