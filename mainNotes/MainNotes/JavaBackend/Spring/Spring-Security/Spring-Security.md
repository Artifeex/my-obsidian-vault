Состоит из 3-х этапов.
### 1. Идентификация пользователя
Это поиск пользователя в системе по какому-нибудь идентифкатору(уникальному в рамках системы). Например, это может быть почта, телефон, логин и т.д.
### 2. Подтверждение подлинности пользователя(аутентификация)
Это делается с помощью передачи в систему какой-то секретной информации(пароль, одноразовый пароль(google authenticator), код из СМС и т.д.).

### 3. Определение прав доступа(авторизация)
Может ли пользователь иметь доступ к какому-то ресурсу. 
Можно реализовать:
- Можно предоставлять доступ на основе ролей.
- Вместо ролей есть правила, которые может совершать пользователь(сложнее, но более гибкая)

### Поговорим подробнее про аутентификацию
Spring-Security интегрируется в систему через систему фильтров. Запрос проходит через эту цепочку фильтров перед тем, как попасть в сервлет. 

Реализовать аутентификацию можно также несколькими способами:
### Basic Authentification
Все начинается с того, что пользователь посылает запрос на получение некоторого ресурса. Его запрос прежде чем попасть в сервлет проходит через цепочку фильтров. Т.е. цепочка фильтров SpringSecurity будет посещена запросом. 

После этого Spring-Security должен проверить, имеет ли доступ к этой странице(происходит параллельно еще и авторизация). Когда пользователь впервые пришел, то Spring-Security попытается выполнить авторизацию, чтобы проверить, есть доступ к странице или нет, а т.к. пользователь анонимный(он же в первый раз пришел), то Spring-Security требует от пользователя пройти аутентификацию.
Как он это делает? Он отвечает пользователю с ответом 401(Unaouthorized) и с помощью заголовка WWW-Authenticate: Basic Realm="my realm".

После этого в браузере появится окошко для ввода логина и пароля. И после ввода браузер снова повторит запрос, но добавит к нему заголовок Authorization: Basic ...(токен). 

После этого Spring Security выполняет аунтентификацию на основе этих данных, то если пользователь был успешно аутентифицирован, то уже можно делать авторизацию и разрешать либо запрещать доступ.

Общая схема:
![[Pasted image 20241029165006.png]]

Basic Authentification - обычно используется, где есть HTTP. Больше ориентирована на системы, которые не хранят данные о пользователе между запросами. Браузер будет хранить данные по Basic Authentification пока сессия не закончится, потом, если мы закроем браузер и по новой попытаемся обратиться, то снова придется вводить пароль. 

### Реализация в Spring
![[Pasted image 20241029165501.png]]
Создаем Bean типа SecurityFiltherChain через который как раз и будет проходить запрос. В нем мы пишем настройки. В данном случае мы указали, что будем использовать как раз Basic Authorization(httpBasic), затем настраиваем права доступа(authorizeHttpRequests) и говорим, что любой запрос должен быть аутентифицирован. И вот такой настроенный FilterChain мы и возвращаем в SpringSecurityFilterChain.

После этого в директории resources создаем директорию static и в ней файлик hello.html. Тогда с помощью GET запроса мы можем попытаться получить этот файлик, но благодаря Spring Security:
![[Pasted image 20241029170157.png]]
Если мы введем данные правильно, то получим страничку(Spring создает дефолтного пользователя с именем user и пароль генериует и выводит в консоли, поэтому мы можем пока по этим данным войти).
При этом если мы обновим страничку, то уже никакой пароль и логин вводить не нужно. Браузер сохранил информацию с логином и паролем в виде строки base64(закодирована) и передает ее на сервер в хедере Authorization: Basic < base64 строка>(на скрине ниже они синим выделена).
![[Pasted image 20241029170306.png]]

### Теперь рассмотрим другой вариант аутентификации, но теперь в виде формы (а не в виде появляющихся в браузере полей для имени и пароля)
В таком случае пользователя редиректнет на URL с получением странички для ввода логина и пароля. Также в момент отправки запроса с перенаправлением будет установлена сессионная кука.
После этого отправляются данные в POST запросе с данными пользователя, Spring-Security проводит аутентификацию и если все хорошо, то снова 302(redirect) на уже ту страницу, на которую пользователь изначально хотел попасть(можем настраивать) + устанавливается новая сессионная кука(уже авторизованного пользователя).
Итоговая схема:
![[Pasted image 20241029171307.png]]

Такой вариант чаще всего используется в вебе. Он активно используется в системах, которые сохраняют состояние пользователя между запросами. Т.е. даже когда пользователь закроет браузер, то куки продолжают храниться(у них есть expired time) и потом мы по этой куке JSESSION сможем восстановить сессию пользователя и пользователь сможет не вводить пароль и логин.

Реализация в Spring - нам не нужно даже писать никаких Бины(как в случае с Base аутентификацией). Это как раз вариант по умолчанию для Spring-Security.

![[Pasted image 20241029172034.png]]

### Компоненты аунтентификации в Spring-Security
Разберем из каких компонентов состоит и что происходит в Spring-Security?
