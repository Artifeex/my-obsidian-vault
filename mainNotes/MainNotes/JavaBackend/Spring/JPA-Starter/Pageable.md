Параметр, который мы дополнительно можем передавать в запросы. Причем он работает со всеми типами запросов. И с @Query и c [[PartTreeQuery]]. Используется для того, чтобы динамически передавать в запрос сортировку, limit и offset.
![[Pasted image 20240908165914.png]]
![[Pasted image 20240908170049.png]]
Таким образом, с помощью pageable мы можем задавать limit и offset.

### Возможные возвращаемые значение при использовании Pageable
- List
- Streamable - довольно редко используется на практике. Является реализацией Iterable интерфейса. Вместо него использует Slice.
- Slice
- Page
### Slice
Наследник Streamable из-за этого много методов, которые похожи на работу со Stream(повторяют даже). Основные элементы:
* number - номер текущей странички. Номер слайса.
* size - размер(limit) странички.
* numberOfElements - актуальное количество элементов в слайсе. Хоть мы и сделали limit, но могло вернуться, например, только 3 элемента. А limit =10. Тогда numberOfElements = 3.
Использование:
![[Pasted image 20240908171612.png]]
Со Slice можем работать как со страничками. Мы получили первый slice элементов, можем с ними как-то поработать, потом с помощью hasNext(), проверить, есть ли в выборке еще slice элементов. Если есть, то можем получить этот новый slice элементов, используя еще один вызов метода из Repository, передав Pageable, у которого просто offset на 1 страничку больше, чтобы мы пропустили те элементы слайса, которые получили при прошлом слайсе.
![[Pasted image 20240908171856.png]]

И это используется при пагинанации на сайте! Но на самом деле у Slice есть 1 минус, мы не можем с помощью него узнать, сколько всего страничек будет. Например, на скрине снизу мы видим цифру 20, которая говорит, что есть 20 страничек. Но в Slice такого функционала нет. Поэтому нам нужен Page, который дополнительно делает запрос count, который узнает, сколько всего строк в таблице. И с помощью этого count запроса мы и можем узнать, сколько всего страниц, разделив количество строк в таблице на размер одной страницы. Таким образом, если нам нужен такой счетчик, который покажет, сколько всего страниц, то используем Page, а если не нужен, то Slice.
![[Pasted image 20240908172244.png]]

### Page
Наследуется от Slice. Появляется просто два доп метода:
getTotalElements()
getTotalPages().
Стоит заметить, что он при каждом получении следующий страницы делает доп запрос couht, для получения количества элементов.
Используя, countQuery мы можем переопределить какой доп запрос будет делаться для получения количества строк при использовании Page.
![[Pasted image 20240908173014.png]]
Получим такие запросы:
![[Pasted image 20240908173146.png]]

Если мы используем какие-либо способы решения [[Проблема N+1|проблемы N+1]], то лучше не использовать ничего, что связано с пагинацией(Pageable, Slice) или LIMIT и OFFSET.

И при работе с Pageable перформанс нашего приложения очень упадет. Т.к. теперь не используется LIMIT и OFFSET на уровне БД, т.е. они просто не появляются в запросе и наше Java приложения получает сразу всех пользователей, потом выбирает из них 2-х и отбрасывает остальные(а это очень тяжелые операции). И потом при запросе на получение следующей страницы, приложение снова делает запрос и получает ВСЕХ пользователей и снова только 2-х из них отбрасывает и т.д. 