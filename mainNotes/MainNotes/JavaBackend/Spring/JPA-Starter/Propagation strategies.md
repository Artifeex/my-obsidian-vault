- REQUIRED - выполнять код в текущей транзакции, если она есть. Если транзакции нет, то происходит ее открытие. Именно то, что мы видели, когда рассматривали взаимодействие cglib proxy сервисов. Это стратегия по умолчанию для @Transactional.
- SUPPORTS - работает также, как и REQUIRED, но, если транзакция НЕ БЫЛА открыта, то proxy не открывает новую. Т.е. вызов метода происходит не в транзакции(надо узнать, что в таком случае будет).
- MANDATORY - если открытый транзакции не было, то выбрасывает исключение, а не игнорирует как в случае SUPPORT.
- [[REQUIRES_NEW]] - в любом случае создает новую транзакцию, не зависимо от того, была она или нет. При этом останавливает транзакцию предшествующую, если она была. Но остановить транзакцию в рамках одного соединения - невозможно. Поэтому на самом деле в таком случае получается новое соединение из HikaruCP(connectionPool).
- NOT_SUPPORTED - метод будет выполняться ВНЕ транзакции. Если уже существовала транзакция, то он ее остановит.
- NEVER - выполняется вне транзакции и пробрасывает исключение, если при вызове метода транзакция открыта.
- NESTED - не поддерживается по умолчанию в JPA TranscationManager(поддерживается в JDBCDataSourceTransactionManager). Он работает по savepoints. Это как в игре. Если вы вызвали setSavePoint, то все изменения то этого savePoint будут закоммичены. И если потом произошел exception после setSavePoint, то то, что мы закоммитили - не потеряется. Работает только в JDBC.
Подытожим:
Чаще всего работа будет с REQUIRED и REQUIRES_NEW.