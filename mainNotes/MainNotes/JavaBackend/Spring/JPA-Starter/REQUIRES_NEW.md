Разберём ваш сценарий с использованием транзакций в Hibernate или JPA, когда один сервис вызывает другой, причём второй сервис использует аннотацию `@Transactional(REQUIRES_NEW)`.

---

### **Сценарий:**

1. **Первая транзакция (`T1`)**: Открывается в первом сервисе.
2. **Вторая транзакция (`T2`)**: Открывается во втором сервисе, так как стоит `@Transactional(REQUIRES_NEW)`.

---

### **Как это работает:**

#### 1. **Что делает `REQUIRES_NEW`:**

- Когда второй сервис с `@Transactional(REQUIRES_NEW)` вызывается из первой транзакции:
    - **Существует текущая транзакция (`T1`)**: Hibernate или JPA **приостанавливает** её выполнение.
    - Создаётся новая транзакция (`T2`), которая работает независимо от `T1`.
- После завершения `T2`, выполнение возвращается к `T1`, которая продолжается с того места, где была приостановлена.

---

#### 2. **Что произойдёт с первой транзакцией (`T1`), пока выполняется `T2`?**

- Первая транзакция (`T1`) будет **ждать** завершения второй транзакции (`T2`).
- Если `T2` успешно завершится, управление вернётся в `T1`, и она продолжит выполнение.

---

#### 3. **Что произойдёт, если во второй транзакции (`T2`) произойдёт ошибка?**

- Ошибка в `T2` приведёт к её откату (**rollback**), но **это не затронет транзакцию `T1`**.
- Транзакция `T1` не знает об ошибке во второй транзакции, так как они работают независимо.
- Однако, если в вашем коде обработка ошибки в `T2` вызывает исключение, которое пробрасывается в `T1`, это может привести к откату `T1`.

### **Как происходит остановка транзакции?**

1. **Начало первой транзакции (`T1`):**
    
    - При вызове метода, помеченного `@Transactional`, Transaction Manager открывает транзакцию (обычно через `EntityManager` или JDBC-соединение).
    - Эта транзакция (`T1`) становится текущей и активной в рамках текущего контекста.
2. **Вызывается метод с `REQUIRES_NEW`:**
    
    - Когда управление доходит до метода, помеченного `@Transactional(propagation = Propagation.REQUIRES_NEW)`, происходит следующее:
        1. **Сохранение текущей транзакции (`T1`):**
            - Transaction Manager "приостанавливает" выполнение текущей транзакции (`T1`).
            - Hibernate "паркует" состояние `Persistence Context` (снэпшот изменений в памяти), чтобы обеспечить изоляцию данных.
        2. **Открытие новой транзакции (`T2`):**
            - Transaction Manager открывает новую транзакцию (`T2`) на том же или другом соединении с базой данных.
            - Эта новая транзакция становится текущей и начинает выполнение.
3. **Завершение `T2`:**
    
    - После выполнения метода с `REQUIRES_NEW`:
        - Если в `T2` нет ошибок, она фиксируется (**commit**).
        - Если есть исключение, происходит откат (**rollback**).
    - Транзакция `T2` закрывается.
4. **Возвращение к первой транзакции (`T1`):**
    
    - После завершения `T2`, Transaction Manager восстанавливает контекст первой транзакции (`T1`):
        - Состояние `Persistence Context` возвращается к тому, каким оно было до приостановки.
        - Выполнение продолжается в рамках первой транзакции.

---

### **Что происходит "под капотом"?**

- **Сохранение состояния:**
    
    - Hibernate сохраняет текущий контекст работы (все изменения объектов, которые ещё не синхронизированы с базой данных).
    - Это необходимо, чтобы изоляция транзакции `T2` не влияла на данные, подготовленные в `T1`.
- **Разные соединения:**
    
    - Чтобы обеспечить изоляцию транзакций, для `T2` Transaction Manager может открыть новое соединение с базой данных, даже если вы используете пул соединений (Connection Pool).
- **Контроль уровня изоляции:**
    
    - Уровень изоляции транзакции (`READ_COMMITTED`, `REPEATABLE_READ` и т.д.) влияет на то, какие данные будут видны для `T2` и что увидит `T1` после возобновления.