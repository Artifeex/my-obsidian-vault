На основе наименование метода, используя регулярное выражение и criteria api выполняет наши запросы.
Регулярное выражение:
![[Pasted image 20240908141743.png]]
Сначала идет один из возможных паттернов(QUERY, COUNT, EXISTS, DELETE), потом может идти или не идти какое-то слово и потом "By".
Например, мы можем использовать QUERY_PATTERN. Внутри QUERY_PATTERN использовать find. Потом идет By и указываем фильтраю. Например, findById или findByName. Id и Name - это название полей в сущностях(только с большой буквы, т.к. camelCase).
И аналогично с другими возможными паттернами.
count - вернет количество записей
exists - вернет boolean. Сущестует такая запись или нет.
delete/remove - для удаления. Как видим, вставлять или добавлять записи в случае PartTreeQuery не получится.

![[Pasted image 20240908142423.png]]
Например, напишем метод, который возвращает Company по названию компании. name - поле в Company, но т.к. CamelCase, то с большой буквы. И автоматически SpringJpa создаст CriteriaApi, привяжет ее к методу findByName(в Map<Method, RepositoryQuery). Spring это делает 1 раз, когда поднимает наш IoC Container.
![[Pasted image 20240908142504.png]]

Напишем вот такой метод
![[Pasted image 20240908143021.png]]
All - когда хотим получить список сущностей.
Containing - аналог LIKE, только с процентами слева и справа. Т.е. получается, что %fragment%.
IngoneCase - игнорирование регистра.
Помимо Collection мы можем еще и получать stream, но нужно его самостоятельно закрывать.

Если название метода не удовлетворит регулярному выражению, то произойдет ошибка. Про все вариации шаблонов нужно читать в документации.![[Pasted image 20240908143445.png]]
Но у всего есть недостатки. В случае сложных запросов очень сильно расширяется название метода, когда нужно сделать и поиск и сортировку и еще несколько условий в where. Поэтому используются другие RepositoryQuery реализации в более сложных запросах.

### Специальные параметры, которые мы можем передавать в запросы
Как видим, мы можем использовать некоторые ключевые слова между find и By.
![[Pasted image 20240908162538.png]]
- All - если возвращаем список
- User - идентичен findBy
- Distinct - добавляется ключевое слово DISTINCT.
- Users - аналог All
- First - находит первый элемент из выборки и возвращает его, если он есть. Но в таком случае я должен передать сортировку, т.к. непонятно по какой логике я буду выбирать первый номер. Сортировку мы можем передать в имени метода. Тогда получаем 
  ```java
  Optional<User> findFirstOrderByIdDesc();
  //можем получать первые N(в данном случае 3) элементов выборки, у которых 
  //birthDate < того параметра, что мы передадим
  //(за эту функцию отвечает) BirthDateBefore
  //Но видим, что название метода получилось очень большое, поэтому лучше использовать
  //@Query
  List<User> findFirst3ByBirthDateBeforeOrderByBirthDateDesc(LocalDate birthDate); 
  ```
  Но писать каждый раз новый метод для сортировки по тому или иному полю - плохая идея. Поэтому можно написать один общий метод и передавать туда сортировку.
- Top - аналог First. 

Вот так мы можем использовать сортировку:
![[Pasted image 20240908165202.png]]
И теперь создаем сортировку по любому полю, по которому захотим и передаем ее в написанный метод.
![[Pasted image 20240908165255.png]]
Несколько сортировок:
![[Pasted image 20240908165353.png]]
Но тут мы хардкодим названия полей, что не очень хорошо, поэтому лучше использовать более безопасный вариант:
![[Pasted image 20240908165621.png]]

[[Pageable]] - еще один параметр, который мы можем передавать в наши запросы.