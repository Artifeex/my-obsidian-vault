И NativeJpaQuery и SimpleJpaQuery являются реализациями RepositoryQuery интерфейса и использует аннотацию @Query.
@Query ставится над методом.
### Что внутри @Query?
![[Pasted image 20240908145251.png]]
- nativeQuery - как раз и делает разницу между Native и Simple Jpa Query. По умолчанию false. Т.е. используется Simpe Jpa Query. Т.е. используем HQL. Если же установим nativeQuery = true, то сможем использовать SQL.
- value - пишем сам запрос(HQL или SQL)
- name - возможность указать именованный запрос([[NamedQuery]]) явно! 
- countQuery - HQL запрос на count(когда возвращаем количество записей)
- countProjection - если используем проекции.
- countName - именованный запрос на count

![[Pasted image 20240908145755.png]]
И как мы говорили на курсе по Hibernate внутри HQL мы можем еще и fetch запросы делать, чтобы подтягивать одним запросом и lazy сущности. Например:
![[Pasted image 20240908145850.png]]

Напишем вот такую реализацию. Важно, что нужно заметить, что когда мы используем like % символ никто за нас ставить не будет, как это было в том случае, когда мы использовали [[PartTreeQuery]] вместе с containing.
![[Pasted image 20240908150105.png]]

Но благодаря Spring Data Jpa он дополнил немного HQL(в котором нельзя использовать "%"). Теперь мы можем использовать "%":
![[Pasted image 20240908150425.png]]

Нативный запрос. Но на самом деле нативные запросы вот так не используются. Нужно дополнительно еще передавать ResultSet, в котором будет название полей в нашей сущности для маппинга. 
Но еще нативные запросы можно использовать вместе с проекциями. А вообще, HQL удовлетворяет практически большинству запросов, которые нам понадобятся + удобный fetch механизм, с помощью которого можно забирать lazy зависимости при необходимости, решая [[Проблема N+1|проблему N+1]].
![[Pasted image 20240908150804.png]]

### Использование @Query для обновления и добавления сущностей
Напишем запрос, который изменяем Role у переданных по id пользователей. Если не будем использовать @Modifying, то произойдет исключение. По умолчанию @Query работает только с read запросами. Если хотим как-то изменять и добавлять данные, то используется @Modifying.
![[Pasted image 20240908155539.png]]

При этом запрос происходит вне persistentContext. Т.е. если мы обновили сущности в БД, но у нас в приложении в persistenContext хранятся те сущности, которые были обновлены в БД, то они не будут синхронизированы с БД! Т.е. если мы для user с id = 1 получили его, т.е. он сохранился в persistenContext, дальше мы с помощью @Query изменили у него какое-то поле в БД, то наш user в persistentContext не обновит это же поле! Поэтому мы должны убрать не синхронизированные сущности из persistentContext. Но проблема в том, что мы не знаем, какие сущности были обновлены, поэтому единственный вариант - почистить весь persistentContext.
Для этого в @Modifying есть:
- clearAutomatically - чистит весь persistentContext после выполнения запроса. Это нужно, чтобы, если мы сделали entityManager.find(id), то, чтобы entityManager не вернул нам значение из [[PersistentContext]], который является кэшем 1-го уровня в Hibernate, а сходил в БД и получил уже обновленные данные!
- flushAutomatically - если мы изменили какие-то сущности, которые лежали в persistentContext, то если мы сделаем очищение persistentContext, то эти изменения не сохранятся. Поэтому это свойство включает вызов flush перед вызовом Query. Причем исходя из 3-го пункта в [[Когда вызывается flush?]] мы можем отключить это поведение по умолчанию для всех методов в Hibernate. Т.е. по умолчанию это свойство включено, т.е. будет вызван сначала flush, если мы сделали любой Query запрос, но если мы отключили это поведение настройками Hibernate, то можем явно для каких-то методов указать, чтобы flush все-таки происходил.

Нужно проявлять некоторую осторожность при работе с сущностями, которые удалились из persistentContext. lazy initialization exception возникнет из-за того, что ivan - detached сущность, т.е. с ней нет ни одной связанной session. 
![[Pasted image 20240908162133.png]]

Поэтому нужно решать самому, насколько критично не получение обновлений для старых сущностей. И нужно либо с ними работать аккуратно, либо добавлять обратно в persistentContext, обновив поля(наверное, используя refresh?)

