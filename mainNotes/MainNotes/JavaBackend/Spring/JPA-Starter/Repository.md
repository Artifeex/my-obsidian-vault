Дефолтный Repository интерфейс. Мы можем больше не использовать @Repository над ним, поскольку в @Conditional в фильтрах может быть поиск по assignedFrom и в данном случае так и происходит. Ищется наследники от Repository. Реализацию данного интерфейса предоставит нам Spring.
![[Pasted image 20240908133947.png]]
И дальше мы можем просто использовать этот интерфейс! 
entityManager.flush() - используется, т.к. delete метод не вызывается сразу же, а только при flush сессии.
![[Pasted image 20240908134148.png]]
Как это все работает? У нас есть JpaRepositoriesAutoConfiguration, который занимается тем, что ищет все классы(интерфейсы), который реализует интерфейс Repository(это чисто интерфейс метка, в нем нет никаких методов) и на основании них создавать proxy реализации!
Есть JpaRepositoriesRegistrar, который на основании классов, реализующих интерфейс Repository будет создавать beanDefinition. Из которых потом и создаются бины.

### Разберемся, как предоставляется функционал в Repository классы, когда мы написали только сигнатуру метода, без ее реализации
Создается dynamic proxy, используя AOP. Но там на самом деле как будто proxy, поверх proxy. Т.к. у нас уже много дополнительно функционала поверх вызова обычного метода. Например, мы работаем с транзакциями - первое прокси, мы работаем с исключениями - второе и т.д. И добавление реализации в нереализованные методы - это также вызов еще одного прокси метода - QueryExecutorMethodInterceptor. 
Внутри он создает queries. Ключом является метод, который вызвали в Repository, а значением RepositoryQuery
![[Pasted image 20240908135533.png]]
RepositoryQuery - является самым главным интерфейсом всех запросов.
![[Pasted image 20240908135609.png]]
Основные реализации RepositoryQuery:
- [[NamedQuery]] 
- NativeJpaQuery - использует SQL. Необходима аннотация @Query. [[NativeAndSimpleJpaQuery]]
- [[PartTreeQuery]] - возможность создавать запросы просто по именованию. Т.е. соблюдая определенный шаблон, мы можем распарсить название метода с помощью регулярок и представить запрос, используя [[CriteriaAPI]]. И в нашем случае, когда мы просто написали названия у методов - этот вариант и произошел!
- SimpleJpaQuery - использует HQL. Необходима аннотация @Query. [[NativeAndSimpleJpaQuery]]
- StoredProcedureJpaQuery - не будем использовать, т.к. вызов хранимых процедур в БД не используется в наше время, только в легаси. Вся логиика должна быть на уровне Java приложения.
Т.е. у нас есть 5 стратегий, по которым будут реализовываться методы в нашем Repository интерфейсе.

Для дефолтных CRUD операций мы можем не писать их сами! Мы можем просто использовать CrudRepository интерфейс вместо просто Repository!
![[Pasted image 20240908140910.png]]
Но если мы хотим еще и для findAll метода иметь возможность сортировки и пагинации, то используем PagindAndSortingRepository
![[Pasted image 20240908141015.png]]
Но если нам и этого не хватает, то мы можем использовать JpaRepository. Там появляется удаление Batch-ем. flush метод, saveAndFlush.

Есть класс SimpleJpaRepository, который реализует JpaRepository интерфейс. Именно ему происходит перенаправление наших запросов! В нем они реализованы! Но, если нам не будет чего-то хватать, то уже будем использовать реализации RepositoryQuery.

Стоит заметить, что нам доступны все средства по оптимизации запросов из Hiberntate. Например, [[Работа с EntityGraph]].

### @Lock
С помощью этой аннотации можно устанавливать оптимистические или пессимистические блокировки строк.![[Pasted image 20240909094137.png]]
- OPTIMISTIC - оптимистическая блокировка.![[Pasted image 20240909094215.png]]
  Используется @Version и дополнительное поле Int.
- OPTIMISTIC_FORCE_INCREMENT - разница от OPTIMISTIC в том, что OPTIMISTIC увеличивает значение version только если сущность была изменена. А OPTIMISTIC_FORCE_INCREMENT всегда увеличивает версию, даже если мы просто достали сущность из БД
- READ, WRITE - старые, вместо них OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT сооотвественно.
- PESSIMISTIC_READ - используется SELECT FOR SHARE
- PESSIMISTIC_WRITE - используется SELECT FOR UPDATE
- PESSIMISTIC_FORCE_INCREMENT - одновременная блокировка и на уровне БД и на уровне Java приложения.

### @QueryHints
![[Pasted image 20240909094741.png]]
forCounting - использовать ли hints для counting доп запросов в [[Pageable]].
Через hints можно задавать различные настройки для hibernate запросов. timeout установить, readOnly режим, кэширование, fetchSize и т.д.
![[Pasted image 20240909095038.png]]

### Custom Repository
Когда нам не хватает того, что предоставляет JpaRepository мы можем написать свой кастомный репозиторий. Например, мы хотим использовать для каких-то запросов CriteriaApi, чтобы можно было создавать динамические запросы с фильтрацией, которая также приходит динамически.
Создадим фильтр, по которому будем искать пользователей:
![[Pasted image 20240909103234.png]]
Создаем интерфейс для репозитория для кастомного функционала, который мы хотим добавить. Название не важно, но лучше следовать шаблону из Repository Jpa, чтобы было привычно работать с этими методами.
![[Pasted image 20240909103256.png]]

А дальше мы создаем реализацию этого репозитория! Но важно, что реализация должна иметь Такое же название + "Impl" в конце. Это нужно для Spring, чтобы он при вызове метода интерфейса связал этот вызов с методом из реализации. Добавление "Impl" в конце - это настройка из JpaAutoConfiguration, которую мы можем поменять(но так не делают).
Таким образом, нам нужно создать реализацию FilterUserRepositoryImpl:
![[Pasted image 20240909103630.png]]

Теперь, чтобы не потерять функциональность внутри интерфейса репозитория, которую нам дал JpaRepository с его удобными CRUD методами, мы просто extends от еще одного интерфейса нашего кастомного репозитория, который мы написали! 
![[Pasted image 20240909103702.png]]

Использование:
![[Pasted image 20240909103904.png]]
И Spring при вызове этого метода спроксирует вызов на FilterUserRepositoryImpl метод, т.к. благодаря Impl он связал FilterRepository и его реализацию.



