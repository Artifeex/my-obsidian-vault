Основная информация находится в [[Hibernate From Notion 2]]. Нам здесь интересно, как использовать EntityGraph на уровне Repository.
Для этого есть @EntityGraph над методом репозитория.
![[Pasted image 20240908180443.png]]
- value - название именованного графа.
- type - FETCH или LOAD. FETCH - все связи в нашей сущности будут LAZY и только те, что мы укажем в графе будут загружаться сразу же. LOAD - все связи такие, как написаны в сущности. Если в сущности для OneToOne по дефолту EAGER, то и будет использоваться EAGER.
- attributePaths - когда динамически определяем те свойства наших сущностей, которые мы хотим подтянуть.

### Использование свойства value
Сначала создаем сам EntityGraph
![[Pasted image 20240908181543.png]]
И используем имя из @NamedEntityGraph:
![[Pasted image 20240908181633.png]]
Но удобнее всего использовать attributePaths для динамического создания EntityGraphs.
### Использование attributePaths
Все очень просто! Указываем названия полей в сущности User, которые мы хотим поднять и все! Т.е. мы хотим подтянуть вместе с User еще и company поле.
![[Pasted image 20240908181837.png]]
А чтобы сделать subgraph, то для этого просто используем company.locales. Т.е. теперь подтянется и company, а внутри company подтянется поле locales! Но в таком случае Pageable будет работать неправильно! Поскольку теперь для одного User будет возвращаться сразу несколько строк из-за того, что User притянул Company. А Company притянуло locales, и если у одной компании сразу несколько locales, например, 2. То тогда мы получим две строчки для одного и того же юзера с одной и той же компанией, но с двумя разными locales.
![[Pasted image 20240908181930.png]]

И при работе с [[Pageable]] перформанс нашего приложения очень упадет. Т.к. теперь не используется LIMIT и OFFSET на уровне БД, т.е. они просто не появляются в запросе и наше Java приложения получает сразу всех пользователей, потом выбирает из них 2-х и отбрасывает остальные(а это очень тяжелые операции). И потом при запросе на получение следующей страницы, приложение снова делает запрос и получает ВСЕХ пользователей и снова только 2-х из них отбрасывает и т.д. 

Таким образом, если мы используем EntityGraph или другие способы решения [[Проблема N+1|проблемы N+1]], то лучше не использовать ничего, что связано с пагинацией или LIMIT и OFFSET.