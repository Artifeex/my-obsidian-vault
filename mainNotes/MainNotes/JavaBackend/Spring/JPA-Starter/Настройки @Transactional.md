- value и transactionManager(alias для value). Мы можем указать id из IoC Container того TransactionManager, который будет управлять @Transactional. Мы можем в нашем приложении поддерживать несколько TransactionManager. Но чаще всего нас устраивает один, который создается в JpaBaseConfiguration.
- propagation - именно эта настройка отвечает за то, как взаимодействуют между собой cglib proxy, а именно открывать или не открывать новую транзакцию. [[Propagation strategies]]
- isolation - [[Уровни изолированности транзакции]]. По умолчанию значение DEFAULT - определяется в зависимости от выбранной СУБД. Но уровень транзакции, который мы указывает внутри @Transaction будет влиять только в случае, если при вызове метода создавалась новая транзакция. Если не создавалась, то будет использоваться тот уровень транзакции, который установился при создании транзакции где-то раньше у одного из cglib proxy. Если хотим, чтобы точно использовался тот isolation level, который мы установим, то тогда нужн использовать propagation REQUIRES_NEW.
- timeout - работает аналогично isolation. Т.е. влияет только в том случае, если транзакция открылась в вызове метода. 
- readOnly - если происходит только чтение данных в нашем методе, то полезно использовать эту настройку. Поскольку происходит [[Оптимизация при использовании readOnly]].
- rollbackFor - в каких случаях и каких exception нужно делать rollback транзакции. И по умолчанию происходит rollback только в случае Runtime Exception и Error. Но если у нас есть какие-то checked exception в нашей бизнес логике, то их нужно явно сюда добавлять, если мы хотим, чтобы произошел rollback. 
- rollbackForClassname - аналог предыдущей, если нет доступа к классу, то можем установить его название через String.
- noRollbackFor - в каких случаях не откатывать транзакцию
- noRollbackForName.
На практике чаще всего будет использовать @Transcational без каких-либо настроек, т.к. дефолтное поведение нас вполне устраивает.