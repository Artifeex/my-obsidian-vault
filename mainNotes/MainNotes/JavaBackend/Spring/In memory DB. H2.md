Проблема описана в [[Тестирование с использованием тестовой БД]]
Реализуем in memory DB вариант для тестирования. 
Добавляем зависимость на H2 БД.
![[Pasted image 20240909210900.png]]

В application-test.yaml(файлик с properties для тестов) настраиваем подключение к H2(url, passowrd, username для подключение находим в документации):
![[Pasted image 20240909211131.png]]
Мы оставили jpa: properties.hibernate: hbm2ddl.auto: update - чтобы использовать Hibernate для накатывания DDL схемы(ну т.е. для поднятия БД(даже in memory) нам же нужны таблицы. Откуда их взять? Их можно взять, используя Hibernate сущности). Поэтому для создания таблиц и будет использоваться Hibernate(на самом деле - это не очень хорошо, что мы использем Hibernate для этих целей, но мы пока не знаем миграционного фреймворка, но в будущуем узнаем о [[Liquibase]]).

Теперь, если мы запустим наши тесты, то увидим в консоли как вызываются DDL операции для создания таблиц, используя Entity из Hibernate. Но при этом никаких данных в таблицах не будет! Для данных мы должны иметь специальные sql скрипты, в которых находится DML операции, в которых и находятся данные для тестов. Эти скрипты автоматически запускают перед каждым тестом. Но как нам сделать так, чтобы выбранные скрипты запускались перед каждым тестом?
![[Pasted image 20240909211652.png]]

Для этого нужно использовать @Sql над классом с тестами и внутрь передается массив String[] с путями до sql скриптов, которые нужно выполнить. Т.е. мы можем выполнять сразу множество скриптов перед запуском каждого теста!
![[Pasted image 20240909212133.png]]
Также стоит добавить, что мы должны хранить такие файлы со скриптами в папке ресурсов для тестов.
![[Pasted image 20240909212046.png]]

Аннотацию @Sql можно ставить не только над классом, но и над методом теста. Тогда переданные скрипты будут выполнены перед выполнением этого теста.

Очень советует использовать точно такую же комбинацию. Мы 1 раз поднимаем БД перед запуском тестов(как угодно, можем in memory, можем через docker полноценную), потом с помощью migration framework накатываем данные на поднятую БД перед запуском каждого теста.
