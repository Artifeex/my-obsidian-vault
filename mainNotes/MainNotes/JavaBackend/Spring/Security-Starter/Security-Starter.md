Вспомним, что такое [[Авторизация]] и [[Аутентификация]].
### Вспомним, как происходила авторизация и аутентификация при использовании Servlets
![[Pasted image 20240915165540.png]]
Аутентификация и авторизация происходила с помощью фильтров. Это обычные классы, которые реализовывали интерфейс фильтр. И они срабатывали ДО того, как вызвали нас сервлет. Поэтому это и называется фильтрами, поскольку они могут отфильтровать запрос раньше и вернуть response до того, как запрос дойдет до DispatcherServlet. И т.к. таких фильтров может быть много на 1 DispatcherServlet, то из фильтров образуется цепочка фильтров - FilterChain.
### Жизненный цикл фильтров
1. Один раз вызывается метод init при создании фильтра.
2. Далее постоянно при запросах вызывается метод doFilter, где и содержится основная логика по фильтрации и аутентификации и авторизации.
3. destroy при удалении.

### Нюансы фильтров в Spring
![[Pasted image 20240915170002.png]]
У нас все также есть FilterChain, но в ней есть специальный фильтр DelegatingFliterProxy. Внутри него содержится объект FilterChainProxy, который является Spring Bean, который содержит цепочку Security фильтров. И эта цепочка фильтров называется SecurityFilterChain. Другими словами, мы вынесли все фильтры, которые относятся к спрингу в отдельную цепочку, которая уже работает как Bean и подчиняется beanLifeCycle, а не FilterLifecycle(это из-за того, что эта цепочка лежит внутри FilterChainProxy, который является бином). Но при этом сами фильтры все также остались фильтрами, т.е. реализуют интерфейс фильтр.

Порядок фильтров важен! Например, сначала должен быть вызван AuthenticationFilter, а потом только Authorization. Поскольку сначала мы должны аутентифицировать пользователя, т.е. узнать, кто к нам вообще пришел. А потом только проверять его действия на то, может ли он их выполнять или нет.

Подключим SpringSecurity:
![[Pasted image 20240915170626.png]]

Можем настраивать SpringSecurity с помощью yaml:
![[Pasted image 20240915170743.png]]
Внутри автоконфигурации Spring Security создается как раз bean, который отвечает за Security Filter Chain
![[Pasted image 20240915171016.png]]
И мы будем настраивать как раз SecurityFilterChain.

### Изучим архитектуру аутентификации в Spring приложении
Начнем с модели. Т.е. где мы будем хранить пользователя, который прошел аутентификацию.
![[Pasted image 20240915171142.png]]
Самый главный объект - это SecurityContext, который является оберткой над Authentication объекта, который хранит в себе 3 значениея:
1. Principal - это по сути наш UserDto. Т.е. это объект, который реализует интерфейс UserDetails и хранит информацию про нашего пользователя. Мы сами решаем, что туда поместим.
2. Credentials - это пароль. Но это поле часто чистится сразу же после аутентификации, чтобы пароль не гулял по всему нашему приложению.
3. Authorities - роли. Т.е. обычные роли пользователя. Их может быть много, поэтому это список. Каждая роль должна реализовывать интерфейс GrantedAuthoritys.

Authentication - мы создаем на основе информации, полученной со страницы login.
И для того, чтобы получить SecurityContext, который хранит всю необходимую информацию для авторизации и аутентификации для нашего пользователя мы будем использовать SecurityContextHolder. В нем есть различные стратегии хранения SecurityContext, мы будем использовать ThreadLocal. 
Каждый раз, когда нам нужно будет получить SecurityContext, т.е. текущего пользователя, то мы будем обращаться к SecurityContextHolder. Когда приходит запрос и пользователь проходит аутентификацию, то мы сохраняем его в SecurityContext. Потом выполняем на сервере код для создания ответа. И потом, когда отправили ответ, то очищаем SecurityContext.

Теперь разберем логику работы самого фильтра, потому что до этого была модель.![[Pasted image 20240915172159.png]]
На первом шаге создаем Authentication объект, который хранит 3 значения(principal, credentials, authorities). После этого мы получаем AuthenticationManager и передаем в его метод authenticate наш Authentication объект. А внутри AythenticationManager он проходит циклом по всем Authentication Providers(т.е. их может быть несколько настроено в приложении) и по очереди пытается провести аутентификацию. И как только хотя бы один из таких провайдеров прошел, то, значит, такой пользователь действительно есть и он прошел аутентификацию.

Посмотрим, какие фильтры вызываются, когда мы делаем запрос:
![[Pasted image 20240915172800.png]]
![[Pasted image 20240915172946.png]]
![[Pasted image 20240915173046.png]]
И если посмотреть подробнее эти SecurityFiltherChain:
![[Pasted image 20240915173209.png]]
5 - фильтр, который будет заниматься как раз аутентификацией по логину и паролю
6- фильтр, который генерирует дефолтную страничку логина
7 - генерация logout странички.
И теперь, когда мы делаем запрос на users/, т.к. мы не аутентифицированы в системе, то произошел редирект на страничку с логином.
![[Pasted image 20240915173335.png]]
По умолчанию Spring Security создает дефолтного пользователя, через которого мы можем залогиниться. Логин у него user, а пароль генерируется каждый раз и выводится в консоли при запуске приложения. После ввода этих данных мы попадем на нашу страничку.![[Pasted image 20240915173458.png]]
Как мы проходили на курсе HTTP Servlets сессия пользователя привязывается к cookie. И если мы авторизованы, то в cookie хранится JSESSIONID, которая передается при запросах на сервер.
![[Pasted image 20240915173624.png]]
На сервере хранится Map всех JSESSIONID и наших пользователей. И если в этой маппе есть пользователь по данной куке, то данный пользователь существует и он прошел аутентификацию в приложении. Поэтому если ее удалить, то мы будем снова считаться на аутентифицированными. 

### Dao Authentication Provider
Используется для того, чтобы проводить аутентификацию пользователей, хранящихся в БД.
Если зайдем внутрь, то увидим, что он использует PassowrdEncoder, а это означает, что все пароли будут закодированы.
![[Pasted image 20240915174106.png]]
Также внутри этого провайдера хранится поле типа UserDetailsService. Посмотрим, что в этом интерфейсе. А в нем есть метод loadUserByUsername, который возвращает UserDetails по username. И в UserDetails(это интерфейс) уже находится основная информация о пользователе, т.е. по сути это наш DTO. Но чтобы нам не реализовывать этот интерфейс отдельно и не создавать отдельный DTO мы можем использовать готовый.
![[Pasted image 20240915174157.png]]
Готовый класс User:
![[Pasted image 20240915174417.png]]
Интерфейс GranderAuthorities - это интерфейс с одним методом - getAuthority. Т.е. строковое представление наших полей. USER, ADMIN и т.д.
![[Pasted image 20240915174500.png]]
И внутри главного метода нашего DaoProvidera мы будем использовать UserDetailsService, который мы должны реализовать. Важно, что если пользователь не был найден, то нужно самостоятельно пробросить исключение UsernameNotFoundException.
![[Pasted image 20240915174617.png]]
Теперь добавим в БД колонку с паролем. В ней будет хранится закодированный пароль.
![[Pasted image 20240915174838.png]]
В DEFAULT мы написали дефолтный пароль для наших пользователь, а {noop} означает, что он будет хранится без кодировки. Т.е. это именно "123" нужно хранить без кодировки. А если пользователь будет вводить свой пароль, то он будет кодироваться.

Также добавляем поле в User в Entity:
![[Pasted image 20240915174951.png]]

Реализуем интерфейс GrantedAuthority для наших ролей.
![[Pasted image 20240915175025.png]]

Осталось реализовать UserDetailsService. Он будет у нас один на все Spring приложение, а это, значит, что Spring найдет этот bean и заинжектит его в DaoAuthenticationProvider. Проще всего реализовать этот интерфейс в нашел UserService классе.
![[Pasted image 20240915175142.png]]

Далее мы должны реализовать метод из этого интерфейса loadUserByUsername.
Для этого сначала в репозитории создаем метод, который будет находиться пользователя по имени пользователя:
![[Pasted image 20240915175249.png]]
Теперь реализовываем сам метод loadUserByUsername
![[Pasted image 20240915175434.png]]
После этого при вводе значений в форму логина мы попадаем в метод loadUserByUsername. И после того, как мы вернем USerDetais будет проводиться процедура проверки пароля! Т.е. пароль, что передал пользователь - шифруется и сравнивается с зашифрованным в БД. Таким образом, для реализации DaoAuthenticationProvider нам нужно просто реализовать интерфейс UserDetailsService в каком-нибудь из бинов. Реализовать метод из него, который возвращает UserDetails, в котором хранятся username, password, authorities. И этот UserDetails используется для дальнейшей работы.

### Form login
Как мы видели - есть фильтр, который генерирует страничку по умолчанию. По правилу хорошего тона мы должна переопределить эту страничку на свою.
![[Pasted image 20240916092447.png]]
Самое важное, чтобы форма отправляла username и password именно с такими именами, т.к. такие параметры ожидает Spring.
Spring передаем ошибку, связанную с credentials в param.error
![[Pasted image 20240916092606.png]]
В контроллере логина мы должны оставить гет маппинг для получения странички формы. 
![[Pasted image 20240916092659.png]]
Но нам еще нужно заменить форму, которую будет возвращать Spring по умолчанию. Для этого нужно создать свою конфигурацию и переопределить HttpSecurity.
![[Pasted image 20240916093402.png]]
И важно заметить, что как только мы переопределили configure, то мы отключили настройку по умолчанию для HTTPSecurity, которое было внутри SpringBootWebSecurityConfiguration:
![[Pasted image 20240916093449.png]]
Теперь, если введем неправильный пароль, то как раз spring вернет ошибку в ${param.error}
![[Pasted image 20240916093542.png]]

### HTTP-Basic Authentication
На прошлом занятии мы рассмотрели один из вариантов AuthenticationFilter - это UsernamePassowrdAuthenticationFilter.
Через логин форму, используя этот фильтр мы проходили процесс аутентификации. Но на самом деле есть другие реализации AuthenticationFilter. Один из которыз HTTP-basic authentication filter.
![[Pasted image 20240916094109.png]]
Аутентификация через HTTP-basic происходит с помощью хедеров. 
У нас есть хедер Authorization. Его значение начинается с "Basic" и дальше идет base64(username:password). Далее, используя кодировку base64 и конкатенацию строку username+password строка кодируется. И дальше уже такая строка передается на сервер. И на сервере, если подключено HTTP-basic аутентификация, то происходит аутентификация.
![[Pasted image 20240916094615.png]]
![[Pasted image 20240916094707.png]]
Теперь у нас нет login странички, а идет сразу дефолтная форма HTTP basic.
Как видим, когда мы обратились по users/5, то т.к. мы не авторизованый пользователь, то видим статус код 401. 403 - когда доступ запрещен.
![[Pasted image 20240916094745.png]]
В response мы видим header WWW-Authenticate. По этому хедеру браузер понял, что в приложении подключена HTTP-basic аутентификация. Поэтому он отобразил форму, которую мы увидели выше.
![[Pasted image 20240916095036.png]]
И теперь, когда мы введем данные в форму, то придетс респонс со статусом 200 и мы получим страничку users. А в хедерах будет хедер Authorization: Basic и закодированная в base64 строчка с логином и паролем.
![[Pasted image 20240916095230.png]]
А на сервере эта строка раскодируется для извлечения username и password. Потом они используются для создания объекта Authentication. Вот код аутентификации:
![[Pasted image 20240916095514.png]]
### Password Encoder
В БД должен быть всегда зашифрованный пароль, чтобы мы не могли узнать настоящий пароль, даже если у нас будет прямой доступ к БД.
И когда пользователь вводит пароль, который он знает, это пароль приходит к нам на сервер. Потом шифруется. И при аутентификации мы сравниваем два зашифрованных пароля. Один из БД, который мы получили, сделав поиск по Username в методе loadUserByUsername и создав объект UserDetails, в котором как раз будет храниться зашифрованный пароль из БД. А потом уже, в одном из фильтров сравнивается зашифрованный пароль из UserDetails и зашифрованный пароль, который пришел извне. 
В DaoAuthenticationProvider как раз и устанавливаются password encoderds.
![[Pasted image 20240916100816.png]]
Есть Map всех энкодеров, которые поддерживаются в Spring Security:
![[Pasted image 20240916100414.png]]
Т.к. encoder - это не SpringBean, то мы не сможем получить к нему доступ напрямую, чтобы вызывать методы для кодирования и декодирования. Но нам такой функционал потребуется, когда будет реализовывать регистрацию и кодировать пароль. Поэтому в SecurityConfiguration классе, который мы создали ранее создаем Bean с получением PasswordEncoder. Вызывается метод, который на скрине выше.
![[Pasted image 20240916101130.png]]
Теперь напишем страничку для регистрации и добавим в ней формы ля ввода логина и пароля
![[Pasted image 20240916101450.png]]
Теперь пишем Dto для приема этой формы.
![[Pasted image 20240916101552.png]]
И теперь нам нужно переделать mapper, который смаппит dto на entity. И тут нам и понадобится наш passowrdEncoder, чтобы rawPassword, который пришел с формы можно было закодировать.
![[Pasted image 20240916101733.png]]
![[Pasted image 20240916101931.png]]
В контроллере в методе create после создания пользователя редиректим на страницу login, чтобы он мог залогиниться.
![[Pasted image 20240916102026.png]]
Теперь в password столбце в БД после регистрации будет храниться закодированный пароль.
![[Pasted image 20240916102244.png]]
Именно потому что владельцы сайтов хранят закодированные пароля, они не могут вернуть нам пароль и при восстановлении пароля мы создаем новый!

### Logout
Для этого в SpringSecurity есть LogoutFilter. Внутри он просто чистить сессию. Т.е. очищает Map, в котором хранится JSESSIONID.
Настроить можем все в том же SecurityConfig.
![[Pasted image 20240916104156.png]]
После этого, добавили кнопку, которая делает POST запрос на /logout, который мы указали при настройке HttpSecurity.

### Authorization architecture
![[Pasted image 20240916104822.png]]
AuthorizationFilter срабатывает самым последним в SecurityFilterChain и нужен для проверки прав доступа к тем или иным ресурсам. Т.е. проявляется authorities у объекта Authorization.

Внутри AuthorizationFilter используется AuthorizationManager и у него вызывается метод verify.
![[Pasted image 20240916105144.png]]
Внутри AuthorizationManager мы должны переопределить метод check, который возвращает AuthorizationDecision(внутри просто boolean поле, которое равно true, если доступ разрешен и false, если нет). Далее на основе decision решается, есть доступ или нет. Если нет, то выбрасывается исключение AccessDeniedException. Его отлавливает Spring и возвращает 403 статус.
![[Pasted image 20240916105111.png]]
В методе check приходит объект authentication и object - как раз тот ресурс, который хочет получить пользователь. 
![[Pasted image 20240916105405.png]]

Есть уже готовые реализации AuthorizationManager:
![[Pasted image 20240916105804.png]]
- AuthenticatedAuthorizationManager - проверяет только то, что пользователь аутентифицирован.
- AuthorityAuthorizationManager - уже проверяет роли.
- Jsr250 - Java EE спецификация по Security.
- PostAuthorize - позволяет использовать аннотацию @PostAuthorize.
- PreAuthorize -  позволяет использовать аннотацию @PreAuthorize.
- SecuredAuthorizationManager -позволяет использовать аннотацию @Secured.
- RequestMatcherDelegationAuthorizationManager - самый главный и используется по умолчанию. Суть в том, что он по какому-то пути определяет есть ли доступ к ресурсу у пользователя. И это проверку он делегирует эту проверку на другие AuthorizationManagers, которые мы рассмотрели выше.

![[Pasted image 20240916110541.png]]

Первое, что мы должны сделать - это использовать authorizeHttpRequest, а не authorizeRequest - это нужно для того, чтобы в filterChain использовался не старый FIlterSecurityInterceptor, а более новый authorizationFilter.
![[Pasted image 20240916110703.png]]
Теперь настройки по доступу к ресурсам производятся внутри authorizeHttpRequests. Там мы пишем через antMathcers URL для которых проверяем доступ и потом какую authority должен иметь:
![[Pasted image 20240916111444.png]]
- permitAll() - разрешили всем доступ на страницу логина, регистрации и сваггера. Причем не аутентифицированным пользователям тоже.
- hasAuthority() - передаем строковое представление нашей роли. Т.е. "ADMIN". Есть есть hasRole. Отличие в том, что если мы передаем строку в hasRole, то строка должна иметь префикс "ROLE_". Т.е. если бы использовали hasRole(), то должны были передать "ROLE_ADMIN". Но мы реализовали ранее в enum классе интерфейс Authority, в котором просто возвращаем строковое представление роли.
- anyRequest().authenticated() - для всех других запросов нужно, чтобы пользователь был аутентифицирован, но конкретно роль его уже не проверяется. 
Причем важно заметить, что порядок, в котором мы указываем доступ к URL имеет значение! Эти URL сохраняются в Map, как мы и говорили ранее, в которой каждому URL ставится AuthorizationManager, который будет работать с данным URL. И эта Map на самом деле LinkedHashMap. И при поиске AuthorizationManager, который будет обрабатывать URL просто идет массивом по мапе в том порядке, в котором они добавлялись в нее. Поэтому нужно ставить anyRequest().authenticated() в конце. Т.к. под anyRequest попадает любой реквест, т.е. если бы он стоял в начале, то все запросы сразу бы попадали в этот обработчик и другие бы уже никак не могли повлиять. Еще стоит заметить, что для каждого матчера создается свой AurhotizationManager, т.е. на скрине выше создалось 4 таких.

permitAll просто реализует функциональный интерфейс AuthorizationManager, в котором ничего не проверяет и говорит, что доступ разрешен. denyAll наоборот.
![[Pasted image 20240916111236.png]]

### Method Security
Из-за множества реализаций AuthorizationManager мы можем настраивать доступ также с помощью аннотаций.
Используем аннотацию @PreAuthorize на метода контроллера findById, чтобы к этому методу мог обращаться только ADMIN. @PreAuthorize означает, что мы будем проверять права доступа перед входом в метод findById. 
![[Pasted image 20240916113224.png]]
С помощью @PostAuthorize мы можем написать какие-то доп проверки, используя возвращаемое значение, которое сохранится в returnObject. Но чаще всего мы будем использовать @PreAuthorize
![[Pasted image 20240916113418.png]]

Но, чтобы эти аннотации работали нужно использовать аннотацию![[Pasted image 20240916113553.png]]
Внутри этой аннотации есть свойство prePostEnabled, внутри которого мы как раз и включили обработку аннотаций. Причем еще включили @PreFilter и @PostFilter
![[Pasted image 20240916113735.png]]
И эта аннотация может еще подключить Jsr250 и SecuredAuthorizationManager, который использует аннотацию @Secured. В @Secured мы просто добавляем роли. Но ее щас особо не используют, потому что удобнее использовать @PreAuthorize. Поэтому поддержка этой аннотации и включается по умолчанию(defualt true), а в других default false;
![[Pasted image 20240916113844.png]]

Но еще очень круто то, что мы теперь можем использовать @PreAuthorize нам методами не только контроллеров, но и сервисов!!
![[Pasted image 20240916114057.png]]
И все эти аннотации проверяются с помощью AOP Proxy про него мы поговорим в аспектно ориентированном программировании.

@PostFilter - можем повесить над методом, который возвращает List, Stream. Нужен для того, чтобы дополнительно дофильтровать результирующее значение метода. Внутрь передается SpEL, с помощью которого и можем делать доп фильтрацию.

Два примера использования(работать они не будут, потому что тут Page возвращается, но если бы возвращался какой-нибудь List, то работало бы).
![[Pasted image 20240916114613.png]]
С помощью filterObject - мы получаем элемент коллекции. Т.е. на скрине выше это USerReadDto. И дальше пишем фильтр для этого элемента, и если выражение вернет true, то значит, он проходит и вернется как один из элементов коллекции.
Но и т.к. это SpEL, то мы можем даже обращаться к другим spring beans и например, проверить через companyService, что компания у UserReadDto реально существует.

И еще внутри пройденных в этом блоке аннотаций мы можем обращаться к специлаьному объекту SecurityExpressionRoot, через который нам, например, и был доступен метод hasAuthority
![[Pasted image 20240916114840.png]]

### Как внутри кода получить доступ к аутентифицированному пользователю ?
Получить мы можем через SecurityContextHolder сначала SecurityContext, а из него уже Authentication. А из него уже Principal, которым является наш класс, описывающий Usera.
![[Pasted image 20240916143124.png]]
В контроллерах мы также можем получить SecurityContext
![[Pasted image 20240916143300.png]]

Но в случае контроллеров чаще всего будет применяться @AurthenticationPrincipal для получения UserDetails. ![[Pasted image 20240916143353.png]]
И вот что будет внутри userDetails:
![[Pasted image 20240916143501.png]]
password = null, потому что сразу же после успешной аутентификации мы чистим пароль, чтобы он не гулял по всему приложению.

А вот как и говорили SecurityContext, который является оберкткой вокруг Authentication:
![[Pasted image 20240916143616.png]]

[[CSRF Filter]]

[[Security-Testing]]

[[OAuth2]]

[[JWT]]