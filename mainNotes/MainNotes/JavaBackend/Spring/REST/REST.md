Вспомним, что мы имеем на текущий момент.
![[Pasted image 20240913162100.png]]
Когда мы работали по MVC и возвращали HTML странички мы столкнулись со следующими проблемами:
1. Через HTML мы могли посылать только GET и POST запросы. А POST запросы через формы, т.е. мы никак не могли сделать PUT, DELETE запросы и другие. А это нарушает [[CRUD. Api Design]]
2. Мы всегда должны возвращать только HTML страничку, даже когда конечному клиенту нужны только данные, а мы дополнительно пересылаем кучу тегов, а это все занимает место, а, следовательно, производительность ухудшается.
3. Мы поддерживали только запросы из браузера, а есть и другие устройства, которые также хотели бы делать к нам запросы и получать данные, а не HTML, с которым умеет работать только браузер. Например, к нам мог обратиться какой-нибудь микросервис или мобильное приложение.

Поэтому мы переходим к новому подходу - REST.
![[Pasted image 20240913162409.png]]
REST - передача репрезентативного состояния. Означает, что REST - это лишь архитектурный стиль для распределенных медиа систем. Более простым языком - мы общаемся с различными система в сети, просто передавая состояния, используя HTTP протокол и не ограничивания себя каким-то определенным типом, как в HTML.

Как теперь это будет выглядеть в нашем приложении?
![[Pasted image 20240913162549.png]]
Теперь у нашего сервиса есть REST API. Т.е. теперь для взаимодействия с сервисом(это упрощенная схема, понятно, что там всякие dispatcherServlet и все такое) мы общаемся через REST-ы, а не обычные контроллеры. Со стороны браузера теперь изменения, т.к. браузер умеет отправлять только GET и POST методы, а поэтому нам нужен JavaScript.
А значит, что проблемы, которые мы обсудили - решены:
1. Нам доступны все HTTP методы, т.к. JS умеет посылать любые HTTP сообщения.
2. Теперь мы не ограничены возвращением HTML, а можем возвращать данные в любом формате. Чаще всего будет использоваться JSON.
3. HTTP реквесты теперь могут приходить из любых платформ, не только из браузера.
![[Pasted image 20240913163017.png]]
Мы также можем посылать сами запросы из других сервисов. В Spring, например, используется RestTemplate и WebClient(асинхронный). В случае микросервисов, они не всегда общается по HTTP, могут, например, по gRPC. Другие способы общения нужны, чтобы сократить количество информации, передаваемой между микросервисами, чтобы увеличить скорость обработки.

### Реализация REST в сервисах
Чтобы отключить viewResolvers, которые занимаются отрисовкой view мы должны вернуть ModelAndView = null. Для этого нужно просто над нашими методами поставить @ResponseBody.
![[Pasted image 20240913163407.png]]

Напишем REST контроллер. Для начала посмотрим, что вернется, если мы просто вернет из него какую-то строку. И также стоит заметить, что т.к. больше нет никакой ModelAndView, следовательно, с Model мы больше не можем работать и сохранять в нее. 
![[Pasted image 20240913163736.png]]
Тогда вернется просто строка, но браузер, чтобы отобразить нам ее коррентно обернет ее body из HTML. Поэтому, когда мы указываем ResponseBody ответ возвращается так, как он есть. Если мы возвращаем строку - возвращается строка, если возвращаем объект - то по умолчанию возвращается объект в формате JSON.
Вернем объект:
![[Pasted image 20240913164121.png]]
И в таком случае возвращается JSON, а также Content-Type также JSON.
![[Pasted image 20240913164156.png]]

Но если мы хотим управлять content-type для request и response, то это делается внутри @GetMapping. ![[Pasted image 20240913164916.png]]
Перепишем другие методы UserControllera
![[Pasted image 20240913165436.png]]
![[Pasted image 20240913165608.png]]
Чтобы не дублировать аннотацию над каждым методом REST контроллера она ставится над всем классом. Но можно использовать аннотацию @RestController - которая внутри содержит и @Controller и @ResponseBody
![[Pasted image 20240913165720.png]]
Осталось только узнать, каким образом обработать ошибки валидации и исключения. Для этого мы создаем отдельный контроллер. Используем @RestControllerAdvice(тут передаем пекедж для рест контроллеров, чтобы он срабатывал только для них). Внутри это аннотация объединяет аннотацию @ControllerAdvice + @ResponseBody
![[Pasted image 20240913170034.png]]

### Реализация функционала для сохранения картинки и ее получения
Создаем новый changelog, в котором в БД добавляем столбец для хранения пути до картинки(хранить ее будем локально).
![[Pasted image 20240913183912.png]]
Создадим ImageService:
![[Pasted image 20240913184217.png]]
![[Pasted image 20240913184618.png]]
Подправим HTML:
![[Pasted image 20240913184837.png]]
Изменяем DTO, добавив поле типа MultipartFile.
![[Pasted image 20240913184954.png]]
Изменяем маппер из Dto в Entity.
![[Pasted image 20240913185728.png]]
И теперь в нашем UserService мы должны сначала сохранить картинку на жесткий диск, а потом уже вернуть dto.
![[Pasted image 20240913185328.png]]
![[Pasted image 20240913185455.png]]
### Реализуем теперь получение картинки с сервера
Реализуем метод get в ImageService:
![[Pasted image 20240913190001.png]]
Теперь метод в UserService
![[Pasted image 20240913190220.png]]
На представлении User.html создадим ссылку, по которой сделаем еще один запрос на сервер для получения картинки.
![[Pasted image 20240913190639.png]]
Создадим метод в контроллере, который по запросу со скрина выше будет возвращать массив байт картинки
![[Pasted image 20240913190816.png]]
![[Pasted image 20240913190940.png]]
Можем явно задать, какой content-type будет у response при возвращении массива байт(но браузер и по умолчанию это понимает). В данном случае(и по умолчанию) content-type: image/avif
![[Pasted image 20240913191037.png]]
И стоит заметить, что нам пригодился REST контроллер, который выдавал нам картинку в view.
[[Response Entity]]