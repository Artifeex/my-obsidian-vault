В каких-то случаях в Spring все-таки приходится работать с JDBC напрямую, чтобы улучшить производительность нашего приложения.
Spring Data Jpa несет в себе транзитивную зависимость spring-boot-starter-jdbc.
![[Pasted image 20240909175245.png]]
JDBC-Starter предоставляет обертку над обычным JDBC из Java для упрощения работы с ним.
Как обычно есть класс автоконфигурации:
![[Pasted image 20240909175414.png]]
JdbcTemplate - основной класс, через который мы будем работать с JDBC из JDBC-Starter.
И есть свои JDBC properties. Для настройки используем spring.jdbc 
![[Pasted image 20240909175454.png]]
3 основных настройки:
- fetchSize - поговорим позже
- maxRows - для ограничения количества строк, которое мы получим из БД. Нужно, чтобы не положить наше приложение.
- queryTimeout.
И внутри JdbcTemplateConfiguration, который подключается вместе с JdbcTemplateAutoConfiguration есть bean jdbcTemplate, через который мы и будем работать. Т.е. внутри applicationContext уже такой bean будет.
![[Pasted image 20240909175653.png]]
Также добавляется bean namedParameterJdbcTemplate, который позволяет использовать имена для параметров в запросе, вместо знаков "?" в prepareStatement.
![[Pasted image 20240909175847.png]]

Т.к. JDBC не работает с Hibernate сущностями, то из репозитория мы возвращаем DTO, а не Entity из Hibernate. Напишем метод findAllByCompanyIdAndRole
![[Pasted image 20240909201605.png]]
Внутри реализации интерфейса репозитория мы через DI можем получить JdbcTemplate.
![[Pasted image 20240909201746.png]]
Основные методы:
- execute - для выполнения любых запросов, даже DDL.
- query - наиболее удобный для SELECT запросов
Напишем тело запроса:
![[Pasted image 20240909202048.png]]
И теперь используем jdbcTemplate, передав текст запроса и RowMapper(его можно заменить на лямбда выражение, т.к. это функциональный интерфейс) для того, чтобы смаппить ResultSet на объект. Также последним параметром передаем в query передаем параметры для подстановки вместо "?" в запросе.
![[Pasted image 20240909202353.png]]

Чтобы видеть запрос на консоли нужно добавить JdbcTemplate пекедж для логирования, установив TRACE(если хотим видеть еще и установленные параметры в вопросики, если не хотим, то можно поставить DEBUG).
![[Pasted image 20240909202650.png]]

[[Batch запросы]]

### NamedParameterJdbcTemplate
Минусом при использовании jdbcTemplate является то, что нам приходится запоминать порядок передачи аргументов в запросы(в знаки "?").
Поэтому можно использовать namedParameterJdbcTemplate, bean которого также создается. Тогда в запросах используем имена для параметров: ![[Pasted image 20240909204756.png]]

Подключаем bean в репозитории
![[Pasted image 20240909204928.png]]
На самом деле вся эта обработка Stream появилась только потому что в примере используются [[Batch запросы]]. Если бы это не было batch запросом, то нам бы достаточно было просто создавать MapSqlParameterSource(всего 1, а не array).
![[Pasted image 20240909205342.png]]

