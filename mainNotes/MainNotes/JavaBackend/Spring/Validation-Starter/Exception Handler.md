Когда мы добавляем BindingResult мы вмешиваемся в автоматический алгоритм валидационных ошибок. Т.е. когда мы не добавляем BindingResult, то если произошла валидационноая ошибка, то пользователю вернется страница с 400 ошибкой. А когда мы добавили BindingResult, то уже пользователю возвращается то, что мы сами напишем, как если бы никакой ошибки не было.

Но есть второй вариант обработки ошибок, который особенно популярен в REST. Для этого мы можем воспользоваться handlerExceptionResolvers, который мы обсуждали в [[Dispatcher Servlet]]

Для того, чтобы метод контроллера стал обработчиком ошибок используется аннотация @ExceptionHandler. Если не указать в ней какой-либо тип ошибок, то он будет обработчиком для всех ошибок.
![[Pasted image 20240913161001.png]]
Но в таком случае, handler будет работать только для UserController. Если мы хотим какой-то глобальный handler, то отдельно создаем класс:
![[Pasted image 20240913161347.png]]
Так и поступают в реальных приложениях. Более того, есть уже готовые exceptionHandlers, которые мы можем использовать. Внутри него есть такой же метод для обработки ошибок и там он обрабатывает большинство ошибок уже некоторым готовым образом.
![[Pasted image 20240913161609.png]]