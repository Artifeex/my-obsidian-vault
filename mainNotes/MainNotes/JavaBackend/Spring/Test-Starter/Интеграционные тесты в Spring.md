В Spring интеграционных тестов есть 3 основные цели![[Pasted image 20240905181509.png]]
- DI - хотим поднимать SpringContext при запуске наших тестов и внедрять bean зависимости в наших тестовых классах. Например, мы бы хотели, чтобы поля, которые мы делали @Mock, в случае юнит тестов были обычными бинами из ApplicationContext.
- Context Caching - кэширование контекстов. Если мы будем запускать ApplicationContext перед запуском каждого теста, которых может быть тысячи, то это будет расточительно. 
- Transaction Management - нам необходимо часто работать с БД и во время интеграционных тестов мы хотим проверить уровень БД. Для этого нам нужно стартовать транзакции, выполнять тесты и откатывать транзакции.

[[TestContextFramework]] используется в Spring для тестирования. Нам нужно интегрировать TestContextFramework и jUNIT5. Интеграция происходит благодаря [[Extension Model]] jUNIT5.

Напишем интеграционный тест. Для этого: 
1. создадим в test директории пекедж integration
2. Создадим класс теста с суффиксом IT
3. Используем @ExtendWith для расширения ExtensionModel.
4. Т.к. у нас в yaml файле находятся свойства, необходимые для создания бинов(@Value), то для того, чтобы они прочитались нужно использовать @ContextConfiguration(classes=ApplicationRunner.class, initializers - класс, который и будет заниматься считыванием application.yaml). ApplicationRunner - наш основной класс с аннотацией @SpringBootApplication.
5. Вместо 3 и 4 пункта можем использовать аннотацию @SpringBootTest
![[Pasted image 20240905200736.png]]
Внутри SpringBootTest:
![[Pasted image 20240905201119.png]]
- @ExtendWith - знакомая нам аннотация
- @BootstrapWith - автоматически искать @SpringBootConfiguration для загрузки.
Базовый интеграционный тест:
![[Pasted image 20240905201739.png]]
Видим, что тут нет никаких Mock объектов. Т.е. тут реально поднимается ApplicationContext!

### Как [[TestContextFramework]] инжектит зависимости в наши классы тестов?

Внутри TestContextFramework есть list из TestExecutionListeners. Каждый TestExecutionListener - это интерфейс, у которого есть методы, соотвествующие коллбекам из [[Extension Model]].
![[Pasted image 20240905202124.png]]

И есть куча готовых реализаций интерфейса TestExecutionListener.
И нам интересует DependencyInjectionTestExecutionListener, который занимается тем, что инжектит зависимости в наши тесты.
![[Pasted image 20240905202344.png]]

Инъекция происходит внутри prepareTestInstance
![[Pasted image 20240905202531.png]]

И внутри injectDependencies, используя BeanFactory, которая как раз и делает всю основную работу, а именно инжектит зависимости для нашего тестового класса![[Pasted image 20240905202603.png]]

И этот механизм с использованием TestExecutionListener работает много где. Например, для создания моков, для их очистки, для сервлетов.

При написании тестов нам также может понадобиться файл application.yaml, только для тестов. Чтобы часть полей из application.yaml осталось, а часть мы могли переписать, например, url к тестовой БД. Для этого:
1. Создаем файл application-test.yaml в test/resources
2. Включаем этот файл, используя @ActiveProfile
![[Pasted image 20240905205741.png]]

Для того, чтобы инжектить зависимости в конструктор, а не в поля, используется аннотация @TestConstructor(autowireMode=ALL)
![[Pasted image 20240905210357.png]]
Либо, чтобы не ставить @TestConstructor над каждым тестовым классом, мы можем использовать spring.properties, создав такой файл в test/resources и установить в нем значения для property:![[Pasted image 20240905210500.png]]

### Кэширование applicationContext
Если мы создадим 2 разных интеграционных тестовых класса, то при запуске всех интеграционных тестов поднимается 2 applicationContext. TestContextFramework сам решает, когда использовать кеширование, а когда нет. Если 2 тестовых класса имеют разную конфигурацию, то будет поднято 2 отдельных applicationContext. Если же конфигурации applicationContext будут одинаковыми в обоих классах, то будет использован один applicationContext.
Также на applicationContext могут повлиять Mock и Spy бины. Да, мы можем использовать Mock и Spy в интеграционных тестов, но нужно использовать аннотацию @MockBean и @SpyBean. ![[Pasted image 20240905211509.png]]
Но в таком случае, снова не будет закеширован applicationContext, поскольку мы в одном из наших тестов испортили applicationContext. Другими словами, мы можем переиспользовать applicationContext только в том случае, если мы не меняем бины в applicationContext. А в случае @SpyBean мы подменили один бин на другой и тогда, если не пересоздать новый applicationContext в другом интеграционном тесте, то там будет использован SpyBean.
Но если нас устраивает, чтобы Bean был Spy, то мы можем это сделать, чтобы не пересоздавался applicationContext(в 44. Integration-testing-3 показано как)

Каким образом происходит инжект моков в наших классах? Это делает MockitoTestExecutionLIstener
![[Pasted image 20240905212014.png]]

Можем вручную указывать, когда будет переиспользоваться или не переиспользоваться наш applicationContext.
![[Pasted image 20240905212740.png]]
Но лучше такое не использовать и оставить все на автоматическое определение.
Таким образом, на кэширование applicationContext влияют 2 вещи:
1. Конфигурации у двух классов интеграционных тестов должна быть одинакова. Т.е. должны быть использованы одинаковые аннотации, которые как-либо влияют на applicationContext.
2. При замене бинов на другие бины(например, на Spy) applicationContext становится dirty и не переиспользуется.