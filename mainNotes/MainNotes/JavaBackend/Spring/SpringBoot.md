Наше Spring приложение состоит из множества модулей. Например, модуль по работе с месседж брокерами, модуль по работе с БД, модуль по работе с веб и т.д.
Каждый модуль представляет из себя набор конфигураций и бинов. Например, рассмотрим Data модуль. Внутри него находятся бины, которые представлены на фото:

![[Pasted image 20240905090726.png]]

Каждый такой бин нужно как-то настраивать, инжектить зависимости, думать о том, какие еще зависимости ему нужны. Что достаточно сложно. А в реальных проектах может быть 10-ки различных модулей. До появления SpringBoot люди просто копировали конфигурации для модуля со своих прошлых проектов. Что порождало множество ошибок.
Появилась автоконфигурация. Spring предоставил нам классы, которые помечены @Configuration и которые внутри себя содержат необходимую конфигурацию наших бинов и properties.

![[Pasted image 20240905091232.png]]

Например, если хотим работать с Jpa, то Spring предоставит класс JpaAutoConfiguration, в котором уже будут созданы бины для необходимой работы. Таким образом, значительно упрощается настройка каждого модуля.
И все эти autoConfiguration классы тянутся как [[Транзитивная зависимость|транзитивная зависимость]] во всех spring-boot приложениях.
Но, тогда бы нам пришлось явно подключать все зависимость через @Import внутри класса, который мы пометили @Configuration. Но, например, локально нам может быть не нужна зависимость Kafka. Тогда Spring предоставляем функционал динамического подключения и отключения модулей по некоторому условию.

![[Pasted image 20240905092042.png]]

Условие для подключения может быть, например, classpath. Если я в нем увижу postgres драйвер, то это значит, что я собираюсь работать с БД, а, значит, можно подключить JpaAutoConfiguration. Также есть условия на Properties, что где-то есть нужное property. И если в ApplicationContext есть Bean определенного класса. Такой механизм работает с помощью @Conditional.
Помимо этого SpringBoot предоставляет SpringBootStarter - набор зависимостей(JAR файлов), которые добавляют нужный функционал в проект. Т.е. внутри стартера есть как раз AutoConfiguration бины и другие классы, для настройки и работы. Есть как официальные стартеры, так и third-party стартеры.
И последнее, что добавляет SpringBoot - это dependency management механизм. 

![[Pasted image 20240905093235.png]]

### @Conditional

Рассмотрим @Conditional

![[Pasted image 20240905093733.png]]

Ее можно вешать наш классом, а также над методом. Над методом в нашем случае - означает над методом, который создает Bean. Таким образом, мы можем динамически решать, используя некоторое условие, создавать нам Bean или нет.
Внутрь @Conditional передается массив классов, которые и будут проверять различные условия.

![[Pasted image 20240905093958.png]]

matches(ConditionContext context, AnnotatedTypeMetadata metadata) вернет true, если условие прошло, а, значит, создастся Bean.
ConditionContext context - доступ к нашему SpringContext. Внутри можно получить доступ как к beanDefinitions, так и к beanFactory, а внутри нее уже получить доступ к созданным бинам приложения. Также можно получить Environment, а, значит доступ, ко всем properties. 
AnnotatedTypeMetadata metadata - получение информации о других аннотациях, которые стоят рядом с @Conditional. А также информация о классе, в котором находится @Conditional, его интерфейсах, внутренних классах и многое другое.
Используем @Conditional, которая будет либо подключить bean JpaConfiguration или нет.

![[Pasted image 20240905094732.png]]

Переопределяем функциональный интерфейс. Идея: если в classpath есть postgres драйвер, то мы с помощью classLoader его загрузим в память, а, значит, создается bean JpaConfiguration, т.к. вернули true. А если такого драйвера нет, то, значит, что человек не хотел использовать БД, а, значит, что bean JpaConfiguration нам не нужен, поэтому вернули false.
![[Pasted image 20240905094825.png]]

Когда мы добавим SpringBoot то добавятся аннотации, например, @ConditionalOnClass, которая внутри будет помечена @Conditional и передан класс. Т.е. мы просто создали еще одну Conditional аннотацию, но с другим именем и сразу переданным Condition классом, который будет проверять нужное нам условие.
![[Pasted image 20240905095603.png]]

Топик выше был о том, что нам самим не придется писать какие-то классы, которые будут реализовывать интерфейс Condition, поскольку в Spring уже есть множество основных классов, которые смогут проверять почти все условия, которые нам могут потребоваться. Например, то, что мы написали руками про postgresql проверку, мы могли использовать @ConditionalOnClass и проверить, загружен ли класс драйвера в память.

### SpringBootStarter
SpringBootStarter - это core стартер. Который добавляет поддержку автоконфигурации(т.е. поддержку @Conditional), логирование, YAML формат.
Внутри implementation мы не указываем версию при подключении, поскольку она будет браться из 2-х плагинов ![[Pasted image 20240905101634.png]]

Транзитивные зависимости, которые есть в spring-boot-starter:
![[Pasted image 20240905115146.png]]
### SpringBootApplication

Когда мы вызываем SpringApplication.run(), то на самом деле под капотом просто создается ApplicationContext. Т.е. теперь не мы вызываем new, выбирая определенную версию реализации ApplicationContext, а это делает за нас Spring и возвращает ее. Т.е. мы можем также, как и раньше, получать различые бины.
![[Pasted image 20240905102458.png]]

Разберемся, что есть внутри @SpringBootApplication
![[Pasted image 20240905103136.png]]

- SpringBootConfiguration - внутри нее аннотация @Configuration. Т.е. это говорит о том, что это класс Configuration. Особенностью является то, что @SpringBootConfiguration - один на весь проект. А вот @Configuration может быть много, каждый из которых будет заниматься конфигурацией различных модулей.
- EnableAutoConfiguration - включает механизм автоконфигураций с помощью @Conditional, о котором мы говорили ранее. Все автоконфигурации лежат внутри org.springframework.boot:spring-boot-autoconfiguration. И какие-то из них автоматически подключаются, если удовлетворяют @Conditional.
- [[ComponentScan]] - дефолтный механизм для сканирования классов. Путь от которого начинает сканировать - это тот пакет, в котором находится класс с @SpringBootApplication. Поэтому такой класс должен находиться в корне проекта, чтобы ComponentScan просканировал все внутренние классы.
- Дополнительно(почему-то нет аннотации) не нужно указывать @[[PropertySource]]. Spring автоматически считывает application.properties/yaml файл.

### Что внутри spring-boot-autoconfiguration
Там находится множество пакетов, внутри которых находятся автоконфигурации. Например, вот, что находится в автоконфигурации jpa:
![[Pasted image 20240905104309.png]]

А вот, что находится внутри AutoConfiguration класса:
![[Pasted image 20240905104339.png]]

- AutoConfigureAfter - говорит о том, после каких автоконфигураций должна быть запущена наша автоконфигурация. Т.е. мы можем определять порядок загрузки автоконфигураций.
- ConditionalOnBean - автоконфигурация будет запущена, если в ApplicationContext есть bean, типа DataSource.
- ConditionalOnClass - внутри classpath должен быть JpaRepository.class
- ConditionalOnMissingBean - автоконфигурация запускается, если в applicationContext нет переданных внутрь бинов такого типа.
- ConditionalOnProperty. Используя spring.data.jpa.repositories.enabled=true внутри application.properties мы включим данную автоконфигурацию. matchIfMissing = true - означает, что если такой проперти в application.properties нет, то все равно загрузить нашу автоконфигурацию.

Но, если мы не хотим, чтобы какая-то автоконфигурация подключалась. Т.е. выполнились @Conditional и подключилась автоконфигурация, но мы не хотим ее использовать. Тогда нужно в @EnableAutoConfiguration передать класс автоконфигурации, либо его имя.
@EnableAutoConfiguration(exclude=JpaAutoConfiguration.class) или @EnableAutoConfiguration(excludeName="JpaAutoConfiguration").
Но для удобства сделали так, что можно передать тоже самое в @SpringBootApplication!

[[Properties]] - топик, про работу с properties файлами и в целом про работу с property, т.к. их можно передавать не только, используя файл application.propeties.

