Мы не хотим использовать jasper, поскольку есть более современные Template Engine для генерации наших HTML страниц на сервере.
Мы можем заменить дефолтный viewResolver, который как раз и занимается генерацией странички на наш кастомный, подключив нужную зависимость. Мы будем использовать Thymleaf.

Первое, что нужно понять - thymleaf использует аттрибуты, который начинаются с th: и динамическую составляющую мы можем писать только в значениях аттрибутов.
Подключаем thymleaf:
![[Pasted image 20240913111848.png]]
Нам теперь не нужна директория webapp. А также теперь мы должны сохранять наши HTML файлы в resources/templates. Так требует thymleaf(но эта настройка в properties, можем поменять).
![[Pasted image 20240913112143.png]]
И теперь нужно импортировать аттрибут th, чтобы мы могли к нему обращаться в каждом HTML файле.
![[Pasted image 20240913112215.png]]
th: - всегда должен находиться внутри какого-то тэга, просто так мы его писать не можем! th нужен только для какой-то динамической составляющей. Внутри ${} мы больше не пишем requestScope, т.к. по умолчанию считается то, что внутри $ находится в requestScope. Если же мы хотим использовать sessionScope, то так и пишем ${session.user}. Аналогично с applicationScope.
![[Pasted image 20240913112521.png]]

При использовании th:each будет продублирован сам тэг div и все его внутренности столько раз, сколько элементов в коллекции users
![[Pasted image 20240913113138.png]]

![[Pasted image 20240913113556.png]]
Получим такой результат:
![[Pasted image 20240913113442.png]]

![[Pasted image 20240913113851.png]]
![[Pasted image 20240913114043.png]]
На скрине выше видим, что мы каждый раз дублируем user. Но мы можем избавиться от этого. Для этого используется th:object, в котором мы указываем user. И тогда во всех вложенных тегах при использовании th: мы можем обращаться сразу к полям у user. Но для этого используется уже не доллар, а звездочка и сразу пишем название поля! th:value - используется в формах для того, чтобы задать значение. Это значение будет отправлено на сервер по ключу name.
![[Pasted image 20240913114144.png]]
Через # мы можем получить доступ ко множеству утилитных классов
![[Pasted image 20240913115649.png]]
Добавим еще выпадающий список и radiobutton
![[Pasted image 20240913120602.png]]
![[Pasted image 20240913120732.png]]
Результат:
![[Pasted image 20240913120803.png]]
th:if - только если true, то тогда появится данная составляющая. Например, добавим кнопку delete, если у пользователя роль ADMIN
![[Pasted image 20240913121409.png]]

### Создадим возможность регистрации
На страничке логина добавим кнопку, которая будет отсылать GET запрос(по умолчанию форма отсылает именно GET запрос) на получение странички регистрации.
![[Pasted image 20240913121913.png]]
Получение страницы регистрации:
![[Pasted image 20240913122358.png]]
Может возникнуть вопрос, а зачем передавать UserCreateEditDto при получении страницы регистрации, если еще никакой пользователь не создан? Это нужно для того, чтобы если пользователь заполнил данные, нажал зарегистрироваться и потом мы провалидировали и поняли, что у него ошибка. И чтобы пользователь не заполнял по новой все эти данные, при возвращении на страницу регистрации мы и должны в UserCreateEditDto сохранить данные с его прошлой попытки регистрации. Но как это сделать ? Ведь по умолчанию у нас RequestScope, а, значит, что UserCreateEditDto при повторном GET запросе на страницу регистрации будет с null полями внутри. Нам нужно как-то внутри метода контроллера CREATE, который произвел валидацию и вернул пользователя на страницу регистрации. Нужно в этом методе передать информацию для инициализации UserCreateEditDto. Для этого можно воспользоваться параметрами в запросе, т.е. при редиректе передать ?username=... и т.д. Но это не очень удобно. Есть вариант, который под капотом использует те же самые параметры, но мы это делаем не через конкатенацию строк, а через класс RedirectAttributes.
![[Pasted image 20240913122910.png]]
Но все равно неудобно, т.к. приходится множество раз вызывать addAttribute метод для каждого поля. Но мы можем сохранить целый объект в sessionScope, воспользовавшись методом addFlashAttribute.
![[Pasted image 20240913123015.png]]
И после этого при перенаправлении снова на получение странички registration в UserCreateEditDto будет находиться значение из sessionScope.  

[[Filter Query]]

