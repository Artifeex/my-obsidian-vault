Первое, на что нужно обратить внимание - это то, что возвращать данные нужно внутри "data", поскольку благодаря этому мы можем вернуть какую-то метаинформацию по нашему запросу внутри этого поля.
![[Pasted image 20240913124528.png]]

Для реализации пагинации есть 2 основных варианта. Offset-based и key-set based(оказывается, мы разбирали их различие в JDBC, поэтому стоит освежить в памяти)
### Offset-based Pagination
Встречается чаще всего и реализуется проще всего. Но с ней связаны проблемы с производительностью(о которых в курсе по JDBC). Все, что нам нужно - это добавить offset и limit параметры в URL. А если пользователь их не указал, то использовать какие-то стандартные.
![[Pasted image 20240913124938.png]]
Подготовим класс для Response для пагинации
![[Pasted image 20240913133035.png]]
Для реализации самой пагинации используем [[Pageable]].
![[Pasted image 20240913133326.png]]
 Доработаем класс PageResponse, чтобы он по Page мог возвращать PageResponse:
 ![[Pasted image 20240913134206.png]]
 ![[Pasted image 20240913134729.png]]
 Добавляем новый функционал во View:
 ![[Pasted image 20240913134922.png]]
 Результат:
 ![[Pasted image 20240913135033.png]]
### Key-set Pagination
В ней используется все также размер одной странички(LIMIT). Но вместо OFFSET используется некоторое поле, по которому установлен INDEX, чтобы быстро искать. И мы просто передаем некоторое значение для этого поля, начиная с которого нужно брать сущности(ограничены LIMIT). И т.е. для реализации пагинации, мы просто увеличиваем значение с которого нужно брать сущности. Т.е. это может быть, например, id. И при offset = 0, мы можем передать id =1. Дальше хотим следующую страничку с offset = 15. Тогда мы просто передаем id = 16 и начиная с него нужно будет забирать сущности. Но это дополнительные сложности, которые дают перформенс за счет того, что LIMIT происходит по полю, которое можно быстро найти в БД за счет индекса.
![[Pasted image 20240913125453.png]]