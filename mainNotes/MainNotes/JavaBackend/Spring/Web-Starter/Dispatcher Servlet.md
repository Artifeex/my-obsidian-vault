Разберемся с жизненным циклом Dispatcher Servlet. Т.к. это обычный Servlet, то у него такой же ЖЦ, как и у других сервлетов.
![[Pasted image 20240910103206.png]]

Когда клиент делает HTTP запрос на наш веб-сервер, то запрос попадает в Coyote(HTTP connector). Он парсит этот запрос и создает из него объект типа coyoute.Request. Этот объект попадает в Catalina(servlet container). С помощью coyoute.Request Catalina маппит запрос на сервлет, который должен обработать этот запрос. Но так было в обычных сервлетах. В случае Spring MVC у нас всего 1 сервлет на все веб-приложение - Dispatcher Servlet. Таким образом, Catalina любой запрос посылает в Dispatcher Servlet. Но сначала нужно создать этот сервлет, если он не создан. Дефолтный, жизненный цикл сервлета состоит из 3 основных шагов.
1. Инициализация. Класс сервлета загружается в JVM. С помощью Reflection Api создается объект сервлета. И у этого объекта вызывается метод init.
2. Вся дальнейшая работа происходит внутри метода service нашего сервлета. 
3. При завершении нашего приложения у сервлета вызывается метод destroy().

При этом после шага 1 никакой дальнейшей инициализации не происходит. Сервлет просто работает, когда Catalina вызывает на нем метод service. Вся основная логика по маппингу запроса на соотвествующий Controller происходит внутри метода service(req, resp).

### Что происходит внутри метода service в dispatcher servlet?
![[Pasted image 20240910104444.png]]
Сначала по URL-у мы должны определить какой handler(обработчик) должен обрабатывать запрос. Раньше мы по URL определяли какой сервлет будет обрабатывать данный запрос, а теперь нам сервлет понятен(он у нас всего 1), то, значит, нужно определить обработчик.

Handler представляет из себя controller, а точнее метод контроллера, который будет обрабатывать HTTP запрос, т.к. в одном контроллере мы можем добавлять сколько угодно методов для обработки get запросов, post запросов и т.д. (в сервлетах же у нас был 1 метод doGet, doPost и т.д.). Помимо этого в handler есть еще interceptors - что-то вроде фильтров, как в сервлетах. Они вызываются до вызова метода контроллера и после вызова. Поэтому в Spring мы можем использовать как фильтры, так и interceptors.

После определения handlerа мы должны определить handler adapter.
Handler Adapter интересен тем, что он включает в себя много других вспомогательных объектов. В первую очередь, в нем есть ссылка на WebApplicationContext. После того, как мы подключили Spring Web, у нас будет создаваться именно WebApplicationContext.

Также внутри Handler Adapter есть множество HandlerMethodArgumentResolver. Они нужны для того, чтобы заинжектить в методы контроллера то, что мы попросили.
После обработки HTTP запроса мы из метода контроллера возвращаем некоторое значение, которое уже знает как обработать HandlerMethodReturnValueHandler. Мы можем захотеть вернуть View или объект, который потом должен преобразоваться в JSON. Всем этим занимается HandlerMethodReturnValueHandler, который также находится внутри Handler Adapter.

После этого вызывается метод handlerAdapter.handler(req, resp, handler). Внутри него вызывается соответствующий метод контроллера, интерсепторы, если есть. Возвращается из него ModelAndView - по умолчанию. Которая включает в себя модель(т.е. данные для отображение) и View - само отображение. View - может быть как HTML, так и JSP. Т.е. та страничка, которую должны вернуть пользователю.
Но этот ModelAndView объект может быть null(так в современных приложениях чаще всего и происходит, потому что рендеринг страниц на стороне сервера не очень часто используется. С сервера вы возвращаем данные, а не страницы(REST)). А значит, используя аннотацию @ResponseBody мы просим, чтобы ModelAndView был null. И тогда мы возвращаем данные как есть. 
Но, если все-таки, вернули ModelAndView то нужно, чтобы странички отрендерилась на сервере, чтобы ее вернуть. Для этого используется viewResolver. Мы передаем в него название странички, он знает, где ее найти и находит. А дальше, мы должны подставить в эту странички данные! Т.е. как раз в шаблоны подставить уже какие-то конкретные данные. Модель позволяет делать страничку динамический, т.е. подставлять значение в EL динамически.

В противном случае, если произошел какой-то exception на любом из этапов, то происходит его обработка с помощью handlerExceptionResolvers в нашем DispatcherServlet. И мы можем обработать этот exception каким угодно образом. Например, вернуть другую страничку или страничку с ошибкой. Или код ошибки без данных и т.д.
На практике разработчик чаще всего будет реализовывать контроллеры, реже interceptors, handlerExpcetionResolvers, чтобы определить, что вернуть пользователю в случае ошибки. А также, если у нас MVC приложение, то сам View.

Посмотрим на DispatcherServlet
![[Pasted image 20240910110603.png]]

doDispatch вызывается из метода doService, который вызывается из метода service. И если по нему походить, то увидим, что он соответствует той логике, которую мы описывали выше.

**![Dispatcher-servlet-diagram](https://lh7-rt.googleusercontent.com/docsz/AD_4nXeR8H_wjAB8oFHenlSpXrmhoFShUJyj6jVn2LNUEzsjAJhsZ0mIqvdvOyZwAxq5rWWogh6myVcp7Lj2sf06jk6PUVouXaoIBwUNkfyc_KfJxjGv8r80L5HNtlI3cJbi6iE4ZKYfwDNIduHxQjpk1VpmseU?key=XMeQwLql_JMyD2k54CogZg)**



