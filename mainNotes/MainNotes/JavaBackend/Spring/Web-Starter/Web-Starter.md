Для начала вспомним, как выглядит наше приложение. [[MVC]]
[[Структура веб-приложения]].

В Spring есть модуль Spring MVC, который точно также использует MVC структуру, только в данном случае в Spring реализован паттерн front controller. Т.е. у нас есть 1 единственный сервлет - Dispatcher Servlet, и он за нас создан и положен в Spring. И все запросы, которые будут приходить в наше веб-приложение, они все будут идти через Dispather Servlet, который будет перенаправлять запросы на контроллеры по соотвествующему URL-у. 
![[Pasted image 20240910101642.png]]

### В Spring Boot меняется и структура веб-приложения
Мы теперь собираем наше приложение в jar файл, а внутри него будет встроенный Tomcat(просто подключим зависимость). И для запуска приложения теперь нужно будет только запустить jar файлик.
![[Pasted image 20240910102014.png]]

Но, т.к. Embedded Tomcat не совсем полноценный Tomcat, в нем нет Jaspera. Но если он нужен, то мы можем его подключить. Но на практике jasper не очень нужен, т.к. есть более современные template engines, для которых не нужен jasper.
![[Pasted image 20240910102134.png]]

Подключаем зависимости:
![[Pasted image 20240910102335.png]]
Подтянутся зависимости:
![[Pasted image 20240910102413.png]]

После этого наше приложение становится веб-приложением! Нам самим ничего не пришлось реализовывать. Это произошло благодаря AutoConfiguration:
![[Pasted image 20240910102740.png]]

Внутри DispathcerServletAutoConfiguration создается bean для [[Dispatcher Servlet]]
![[Pasted image 20240910102926.png]]

И также в AutoConfiguration есть bean для Tomcat. А с помощью properties и префикса server мы можем настраивать Tomcat(поменять порт и т.д.). Помимо Tomcat мы можем использовать другие Embeded веб-серверы, например, Jetti. По умолчанию используется Tomcat.

### Создание первого Controller
Т.к. мы пока работаем с MVC, нам нужно установить настройки для viewResolver(стоит почитать [[Dispatcher Servlet]]). Чтобы viewResolver мог понимать, где искать View по их названию. prefix - диреткория, в которой нужно искать View. suffix - какое расширение. Т.к. пока работает с JSP, а не Thymleaf, то используем .jsp(также т.к. в Embdede Tomcat нет Jaspera, то нужно добавить зависимость на него).
![[Pasted image 20240910112252.png]]
prefix и suffix на самом деле используется, когда мы из метода controllera возвращаем название view, то к нему подставляется prefix и suffix. Т.е. вернув "index" из контроллера, на самом деле вернется /WEB-INF/jsp/index.jsp.

Создаем webapp директорию в корне проекта
![[Pasted image 20240910112810.png]]

Для web обычно создается пекедж http, а внутри него уже controller, interceptor, filter и т.д. Для того, чтобы класс стал контроллером - используем @Controller.
![[Pasted image 20240910113011.png]]

@Controller - это @Component.
![[Pasted image 20240910113039.png]]

Как мы и говорили из контроллера мы должны вернуть ModelAndView. Также вставляет название jsp странички, которую нужно будет вернуть. 
![[Pasted image 20240910114156.png]]

Но нам еще нужно указать URL для метода контроллера, по которому должен вызываться данный метод.

Но перед этим вспомнил немного про [[MainNotes/JavaBackend/HTTP]]

Теперь можем указать URL для маппинга, используя [[@RequestMapping]]
![[Pasted image 20240910122448.png]]

Но на практике есть аналоги для @RequestMapping, чтобы не указывать method, т.к. получается очень громоздко. Вместо этого используется @GetMapping, @PostMapping, @DeleteMapping и т.д.
Но @RequestMapping используют для того, чтобы указать общую часть URL, которая должна быть у всех обработчиков.
![[Pasted image 20240910123425.png]]
Теперь для обращения нужно писать /api/v1 дополнительно в начале path в URL запроса.
![[Pasted image 20240910123535.png]]

### Извлечение информации из запроса
![[Pasted image 20240910180132.png]]
С помощью @RequestParam мы можем извлечь значение этого параметра. По дефолту он обязательный(можем изменить это в @RequestParam) и поэтому,если не будет передан параметр, то произойдет 400 ошибка.
![[Pasted image 20240910180230.png]]

Для получения информации из header используем @RequestHeader
![[Pasted image 20240910180424.png]]

Куки мы можем получить, использую @CookieValue
![[Pasted image 20240910180540.png]]

Разница в получении различных элементов HTTP запроса, используя аннотации и ServletRequest.
![[Pasted image 20240910180636.png]]

Мы также можем опустить названия внутри скобочках, тогда оно будет браться по названию параметра в методе.

Инжектом занимаются arugmentResolvers, которые лежат внутри handlerAdapter.

Для получения значений из URL path используем {} в описании обработчика, а чтобы само значение получать используем @PathVariable.
![[Pasted image 20240910181115.png]]

### Model
На текущий момент у нас нет никакой динамической составляющей в JSP страницах. Чтобы создать динамическую составляющую нужно воспользоваться EL. А чтобы передать данные, которые нужно подставлять используется Model.
В сервлетах мы использовали для этого аттрибуты и у нас было 3 различных варианта установки аттрибутов. Аттрбиты - это Map. String - ключ, а значением является любой объект, а, значит, что мы можем получить любой объект, используя аттрибуты.
![[Pasted image 20240910181551.png]]
3 различных аттрибута:
1. ServletContext - один единственный на все наши сервлеты. Т.е. одна единственная Map на все приложение. На практике не используют.
2. Аттрибуты сессии. Т.е. аттрибуты, привязанные к объекты HttpSession.
3. Аттрибуты реквеста. Т.е. аттрибуты, привязанные к объекту HttpServletRequest.
В случае сессии используются аннотации @SessionAttribute - мы достаем этот аттрибут из сессии, чтобы получить к нему доступ. @SessionAttributes - мы определяем какие ключи аттрибутов будут храниться в сессии.
В случае реквеста используется аннотация @RequestAtrribute. Но мы не увидим использование этой аннотации, поскольку все аттрибуты, которые мы будем устанавливать по умолчанию являются @RequestAttribute.

Научимся добавлять аттрибуты. Создадим класс, объект которого хотим сохранить в аттрибуты и получить потом на нашей JSP страничке.
![[Pasted image 20240910182458.png]]
Добавляем по ключу "user" созданный объект в модель. По дефолту это добавление будет в RequestScope.
![[Pasted image 20240910182542.png]]
Теперь могу получить значение в JSP из этого объекта:
![[Pasted image 20240910182743.png]]

Под капотом неявно будет вызвано request.setAttribute(так мы делали в ServletRequest)
![[Pasted image 20240910182832.png]]

Как теперь установить этот аттрибут на уровне сессии, а не реквеста?
![[Pasted image 20240910183224.png]]

А для получения мы как раз используем @SessionAttribute. Тогда Spring под капотом сделает request.getSession().getAttribute("user"). Причем этот объект UserReadDto сохраняется именно в сессии пользователя! Т.е. если ты не заметил, то мы задали этот объект при вызове метода hello контроллера, а получаем его в другом методе контроллера - bye. 
![[Pasted image 20240910183325.png]]

В JSP же мы можем обращаться в sessionScope:
![[Pasted image 20240910183822.png]]

### Упрощение возвращаемого значения
Мы можем вместо возвращения объекта ModelAndView возвращать строку, котора является названием нашей JSP страницы. HandlerMethodReturnValueHandler - как раз обработает эту строчку. Он поймет, что у нас MVC приложение, значит, мы из всех методов контроллера возвращаем какую-то View, поэтому он интерпретирует вернувшуюся строчку как название View и потом уже на основании этого создаст снова ModelAndView объект. Для работы с Model мы теперь работает напрямую с Model, а не с ModelAndView.
![[Pasted image 20240910184206.png]]

Очень прикольно, что Spring может смаппить параметры из URL на наш UserReadDto параметр и помимо этого он еще и кладет этот объект в Model. А для этого нам даже ничего не нужно делать. Мы просто добавляем в метод контроллера параметр с типом UserReadDto:
![[Pasted image 20240910184904.png]]
И теперь при передаче параметров, если они окажутся идентичными названиям полей из UserReadDto, то в объекте userReadDto мы увидим userReadDto.id = 11 и userReadDto.name="Petr". 
![[Pasted image 20240910185010.png]]
А также стоит добавить, что этот UserReadDto Spring добавил в Model, которую мы указали как один из параметров нашего метода контроллера.
![[Pasted image 20240910185145.png]]

А раз Spring добавляет UserReadDto в Model, то мы можем обратиться к нему из нашей JSP
![[Pasted image 20240910185311.png]]
Но, на самом деле, здесь используется аннотация по умолчанию @ModelAttribute. Ее просто опускают в виду ненадобности(она же по умолчанию).
![[Pasted image 20240910185349.png]]
В скобочках можем указать название аттрибута, т.е. ключ, который добавится в Model
![[Pasted image 20240910185509.png]]

Также @ModelAttribute мы можем поставить над методом! Тогда тот объект, который вернет метод будет добавлен в нашу модель как аттрибут.
Например, хочу добавить в модель список всех ролей. 
![[Pasted image 20240910185700.png]]
Теперь мы можем обращаться по ключу roles к нашей модели и получать из нее список ролей. НООО, стоит заметить, что теперь метод roles() будет вызываться каждый раз при вызове любого метода контроллера. Это будет происходить, поскольку нужно каждый раз добавлять это значение в модель.

Создадим форму для отправки. method="post" мы сделали это для того, чтобы параметры отправились в body запроса. Если ничего не делать, то форма отправляется по умолчанию в GET запросе, а параметры и их значения в URL запроса. С помощью name указывается название параметров в нашей форме(ну т.е. ключ).
![[Pasted image 20240910190209.png]]
Теперь создадим Dto, в который Spring смаппит параметры из запроса, а именно из body запроса! Важно, чтобы поля в этом dto совпадали с названием параметров, которые передаются в body из формы.
![[Pasted image 20240910190427.png]]
Теперь создаем сам контроллер и как параметр добавляем созданный класс LoginDto.
![[Pasted image 20240910190647.png]]
После этого в Model добавится по ключу "login" объект LoginDto.

Инициализация Model происходит внутри метода HandlerAdaptera в методе exposeModelAsRequestAttributes.
![[Pasted image 20240910192120.png]]


Рассмотрим каким образом происходит [[Перенаправление запросов]]

Здесь можно почитать о лучших практиках. Как именовать API, URL, какие пути нужны делать. Как передавать параметры, что нужно делать на CRUD операции.
[[CRUD. Api Design]]

