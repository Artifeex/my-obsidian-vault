Для мапперов используем полноценные @Component. И инжектим их в наши Service. В мапперах мы маппим из Entity в Dto объект, который и возвращается с уровня сервиса.
![[Pasted image 20240911163930.png]]

Дефолтный mapper:
![[Pasted image 20240911164046.png]]

ВОт, что нужно делать, если по id не был найден пользователь на уровне Controllera:
![[Pasted image 20240911164511.png]]

В мапперах нормально использовать репозитории и инжектить их для получения какой-то информации о наших сущностях, чтобы завершить маппинг.
![[Pasted image 20240911164949.png]]

create метод сервиса
![[Pasted image 20240911165145.png]]

Для CREATE метода в контроллере нужно возвращать 201 статус, который говорит о том, что на сервере было что-то создано.
Для этого нужно использовать аннотацию @ResponseStatus, в которой можно указать явно код статутса или использовать заготовленный HttpStatus.CREATED, который под капотом как раз и передает статус 201. 
![[Pasted image 20240911165322.png]]

На уровне сервисов мы должны ставить @Transactional, чтобы на каждом методе сервиса автоматически создавалась транзакция, и после выполнения закрывалась. Это нужно, потому что внутри сервиса мы работаем с БД(когда обращаемся к Repository объектам), также в сервисе мы обращаемся к mapper объектам, которые тоже могут использовать для своих нужд БД, или же могут получить через getter метод какую-то lazy сущность и тогда мы получим lazy initialization exception. 
![[Pasted image 20240911165456.png]]

На практике делают чуть оптимальнее и ставят readOnly над всем классом сервиса, чтобы работали оптимизации о которых мы говорили в [[Оптимизация при использовании readOnly]].
![[Pasted image 20240911165730.png]]

А в методах, которые все-таки изменяют как-то данные в БД мы просто дополнительно навешиваем @Transactional, которая перекрывает @Transcational(readOnly=true)
![[Pasted image 20240911165846.png]]

Update метод для нашего сервиса
![[Pasted image 20240911170249.png]]
Измененный mapper. чтобы при вызове map метода не создавать новый объект, если бы передан объект, в который можно сохранить.
![[Pasted image 20240911170314.png]]

UPDATE метод в контроллере
![[Pasted image 20240911170621.png]]

delete метод в сервисе
![[Pasted image 20240911170856.png]]

delete в методе контроллера
![[Pasted image 20240911170951.png]]

Теперь напишем тесты для написанных методов
![[Pasted image 20240911171254.png]]
![[Pasted image 20240911171448.png]]
![[Pasted image 20240911171614.png]]
![[Pasted image 20240911171714.png]]

На самом деле в delete методе мы допустили ошибку. Нам нужно явно вызвать метод flush, поскольку в тестах не выполняется commit операций, а выполняется rollback, поэтому в тестах при тестировании метода delete не было на самом деле обращений к БД.
![[Pasted image 20240911171844.png]]

