Проблема описана в [[Тестирование с использованием тестовой БД]].

TestContainers - это библиотека, которая позволяет динамически поднимать нашу БД(используя докер image) при запуске наших тестов и по окончании тестов БД тушится.
Подключаем зависимости
![[Pasted image 20240909213527.png]]

Чтобы не хардкодить значения версий создается файл version.gradle, в котором создается Map с версиями.
![[Pasted image 20240909213643.png]]

Подключаем написанный плагин(файлик)
![[Pasted image 20240909213736.png]]

И используем эти ключи из созданной Map для указания версий
![[Pasted image 20240909213804.png]]

Создадим базовый класс для интеграционных тестов, чтобы не писать в каждом классе создание контейнера. В @BeforeAll запускаем докер контейнер с БД. Хоть @BeforeAll будет выполняться для каждого тестового класса, но при этом внутри метода start проверяется, поднят уже докер контейнер или нет. Поэтому не будут подниматься дополнительные БД для каждого тестового класса.
![[Pasted image 20240909214029.png]]
![[Pasted image 20240909214220.png]]

Для настройки параметров подключения(имя пользовтеля, пароль, имя тестовой БД) при создании контейнера используем методы with
![[Pasted image 20240909214510.png]]

Внутри application-test.yaml: (test и test - это значения по умолчанию для этих полей в контейнере(не докер, а именно в библиотечке. Именно их мы можем настраивать, используя with)).
![[Pasted image 20240909214546.png]]

Но мы не знаем какой url у нас будет для подключения в момент запуска тестов, поэтому мы должны подставить его динамически в application-test.yaml.(проблема именно в порту, потому что docker его определяет при запуске контейнера динамически по своим каким-то правилам) Чтобы это сделать, используем аннотацию @DynamicPropertySource и в registry передаем ключ для property и ее значение. А значением является url, который узнает container, когда будет поднимать docker БД.
![[Pasted image 20240909214825.png]]

И теперь в интеграционных тестах мы можем отнаследоваться от базового класса с тестами. Тогда нам не нужно использовать @IT, которую мы написали(в ней множество аннотаций, которые нужны всем нашим тестам).
![[Pasted image 20240909214948.png]]

Также мы перетащили @Sql, которая вызывает переданные названия  скриптов при запуске тестов в базовый класс интеграционных тестов.
![[Pasted image 20240909215123.png]]

Тогда запустится 2 докер контейнера. Первый с самой БД. А второй для обработки первого, т.е. чтобы когда завершились тесты второй контейнер потушил первый и потом сам потушился.
![[Pasted image 20240909215406.png]]

Но если мы запустим сразу все тесты, то столкнемся с ошибками, если мы в наших тестах полагались на какие-то константные значения для id. Это произойдет, потому что логика работы сейчас следующая:
1. Поднялась БД
2. Перед каждым тестовым методом вызывается sql скрипт из @Sql
3. Вызывается тестовый метод
4. Происходит rollback и сбрасываются изменения на БД как тестового метода, так и накатывания данных. Но при ЭТОМ ВАЖНО, ЧТО ЗНАЧЕНИЯ SEQUENCE не откатываются!!! Т.е. даже если произошел rollback транзакции, то значение в SEQUENCE все равно инкрементится и не возвращается! И поэтому, одна и та же запись окажется в разных тестах под разным id. Поскольку при запуске первого теста запись имела id=1. Потом мы сделали rollback, но сиквенс уже перешел на значение 2. Поэтому при запуске следующего теста id у записи будет = 2, т.к. сиквенс вернет это для id при INSERT методе.
Поэтому решением является в sql скрипте при INSERT методах явно передавать id записи. Но, чтобы SEQUENCE соотвестововал количеству записей, его также нужно обновить, т.к. если его не обновить, то, если мы в тестовом методе делаем INSERT в БД, то т.к. в сиквенс значение = 1, а мы уже использовали такой id в SQL скрипте, то произойдет ошибка, т.к. сиквенс для инсерта вернет id =1, а запись с таким id уже будет в БД.

Таким образом, в скрипте для накатывания для всех INSERT записей мы явно указали id, а также установили для сиквенса значение = максимальное значение вставленного id(просто сделали это динамически, используя SQL код. Могли и за хардкодить и поставить просто значение 3(такой id у Amazon)).
![[Pasted image 20240909221731.png]]

