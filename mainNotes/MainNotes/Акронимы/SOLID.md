Хорошая статья по SOLID: https://habr.com/ru/articles/811305/

 https://ru.wikipedia.org/wiki/SOLID_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
 ![[Pasted image 20241017144435 1.png]]
SOLID - это аббревиатура пяти основных принципов проектирования в объектно-ориентированном программировании, придуманная Робертом Мартином. 
Эти принципы позволяют строить на базе ООП масштабируемые и сопровождаемые программные продукты с понятной бизнес-логикой.

### S - Single Responsibility. Принцип единственной ответственности
Принцип [ООП](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5 "Объектно-ориентированное программирование"), согласно которому каждый [объект](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) "Объект (программирование)") должен иметь одну ответственность и эта ответственность должна быть полностью [инкапсулирована](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) "Инкапсуляция (программирование)) в [класс](https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B0%D1%81%D1%81_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) "Класс (программирование)"). Все его поведения должны быть направлены исключительно на обеспечение этой ответственности.

Возникает вопрос, когда стоит использовать этот принцип? Всё же принцип — это не закон и SRP стоит применять в зависимости от того, как изменяется приложение:

- если при изменении кода, отвечающего за одну ответственность, в приложении появляются исправления кода, отвечающего за другую ответственность, то это первый сигнал о нарушении SRP.
- если же изменения кода, отвечающего за одну ответственность, не вносят изменения в код, отвечающий за другую ответственность, то этот принцип можно не применять.

Каждый класс должен иметь одну зону отвественности. Т.е. каждый класс должен иметь одну обязанность и эта обязанность, должна быть полностью инкапсулирована в класс. Все методы класса должны быть направлены на выполнение этой единственной зоны ответственности. 

Пример не соблюдения:
Класс RentCarService, который ответственен сразу несколько функциональностей. Отправку сообщений, генерацию отчетов, бронированию машин и т.д.

Что будет, если не соблюдать? Изменение какой-то одной функциональности может потребовать изменение и какой-то другой.
### O - Open closed Principle. Принцип открытости-закрытости
Классы должны быть открыты для расширения, но закрыты для изменения.
Идея в том, чтобы при добавлении какой-то функциональности не изменять какой-то код, а система должна быть спроектирована так, что для добавления нужно расширить существующий. Пишем код так, чтобы другие могли легко расширить функционал, не меняя написанный (оттестированный, понравившийся твоему начальнику) код. 

Принцип открытости/закрытости означает, что программные сущности должны быть:
- открыты для расширения: означает, что поведение сущности может быть расширено путём создания новых типов сущностей.
- закрыты для изменения: в результате расширения поведения сущности, не должны вноситься изменения в код, который эту сущность использует.

Например:
Есть класс, в котором есть метод для отправки email сообщений. Мы решили добавить функционал отправки телефонных сообщений. И для добавления такого функционала, мы не должны изменять метод, который отвечает за отправку сообщений. Вместо этого мы создадим интерфейс NotificationService с методом sendMessage. И потом для каждого типа сообщений будем создавать класс и реализовывать данный метод.

Если не следовать, то для добавления изменений нужно будет изменять уже рабочий код.
### L - Liskov substitution Principle. Принцип подставки Барбары Лисков
Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом.

Если в коде программы Базовый класс заменить на его Наследника, то программа должна работать, так как в Наследнике есть все операции, которые были в Базовом. В Базовый класс нужно выносить только общую логику, которую наследники будут реализовывать. Наследников создаем только тогда, когда они правильно собираются реализовать логику Базового класса без проблем.
Например: 
Есть абстрактный класс Acount, в котором мы определили 3 метода. Пополнение, оплата, проверка баланса. У нас будет 2 наследника - дебетовый аккаунт и вклад. Дебетовый может выполнять все 3 метода. А вот с вклада нельзя оплачивать напрямую, поэтому в нем для метода оплаты нужно будет кидать exception о том, что метод не поддерживается. И тогда, если где-то в коде, где мы использовали объект базового класса мы подставим объект типа вклад, то все может поломаться из-за того, что метод не поддерживается.
Решением является:
Для того чтобы следовать принципу подстановки Барбары Лисков необходимо в базовый (родительский) класс выносить только общую логику, характерную для классов наследников, которые будут ее реализовывать и, соответственно, можно будет базовый класс без проблем заменить на его класс-наследник.
### I - Interface Segregation Principle. Принцип разделения интерфейса
Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе.
Т.е. не нужно создавать большой интерфейс с кучей методов, потому что это заставит клиента, который реализует этот интерфейс реализовывать кучу методов, которые ему могут быть не нужны. 

Клиенты не должны зависеть от интерфейсов, которые они не используют. Большие интерфейсы следует разбивать на интерфейсы поменьше. Так клиенты смогут использовать только те интерфейсы, которые им нужны. Это делает менее связанный код, уменьшает зависимости между элементами системы, упрощает изменения в коде.

Например, есть интерфейс Payments, внутри которого есть 3 различных метода оплаты. Оплата картой, оплата через WebMoney, оплата через телефон. И если мы, например, создаем класс банкомата, который реализует наш интерфейс Payments, то мы заставляем его реализовывать все 3 метода, а, например, метод оплаты по телефону не поддерживается банкоматом и вот уже проблема. Поэтому разделяют интерфейс Payments на 3 отдельных интерфейса, с различными методами оплаты. И наши классы уже будут реализовывать те интерфейсы и их методы, которые им реально нужны.
### D - Dependency Inversion Principle. Принцип инверсии зависимостей
1. Модули верхних уровней не должны зависеть от модулей нижних уровней, 
2. Оба типа модулей должны зависеть от абстракций;
3. Сами абстракции не должны зависеть от деталей
4. Детали должны зависеть от абстракций.

Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от реализации. Реализация должна зависеть от абстракции.

Допустим мы пишем магазин. Создаем сам класс магазина. У магазина есть способ оплаты, пока что только в виде Cash. В магазине создадим поле типа Cash, через которое и будет происходить оплата. Но мы тем самым, нарушили принцип инверсии зависимостей, посколку жестко связали наш класс магазин и способ оплаты через cash. Тем самым, если мы захотим добавить в магазине еще и другие способы оплаты, то нам точно придется переписывать код.

Для решения нужно создать интерфейс Payments и в нем будет метод для оплаты. В классе магазина мы также создадим поле типа Payments. И для каждого вида оплаты будем создавать класс, реализующий Payements. Т.е. теперь магазин уже не зависит от какой-либо конкретной оплаты.

Удовлетворяет ли всем принципам? 
1. Да, удовлетворяет. Модуль верхнего уровня - магазин не зависит от конкретной реализации модуля нижнего уровня - оплаты.
2. Да, теперь магазин зависит от абстракции Payments, и какой-то конкретный вариант Payments зависит от абстракции Payements
3. Payments никак не зависит от своих реализаций
4. Реализации Payments зависят от Payments.



![[Pasted image 20241211175006.png]]
![[Pasted image 20241211174950.png]]
![[Pasted image 20241211175020.png]]
