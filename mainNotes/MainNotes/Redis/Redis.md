Редис часто называют БД, но на самом деле это распределенное хранилище key-value данных.
![[Pasted image 20241117103939.png]]
![[Pasted image 20241117104304.png]]
- Redis ограничен оперативными объемами памяти компьютера.
![[Pasted image 20241117104519.png]]
### Запуск
Для установки можно воспользоваться:
curl -O http://download.redis.io/redis-stable.tar.gz - скачиваем последнюю версию.
Потом распаковываем.
Заходим внутрь и через make компилируем исходники. Потом make install для установки.
А дальше все просто. redis-server - чтобы запустить сервер redis. И redis-cli для подключения, а если у нас какой-то удаленный сервер redis, то можно указать
redis-cli -h localhost -p 6379 - только вместо localhost и port уже определенные данные.

### Подключение
redis-cli - это командный интерфейс для работы с Redis хранилищем.

Мы можем также подключаться через -u:
![[Pasted image 20241117112529.png]]
Стоит заметить, что redis поддерживает аутентификацию по паролю.
Также стоит обратить внимание на 3-ю команду. Там есть /2. Redis сервер по умолчанию создает 16 как бы БД(их еще можно назвать namespace). И мы можем так разделять наши данных между БД, причем данные изолированы между ними.


Когда мы просто пишем redis-cli, то автоматически подключаемся к 0-ой БД(номера тех 16 БД, которые создает redis начинаются с 0 и до 15). Для подключения ко второй БД:
![[Pasted image 20241117112839.png]]

### Повторение команды
-r 10 - выполнить команду 10 раз. Т.е. произойдет increment счетчика counter 10 раз:
![[Pasted image 20241117112945.png]]

### Повторение + интервал
выполнить 10 раз с периодом в 0.5 сек. Т.е. не подряд будут выполняться, а с ожиданием.
![[Pasted image 20241117113040.png]]

### Чистый вид данных - это без типа, т.е. тут не будет указан тип, а только результат команды
![[Pasted image 20241117130425.png]]

### Сохраняем результат выполнения команды
В данном случае в файл file.log будет выводиться как инкрементился счетчик. КОманды incr counter - возвращает как раз значение счетчика. Т.е. в файл будет записано 1 2 3 4 5 ... 10. Причем т.к. raw, то не будем integer 1, integer 2, integer 3
![[Pasted image 20241117130503.png]]
### Записываем данные из файла в Redis
По ключу foo будут установлены данные из services
![[Pasted image 20241117130639.png]]

### Запуск скрипта
![[Pasted image 20241117130752.png]]

### Очистить все
Очистит данные во всех базах!! А не только к той, к которой мы подключены
![[Pasted image 20241117130807.png]]

![[Pasted image 20241117130855.png]]

### Переключение между БД внутри cli
select <номер_бд>

### Какого размера мы можем сохранить value по некоторому ключу? 512 мб.

### Работа с сервером
Получение статистики по серверу:
![[Pasted image 20241117132820.png]]
- keys - количество ключей на сервере.
- mem - количество памяти, которое занимает сервер
- clients - количество подключенных клиентов.
- requests - количество команд(+0, +1) и т.д. - это т.к. --stat команда выполняется с интервалом и добавляем по сути в этот счетчик свои же вызовы.

--latency:
![[Pasted image 20241117133151.png]]
Отображает задержку нашего сервера(avg). Т.е. сколько времени требуется серверу между выполнение операций.

Можно смотреть latency с периодом по 5 секунд. Это может быть полезно, чтобы смотреть когда у сервера были нагрузки повышенные.
![[Pasted image 20241117133253.png]]

redis-cli --bigkeys - для получения ключей, которые имеют больше всего элементов. Т.е. например, список, у которого больше всего элементов.
![[Pasted image 20241117133904.png]]

Если хотим посмотреть по памяти самые большие объекты, то используем уже
redis-cli --memkeys. Видим, что для mylist вывело 161 байт. В то время как при вызове redis-cli --bigkeys выводилось количество айтемов в списке.
![[Pasted image 20241117133817.png]]

redis-cli --scan - выводит ключи по порядку размера значений, которые храняется. Причем по убыванию. Т.е. по ключу file хранится самое большое значение:
![[Pasted image 20241117134106.png]]
redis-cli --scan --pattern "\*k\*" - выведет ключи, у которых есть в имени k.

### Команды для скриптинга
![[Pasted image 20241117134236.png]]
![[Pasted image 20241117134335.png]]

Но если не хотим писать на lua, то можем писать команды в txt файле и потом их запускать. Вот обычный txt файлик, в котором мы написали команды, которые хотим выполнить:
![[Pasted image 20241117134436.png]]
По сути просто читаем строки из файла и передаем в redis-cli
![[Pasted image 20241117134507.png]]

redis-cli dbsize - возвращает количество ключей по всем БД.
![[Pasted image 20241117134552.png]]

Для переподключения к другому серверу из интерактивного режима redis-cli:
![[Pasted image 20241117134716.png]]

Повторное выполнение команды в интерактивном режиме
![[Pasted image 20241117134813.png]]

BGSAVE - для сохранения данных на диск(причем асинхронно).

client list - посмотреть подключенных клиентов.
![[Pasted image 20241117135146.png]]

AUTH < password> - для аутентификации. Но предварительно сервер должен работать в режиме аутентификации

Для настройки сервера используется обычно конфигурационный файлик, но мы также можем и напрямую изменять какие-то конфигурации вызовом:
config set requirepass test - например установили для значения requirepass пароль test. И теперь на наш сервер можно подключиться, вызвав сначала auth test.
Вот пример, где мы включили аутентификацию на сервере и теперь мы уже не можешь просто вызвать incr counter, пока не аутентифицируемся по паролю с помощью auth.
![[Pasted image 20241117135629.png]]
Почему такой способ установки свойств конфига плох? Потому что все, что мы ввели для настройки потеряется. Поэтому конфигурацию пишем в файлике redis.config.

### Перейдем к redis config
redis.config - главный конфигурационный файл redis.

Для каждого проекта создается свой такой файлик, в котором и пишем конфигурации.
Базовые директивы:
![[Pasted image 20241117140643.png]]

### Как запустить redis server с определенным redis.config?
redis-server <относительный путь до файла с конфигом>
![[Pasted image 20241117140804.png]]

![[Pasted image 20241117140739.png]]
чтобы остановить сервер, который работает в фоне вызывается после подключения к cli команды shutdown.

![[Pasted image 20241117140949.png]]

loglevel - указываем уровень логирования, самый подробный debug. А в logfile - указываем куда выводить логи, по умолчанию выводятся на консоль, но можем указать файл.
![[Pasted image 20241117141032.png]]

save - для сохранения данных сервера на диск. 300 - это секунды, 10 - это изменения. И должно выполниться оба условия для того, чтобы сохранилось. Т.е. должно пройти 300 секунд, а также должно произойти минимум 10 изменений. Если 10 изменений не было за 300 секунд, то сохранения не будет, пока 10 изменений не произойдет.
![[Pasted image 20241117141338.png]]

Включает аутентификацию по паролю
![[Pasted image 20241117141508.png]]
Особенность Redis - нет пользователей и ролей. Один пароль задал на сервере и все, если по нему зашел, то у тебя полный доступ.

команда config будет переименована в команду hiddenconfig.
![[Pasted image 20241117141721.png]]

maxclients - устанавливает сколько подключений к серверу может быть.
![[Pasted image 20241117142044.png]]

maxmemory 2mb - ограничит размер сервера до 2мб
И теперь появляется вопрос, а что делать, когда память закончилась, то тут уже настройка
maxmemory-policy < policy>
- noeviction - команда на добавление выполнена не будет. Но читать и удалять можно.
- На скрине ниже есть другие возможные алгоритмы:
![[Pasted image 20241117142510.png]]
Чаще всего для policy используется allkeys-lru - которые удаляет ключи, у которых истекло expire time, а также те, которые редко используются, но у которых не истекло expire time.

slaveof - указывает host и port, который будет мастером!
![[Pasted image 20241117142842.png]]

![[Pasted image 20241117143455.png]]
![[Pasted image 20241117143618.png]]

Но если мы попробуем записать какое-то значение на slave сервере, то ничего не получится, т.к. он по умолчанию readonly. slave - является репликой мастера! Т.е. происходит синхронизация после того, как на master что-то было записано.
![[Pasted image 20241117143634.png]]

Но если вдруг мы хотим уметь записывать данные и в slave, то это делается с помощью slave-read-only no
![[Pasted image 20241117143808.png]]
Но так обычно никто не делает, да и к тому же от slave в master данные не идут, т.е. если мы добавим значение по ключу в slave, то в mastere этого ключа и значения не будет. При этом мастер всегда будет своими ключами перетирать ключи, которые slave мог для себя записать.

slave может быть полезен, чтобы быстро обрабатывать запросы клиентов из разных регионов. Мы можем для различных регионов создавать slave варианты нашего mastera. И тогда, backend при запросе пользователя может определить откуда он и получить данные из slave сервера, который запущен на какой-то машине, которая отвечает за этот регион. Т.е. меньшее расстояние будет проходить запрос на получение информации! А для кэша это особенно важно, т.к. выиграть в быстрой скорости получения, но проиграть из-за того, что данные передавались до получателя очень долго - глупо.

### Типы данных с Redis и работа с ними
![[Pasted image 20241118091416.png]]
![[Pasted image 20241118091836.png]]
### Strings
![[Pasted image 20241118091904.png]]
![[Pasted image 20241118092010.png]]
### Команды для работы со строками
![[Pasted image 20241118092554.png]]
incr, decr - будут выполняться только в том случае, если то, что хранится в строке можно интерпретировать как число.
incrBy - для инкремента не на единицу, а на заданное значение.
getrange - получить подстроку
mget - передаем ключи и получим сразу множество строк
mset - аналогично, только передаем ключи и значения
setnx - nx - такая приставка у команд, которая задаст значение для ключа в том случае, если такого ключа не было. Т.е. если ключ уже был создан кем-то, то она ничего не сделает, а если не создан, то создаст ключ и значение.
setex - установить время жизни(везде, где приставка ex)

![[Pasted image 20241118095235.png]]
Скобочки ставим тогда, когда в значении у нас есть пробелы.
Создали по ключу name значение John Doe

Через двоеточие можем создавать namespace пользователей, чтобы разделить их. Например, name:1, а 1 - это id пользователя. И тогда мы можем, например, сохранить
name:1 - имя пользователя с id = 1
age:1 - возраст пользователя с id = 1 и т.д.
![[Pasted image 20241118095328.png]]

извлекаем элементы по ключу
![[Pasted image 20241118095620.png]]

Добавление к значению, которое хранится по ключу name - строку. Причем если по такому ключу значения не было, то создается такая строка и ключ
![[Pasted image 20241118095715.png]]

Извлекаем подстроку
![[Pasted image 20241118095824.png]]

Начиная с 5 символа вставляем Norris:
![[Pasted image 20241118095904.png]]

getset - получаем старое значение и заменяем его новым
![[Pasted image 20241118100111.png]]
И важно, что в Redis команды атомарны! Т.е. если сразу два клиента вызовут getset, то сначала полностью выполнится команда у первого клиента, а потом второго

Устанавливаем значения для двух ключей name и age
![[Pasted image 20241118101151.png]]

incrBy - для инкремента только целые числа
![[Pasted image 20241118101457.png]]

Если хотим увеличить на float значение, то используем incrbyfloat
![[Pasted image 20241118101534.png]]

Если у нас хранится float значение по ключу, то incr уже использовать нельзя будет, будет ошибка

setex - устанавливаем по ключу name значение John Doe с временем жизни 4 секунды. После этого оно удалится.
![[Pasted image 20241118101737.png]]

psetex - тоже самое, что и setex, но в миллисекундах
![[Pasted image 20241118101841.png]]

Добавляем по ключу name значение и видим, что в первый раз было добавлено, а второй раз уже ничего не произойдет, т.к. по такому ключу уже есть запись
![[Pasted image 20241118101914.png]]

msetnx - вставляет либо все, либо ничего. Т.е. несмотря на то, что у нас по ключу age не было значения, вставка все равно не произойдет, т.к. по ключу name уже было значение.
![[Pasted image 20241118102051.png]]

Получаем длину строки по ключу name
![[Pasted image 20241118102206.png]]

### List
![[Pasted image 20241118092916.png]]
![[Pasted image 20241118093049.png]]
![[Pasted image 20241118093107.png]]
pop - извлекает значение из списка.
l - left - начало списка
r - right - конец списка
blpop - b - block. Она устроена так, что если в списке есть элементы, то все хорошо, она выполнится также как и lpop, т.е. получит элемент с начала списка. А если список пустой, то она заблокируется и будет ждать до тех пор, пока кто-нибудь не добавит в список элемент и потом эта команда также выполнится.

Вставляем в список colors значение blue в начало списка
![[Pasted image 20241118102259.png]]

Можем также добавлять сразу несколько элементов
![[Pasted image 20241118102334.png]]

lpushx - вставим значение в начало списка, если список существует, если не существует, то ничего не вставляем
![[Pasted image 20241118102512.png]]

llen colors - количество элементов в списке colors.

Получаем sublist элементов: 0 -1 - это получить весь список.
![[Pasted image 20241118102743.png]]

 pop - получаем и удаляем! Т.е. как в стеке или очереди.
![[Pasted image 20241118102924.png]]

lrem - удаление значений с начала списка. Если указываем отрицательное число для количества элементов, то удаление начинается с конца списка.
![[Pasted image 20241118103114.png]]

Можем вставлять before element или after element
 ![[Pasted image 20241118103306.png]]

lset для вставки по индексу
![[Pasted image 20241118103415.png]]

ltrim - обрезает список, т.е. не возвращает новый, а изменяет текущий!
![[Pasted image 20241118103447.png]]

rpoplpush - берем элемент из конца списка(r) colors и вставляем элемент в список secondColors в начало(l)
![[Pasted image 20241118103524.png]]

blpop - заблокирует клиента, пока в списке secondColors не будет хотя бы одного элемента. 0 - это timeout, сколько ждать выполнения. Если 0, то ждем бесконечно
![[Pasted image 20241118103724.png]]
### Set
![[Pasted image 20241118093601.png]]
![[Pasted image 20241118093730.png]]
scard - получение длины set
sdiff - вернутся элементы, которые отсутствуют во втором set
sinterstore - пересечение множеств сохраняется в списке
sismember - проверить является ли какое-то значение частью set
smembers - вернуть всех членов set
srem - удаление значений
sunion - оставим уникальные значения при объединении двух set

sadd - добавляем set с именем numbers и заполняем его значением one
![[Pasted image 20241118104229.png]]

удаляем элемент
![[Pasted image 20241118104339.png]]

smembers - получить список всех элементов set
![[Pasted image 20241118104400.png]]

ismember - проверить наличие элемента. Возвращает 1 если является и 0 если не является
![[Pasted image 20241118104427.png]]

scard - длина set
![[Pasted image 20241118104523.png]]

srandmember - получить рандомный элемент set

Странно. Какая разница с конца или не с конца, элементы же уникальные в set.
![[Pasted image 20241118104623.png]]

diff - возвращает разницу
![[Pasted image 20241118104708.png]]
![[Pasted image 20241118104719.png]]
![[Pasted image 20241118104748.png]]

sinter - вернуть пересечение множеств
![[Pasted image 20241118104805.png]]

sunion - соединяет значения двух множеств и оставляет только уникальные
![[Pasted image 20241118104826.png]]

smove target destination element
![[Pasted image 20241118104908.png]]
### Hash
![[Pasted image 20241118094058.png]]
![[Pasted image 20241118094441.png]]

Добавление элемента в hash
![[Pasted image 20241118105854.png]]

![[Pasted image 20241118105939.png]]

![[Pasted image 20241118110003.png]]
ключ, значение
![[Pasted image 20241118110014.png]]


![[Pasted image 20241118110038.png]]

Проверка существования ключа в hash
![[Pasted image 20241118110055.png]]

Получаем сразу несколько значений по переданным ключам
![[Pasted image 20241118110157.png]]

Удаляем значения
![[Pasted image 20241118110229.png]]

### Sorted set
![[Pasted image 20241118094734.png]]
![[Pasted image 20241118094925.png]]
![[Pasted image 20241118094953.png]]
rank - индекс
score - вес, по которому происходит сортировка
lex - это по значенению

zadd назнвание сета score значение. Т.е. теперь мы при добавлении указываем вес элемента, который добавляем и по этому весу и будет происходить сортировка.
![[Pasted image 20241118105003.png]]
![[Pasted image 20241118105119.png]]
Сортируется по score.

Получаем значения с score
![[Pasted image 20241118105227.png]]

Получаем элементы, у которых score находится в диапазоне от 0 до 3.
![[Pasted image 20241118105304.png]]

Заметим, что если мы используем rev для byscore, то нужно также менять местами диапазон score. Т.е. если оставить 0 3, а НЕ переделать на 3 0, то получим пустой set
![[Pasted image 20241118105428.png]]

Повышение score
![[Pasted image 20241118105623.png]]

Получаем score по определенному значению
![[Pasted image 20241118105652.png]]

Получаем именно индекс. Т.е. по сути его позиция от начала set
![[Pasted image 20241118105718.png]]

![[Pasted image 20241118105743.png]]

![[Pasted image 20241118105814.png]]

### Publish/subsribe
![[Pasted image 20241118110545.png]]
publish - производители
subsribe - потребители.
Не знают друг о друге, а только есть место, куда нужно выкладывать контент либо потреблять. 
![[Pasted image 20241118110619.png]]
Главное особенностью этого механизма от каких-то других брокеров - это то, что publisher отправил сообщение и это сообщение не будет дожидаться в redis, пока его кто-нибудь прочитает. Если был какой-то subsriber, который слушал это сообщение, то оно отправится ему, а если его не было, то сообщение просто потеряется.

![[Pasted image 20241118110834.png]]
- subsribe - подписаться на определенный канал
- psubsribe - подписаться на каналы по паттерну(у каналов есть названия).
- publish - отправка сообщение в канал, если кто-то на него подписан, то получит сообщение. Нет подписчиков - сообщение потеряется
- unsubsribe - отписаться
- punsubsribe - отписаться по паттерну
![[Pasted image 20241118111020.png]]
![[Pasted image 20241118111028.png]]
![[Pasted image 20241118111044.png]]

Отправка сообщений. Причем сначала нужно, чтобы были подписчики, иначе сообщение никому не придет.
![[Pasted image 20241118111140.png]]
![[Pasted image 20241118111147.png]]
Такое сообщение придет подписчику
![[Pasted image 20241118111324.png]]

### Транзакции
![[Pasted image 20241118112733.png]]
![[Pasted image 20241118112802.png]]
- multi - запуск транзакции
- exec - запустить выполняться транзакцию, т.е. commit
- discard - rollback

![[Pasted image 20241118112850.png]]

![[Pasted image 20241118112904.png]]

В Redis, даже если какая-то команда внутри транзакции вызвала ошибку, то все равно транзакция считается выполненной и другие команды не откатываются.
![[Pasted image 20241118113110.png]]

Зачем вообще такой механизм транзакций, если ошибка - не откатывает транзакцию? Транзакция откатывается, если команда не выполнена(но сюда не входит выполнение с ошибкой). 
### Data-persistence
![[Pasted image 20241118113607.png]]
![[Pasted image 20241118113631.png]]
Если для нас нормально, что данные могут потеряться, если, например, установили time in seconds в 1 час. Если же мы вообще не хотим никогда потерять хоть какие-то данные, то лучше использовать AOF:
![[Pasted image 20241118113733.png]]
Можно записывать каждую операцию, либо операции каждую секунду. Да, файлик будет большой из-за этого, но и меньше вероятности потерять какие-то данные.

При перезапуске нашего redis сервера он просто будет читать этот AOF файлик с начала и выполнять операции, чтобы прийти к тому состоянию, которое было сохранено в файлике AOF. В случае RDB схема похожа, только раз там сохраняется само состояние REdis, то чтение этого файла будет быстрее, чем выполнение операций в AOF.

![[Pasted image 20241118114103.png]]
everysec - рекомендованный к использованию

Redis умеет сжимать файл для aof. Мы можем вызвать redic-cli BGREWRITEAOF и он его сожмет. 


В IOC прикольно тоже применять, т.к. датчики могут генерировать очень много данных постоянно и эти данные можно очень быстро сохранять в redis.
![[Pasted image 20241118120514.png]]

