Редис часто называют БД, но на самом деле это распределенное хранилище key-value данных.
![[Pasted image 20241117103939.png]]
![[Pasted image 20241117104304.png]]
- Redis ограничен оперативными объемами памяти компьютера.
![[Pasted image 20241117104519.png]]
### Запуск
Для установки можно воспользоваться:
curl -O http://download.redis.io/redis-stable.tar.gz - скачиваем последнюю версию.
Потом распаковываем.
Заходим внутрь и через make компилируем исходники. Потом make install для установки.
А дальше все просто. redis-server - чтобы запустить сервер redis. И redis-cli для подключения, а если у нас какой-то удаленный сервер redis, то можно указать
redis-cli -h localhost -p 6379 - только вместо localhost и port уже определенные данные.

### Подключение
redis-cli - это командный интерфейс для работы с Redis хранилищем.

Мы можем также подключаться через -u:
![[Pasted image 20241117112529.png]]
Стоит заметить, что redis поддерживает аутентификацию по паролю.
Также стоит обратить внимание на 3-ю команду. Там есть /2. Redis сервер по умолчанию создает 16 как бы БД(их еще можно назвать namespace). И мы можем так разделять наши данных между БД, причем данные изолированы между ними.


Когда мы просто пишем redis-cli, то автоматически подключаемся к 0-ой БД(номера тех 16 БД, которые создает redis начинаются с 0 и до 15). Для подключения ко второй БД:
![[Pasted image 20241117112839.png]]

### Повторение команды
-r 10 - выполнить команду 10 раз. Т.е. произойдет increment счетчика counter 10 раз:
![[Pasted image 20241117112945.png]]

### Повторение + интервал
выполнить 10 раз с периодом в 0.5 сек. Т.е. не подряд будут выполняться, а с ожиданием.
![[Pasted image 20241117113040.png]]

### Чистый вид данных - это без типа, т.е. тут не будет указан тип, а только результат команды
![[Pasted image 20241117130425.png]]

### Сохраняем результат выполнения команды
В данном случае в файл file.log будет выводиться как инкрементился счетчик. КОманды incr counter - возвращает как раз значение счетчика. Т.е. в файл будет записано 1 2 3 4 5 ... 10. Причем т.к. raw, то не будем integer 1, integer 2, integer 3
![[Pasted image 20241117130503.png]]
### Записываем данные из файла в Redis
По ключу foo будут установлены данные из services
![[Pasted image 20241117130639.png]]

### Запуск скрипта
![[Pasted image 20241117130752.png]]

### Очистить все
Очистит данные во всех базах!! А не только к той, к которой мы подключены
![[Pasted image 20241117130807.png]]

![[Pasted image 20241117130855.png]]

### Переключение между БД внутри cli
select <номер_бд>

### Какого размера мы можем сохранить value по некоторому ключу? 512 мб.

### Работа с сервером
Получение статистики по серверу:
![[Pasted image 20241117132820.png]]
- keys - количество ключей на сервере.
- mem - количество памяти, которое занимает сервер
- clients - количество подключенных клиентов.
- requests - количество команд(+0, +1) и т.д. - это т.к. --stat команда выполняется с интервалом и добавляем по сути в этот счетчик свои же вызовы.

--latency:
![[Pasted image 20241117133151.png]]
Отображает задержку нашего сервера(avg). Т.е. сколько времени требуется серверу между выполнение операций.

Можно смотреть latency с периодом по 5 секунд. Это может быть полезно, чтобы смотреть когда у сервера были нагрузки повышенные.
![[Pasted image 20241117133253.png]]

redis-cli --bigkeys - для получения ключей, которые имеют больше всего элементов. Т.е. например, список, у которого больше всего элементов.
![[Pasted image 20241117133904.png]]

Если хотим посмотреть по памяти самые большие объекты, то используем уже
redis-cli --memkeys. Видим, что для mylist вывело 161 байт. В то время как при вызове redis-cli --bigkeys выводилось количество айтемов в списке.
![[Pasted image 20241117133817.png]]

redis-cli --scan - выводит ключи по порядку размера значений, которые храняется. Причем по убыванию. Т.е. по ключу file хранится самое большое значение:
![[Pasted image 20241117134106.png]]
redis-cli --scan --pattern "\*k\*" - выведет ключи, у которых есть в имени k.

### Команды для скриптинга
![[Pasted image 20241117134236.png]]
![[Pasted image 20241117134335.png]]

Но если не хотим писать на lua, то можем писать команды в txt файле и потом их запускать. Вот обычный txt файлик, в котором мы написали команды, которые хотим выполнить:
![[Pasted image 20241117134436.png]]
По сути просто читаем строки из файла и передаем в redis-cli
![[Pasted image 20241117134507.png]]

redis-cli dbsize - возвращает количество ключей по всем БД.
![[Pasted image 20241117134552.png]]

Для переподключения к другому серверу из интерактивного режима redis-cli:
![[Pasted image 20241117134716.png]]

Повторное выполнение команды в интерактивном режиме
![[Pasted image 20241117134813.png]]

BGSAVE - для сохранения данных на диск(причем асинхронно).

client list - посмотреть подключенных клиентов.
![[Pasted image 20241117135146.png]]

AUTH < password> - для аутентификации. Но предварительно сервер должен работать в режиме аутентификации

Для настройки сервера используется обычно конфигурационный файлик, но мы также можем и напрямую изменять какие-то конфигурации вызовом:
config set requirepass test - например установили для значения requirepass пароль test. И теперь на наш сервер можно подключиться, вызвав сначала auth test.
Вот пример, где мы включили аутентификацию на сервере и теперь мы уже не можешь просто вызвать incr counter, пока не аутентифицируемся по паролю с помощью auth.
![[Pasted image 20241117135629.png]]
Почему такой способ установки свойств конфига плох? Потому что все, что мы ввели для настройки потеряется. Поэтому конфигурацию пишем в файлике redis.config.

### Перейдем к redis config
redis.config - главный конфигурационный файл redis.

Для каждого проекта создается свой такой файлик, в котором и пишем конфигурации.
Базовые директивы:
![[Pasted image 20241117140643.png]]

### Как запустить redis server с определенным redis.config?
redis-server <относительный путь до файла с конфигом>
![[Pasted image 20241117140804.png]]

![[Pasted image 20241117140739.png]]
чтобы остановить сервер, который работает в фоне вызывается после подключения к cli команды shutdown.

![[Pasted image 20241117140949.png]]

loglevel - указываем уровень логирования, самый подробный debug. А в logfile - указываем куда выводить логи, по умолчанию выводятся на консоль, но можем указать файл.
![[Pasted image 20241117141032.png]]

save - для сохранения данных сервера на диск. 300 - это секунды, 10 - это изменения. И должно выполниться оба условия для того, чтобы сохранилось. Т.е. должно пройти 300 секунд, а также должно произойти минимум 10 изменений. Если 10 изменений не было за 300 секунд, то сохранения не будет, пока 10 изменений не произойдет.
![[Pasted image 20241117141338.png]]

Включает аутентификацию по паролю
![[Pasted image 20241117141508.png]]
Особенность Redis - нет пользователей и ролей. Один пароль задал на сервере и все, если по нему зашел, то у тебя полный доступ.

команда config будет переименована в команду hiddenconfig.
![[Pasted image 20241117141721.png]]

maxclients - устанавливает сколько подключений к серверу может быть.
![[Pasted image 20241117142044.png]]

maxmemory 2mb - ограничит размер сервера до 2мб
И теперь появляется вопрос, а что делать, когда память закончилась, то тут уже настройка
maxmemory-policy < policy>
- noeviction - команда на добавление выполнена не будет. Но читать и удалять можно.
- На скрине ниже есть другие возможные алгоритмы:
![[Pasted image 20241117142510.png]]
Чаще всего для policy используется allkeys-lru - которые удаляет ключи, у которых истекло expire time, а также те, которые редко используются, но у которых не истекло expire time.

slaveof - указывает host и port, который будет мастером!
![[Pasted image 20241117142842.png]]

![[Pasted image 20241117143455.png]]
![[Pasted image 20241117143618.png]]

Но если мы попробуем записать какое-то значение на slave сервере, то ничего не получится, т.к. он по умолчанию readonly. slave - является репликой мастера! Т.е. происходит синхронизация после того, как на master что-то было записано.
![[Pasted image 20241117143634.png]]

Но если вдруг мы хотим уметь записывать данные и в slave, то это делается с помощью slave-read-only no
![[Pasted image 20241117143808.png]]
Но так обычно никто не делает, да и к тому же от slave в master данные не идут, т.е. если мы добавим значение по ключу в slave, то в mastere этого ключа и значения не будет. При этом мастер всегда будет своими ключами перетирать ключи, которые slave мог для себя записать.

slave может быть полезен, чтобы быстро обрабатывать запросы клиентов из разных регионов. Мы можем для различных регионов создавать slave варианты нашего mastera. И тогда, backend при запросе пользователя может определить откуда он и получить данные из slave сервера, который запущен на какой-то машине, которая отвечает за этот регион. Т.е. меньшее расстояние будет проходить запрос на получение информации! А для кэша это особенно важно, т.к. выиграть в быстрой скорости получения, но проиграть из-за того, что данные передавались до получателя очень долго - глупо.