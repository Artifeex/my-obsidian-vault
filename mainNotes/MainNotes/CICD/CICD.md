Product Manager приносит бизнес требования. Затем аналитик использует эти бизнес требования и формирует решение - т.е. какие сервисы нужно будет изменить. Как будет устроено взаимодействие. И от этого решение формируются задачи, которые уже попадают в JIRA. Разработчики берут задачи из JIRA и пишет код у себя локально.

Под каждую фичу или задачу разработчик отводит ветку. В master ветке находится production.
![[Pasted image 20250109090426.png]]

Далее нужно влить изменения. Но сразу вливать нельзя - поскольку вдруг мы что-то поломали и теперь другие сервисы, которые обращаются в наш сервис - поломаются, поэтому нужно сначала протестировать систему с нашими изменениями. Мы создаем pull request на вливание изменений и в этот момент запускается процесс CI.

Во время этого процесса прогоняются тесты, которые мы написали, которые написали автотестировщики, если есть статические анализаторы кода, то они также анализируют код. Такие задачи называются джобами(job) и выполняются на CI сервере - т.е. отдельная полноценная машина, на которой все это выполняется. Каждая джоба - это какая-то единица задачи автоматизации. После всех этих тестов происходит сборка. Т.е. весь наш сервис собирается либо в jar, либо в docker контейнер(скорее всего, он имел в виду image). А потом эту сборку нужно разместить в хранилище - например, HARBOR или Nexus.
![[Pasted image 20250109090717.png]]

В основном джобы связаны в цепочки. Т.е. сначала выполняется первая - проверить что тестами покрыт заданный процент кода, затем запустить тесты и автотесты. И потом уже сделать сборку. И также часто, если какой-то этап цепочки не был выполнен успешно, то дальнеший джобы не выполняются. Т.е. есть зависимость между цепочками. Например: если не прошли тесты, то нет смысла делать сборку.

Jenkins и CICD Gitlab - как раз инструменты для того, чтобы можно было запускать и управлять такими джобами. 

Дальше нам необходимо созданную сборку поставить на какой-нибудь тестовый стенд, чтобы проверить, что она ставится, что запросы в нее приходят, ничего не упало. Также можно отправить запросы руками - этим обычно занимаются ручные тестировщики.

И вот тут как раз начинается этап CD. Он нужен для автоматизации замены старой версии проекта на новую. Без него пришлось бы руками подключаться на сервер, останавливать старую версию приложения и поднимать новую. 

Для этих нужд у нас также есть CD сервер(в зависимости от компании это может быть как тот же сервер, где и CI выполняется, так и тот же сервер, где production крутится. Но в больших компаниях обычно разделяют эти сервера. )

На CD сервере выполняется Deploy Job, которая занимается раскаткой(релизом) изменений, которые мы сделали на сервер. И этот сервер может быть разным - production или тестовый сервер, где мы можем кидать тестовые запросы и проверять, что все работает хотя бы на тесте. Процесс CD обычно не запускается автоматически для безопаности продакшена, хотя для каких-то других окружений может и автоматически. Обычно кто-то должен зайти в Gitlab CD или Jenkins и нажать кнопочку для деплоя на сервер.
![[Pasted image 20250109092136.png]]
### Окружения
Окружения нужны для того, чтобы можно было проверять изменения и взаимодействовать с ними. 
DEV - для разработчиков. Мы сделали изменения, хотим сами ручками проверить, отвечает ли на новый endpoint наш сервис или как он взаимодействует с другими сервисами. Для этого изменения раскатываются на dev стенд и после раскатки наш сервис становится доступным. Также этим dev стендом пользуются frontend разработчики. Им же нужно также верстать странички и обращаться к серверу.

Test - для ручных тестировщиков. Они проверяют уже более детально те изменения, которые мы сделали. 

Prod - продакшен. 

Бывают и другие окружения, например, preprod - где все настроено также, как и в prod. Или стенд для нагрузочного тестирования. 
![[Pasted image 20250109092922.png]]


Когда мы создали merge request, то запустился CI, который собрал сборку. Тестировщик эту сборку выкатил на test сервер, проверил ее. Дальше наши коллеги провели код ревью наших изменений. И если все хорошо, то изменения попадают в master ветку. 
![[Pasted image 20250109093635.png]]
И после вливания изменений в master ветку, снова запускается процесс CICD, но теперь уже для мастер ветки для создания сборки, которую уже потом выкатывают на продакшен. 

Pipeline - это как раз последовательность джоб. Их мы и пишем для автоматизации. 


### Статьс с Habr
https://habr.com/ru/articles/764568/
Вот так выглядит pipeline(видимо все-таки сборка раньше, чем тестирование, а не наоборот).
![[Pasted image 20250109095447.png]]
Алгоритм схемы следующий:
1. Разработчик пишет код и заливает его в GitLab-репозиторий проекта. 
2. GitLab ищет в корне репозитория конфиг .gitlab-ci.yml и, когда находит, запускает пайплайн согласно описанной в конфиге логике.
Пайплайн (pipeline) представляет собой целиковый процесс из этапов или стадий (stage), которые состоят из задач (job). Каждая задача выполняется в изолированном процессе (используется GitLab Runner).

