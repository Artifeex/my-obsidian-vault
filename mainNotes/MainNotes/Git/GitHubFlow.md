Где происходит тестирование?
https://github.com/GizmoDevDev/github-flow

https://docs.github.com/en/get-started/using-github/github-flow - гайд от GitHub.
Более простой вариант использования Git, чем [[GitFlow]]. 
![[Pasted image 20241017165324.png]]
## Почему github flow
1. Эффективная командная работа. GitHub Flow работает лучше всего для команд разработчиков, которые работают над одним проектом. Все операции выполняются на базе главной ветки, что облегчает интеграцию изменений, уменьшает фрагментацию ветвления и улучшает командную работу.
2. Простота использования. GitHub Flow очень прост в использовании, что позволяет команде быстро начать работу над проектом. Множество инструментов и функций GitHub помогают быстро создавать новые функции, исправлять ошибки и выпускать новые версии.
3. Надежность. GitHub Flow был разработан компанией GitHub и опробован на практике в течение многих лет. Это обеспечивает надежность и устойчивость работы методологии, а также поддержку и принятие сообществом разработчиков.
4. Непрерывная интеграция и развертывание. GitHub Flow легко интегрируется с инструментами непрерывной интеграции и развертывания, такими как Travis CI и Heroku. Это позволяет командам быстро и безопасно выпускать новые версии приложений.
5. Открытость. GitHub Flow использует открытый и прозрачный процесс разработки, что позволяет командам легко отслеживать изменения, проводить код-ревью и делать предложения по улучшению проекта.
## Базовые принципы
### Создание коммитов
- Один коммит - одна фича
- Заголовок коммита должен отображать изменения в коде
- Заголовок коммита должен быть лаконичным
- Для более подробного описания можно использовать блок описания коммита
### Работа с ветками
- Одна ветка - одна задача
- Не меняем главную ветку напрямую, все изменения через пулл реквесты
- Имя ветки отражает суть задачи или ее номер в системе(например, в JIRA).
- Прежде чем пушить изменения надо обновить main и влить в свою ветку
## Работа с гитом в процессе решения задачи
1. `git checkout -b yourBranchName` - под какую-то фичу создаем ветку.
2. Пишем код, который решает задачу
3. Коммитим все свои изменения в ветку, которую создали. Но и можем делать промежуточные коммиты, чтобы, во-первых, сохранять, во-вторых, следовать правилу - 1 коммит, одна фича. А в рамках одной ветки, в которой мы реализуем какую-то фичу могут, может потребоваться реализовать еще несколько более маленьких фичей.
4. `git checkout main` - переходим в main, которая сохранена на нашем локальном компьютере. 
5. `git pull` - обновляем ветку main, ведь та, что у нас сейчас локально может не быть актуальной. Подтягиваем изменения с удаленного репозитория.
6. Возвращаемся в свою ветку `git checkout yourBranchName`
7. `git merge main` - делаем слияние нашей feature ветки с main.
8. Решаем конфликты, если они есть
9. Пушим в репозиторий `git push --set-upstream origin yourBranchName`. 
10. Создаем пул реквест. Коллеги посмотрят на пул реквест, сделают какие-то замечания. Мы их исправляем. Снова переходим в нашу фича ветку и повторяем пункты с 3 по 9. Т.е. новый пул реквест не создается, все наши git push на нашей ветке, которым мы мерджим будут видны в pull request, где коллеги снова смогут комментировать наши изменения.
## Базовые команды
### Работа с коммитами и удаленным репозиторием
- `git add fileNames` - добавляет файлы для коммита
- `git commit -m 'message'` - коммит добавленные файлы с сообщением
- `git fetch` - запрашивает информацию о ветках с удаленного репозитория
- `git push` - отправляет данные на удаленный репозиторий
- `git pull` - получает данные с удаленного репозитория
### Работа с ветками
- `git checkout name` - переключамся на существующую ветку
- `git checkout -b name` - создаем новую ветку и переключаемся на нее
- `git branch` - получаем список доступных веток
- `git merge name` - запускает процесс слияния двух веток
- `git merge --continue` - продолжает процесс слияния после разрешения мердж конфликтов
- `git merge --abort` - сбрасывает прогресс слияния веток
## Дополнительная информация
### GIT FLOW  по “взрослому”
main - основная ветка,  в ней должен быть только рабочий кот).
основное правило - ничего не пушить напрямую в  main!
1. Находясь в основной ветке создаем ветку по названию задачи -  
    git checkout -b "название_своей_ветки(задачи)" и работаем в ней
2. Когда задача сделана:  
    git add -A, git commit -m "какие измения были внесены\какая задача решена"
3. Переходим на основную ветку git checkout main и притягиваем все изменения с remote репозитория  - git pull origin main
4. Возвращаемся в свою ветку - git checkout название_своей_ветки(задачи)
5. Производим объединение основной ветки со своей локальной веткой командой - git merge main. ( main -> в свою)
6. У себя локально решаем конфликты в коде со своей командой, если таковые возникают.
7. Обязательно запускаем проект, проверяем работает ли то, что вы создали, не сломали ли вы то, что уже работало. Если все работает, -  идете к следующему шагу. Если нет - ищите ошибки, решаете их (если надо - привлекайте команду ) и только после этого переходите к следующему шагу.
8. Комитим и пушим свою ветку на сервер -  
    git add -A, git commit -m "какие измения были внесены\какая задача решена",  
    git push origin название_своей_ветки(задачи)
9. на сайте [github.com](http://github.com/) делайте слияние своей ветки с основной веткой:  на желтом фоне с обновлениями есть кнопка (Compare and Pull Request ), нажимаете ее и при переходе ВНИМАНИЕ вы выбираете откуда(справа) и куда(слева). Слева должно стоять main, справа - название вашей ветки (при этом справа должна появиться надпись "Able to merge". Желательно прописать  название по типу "какие измения были внесены\какая задача решена". Нажимаете внизу кнопку Create pull request.
10. Делаете мердж. После мерджа в той же форме удаляем свою ветку delete branch
11. Сообщаем своей команде, что основная ветка обновлена и они могут пулить(подтягиваеть) ее себе. Все радуются и пулят.
12. Возвращаемся в VSCode или Webshtorm. переходим в основную ветку - git checkout main подтягиваем изменения: git pull origin main
13. Кто пользует ВСкод - запускаем команду git fetch --prune - она удалит персональные ветки, которые были удалены на гите. Кто использует Шторм - при клике на ветку увидит возможность удаления ветки.
14. Берем новую задачу, и находясь в основной ветке, создаем и переключаемся на свою новую ветку (пункт 1) и творим дальше.