На самом деле HEAD ссылается на определенную ветку. А ветка уже ссылается на определенный commit. 
![[Pasted image 20241013204543.png]]
При создании нового коммита git автоматически делает так, чтобы ветка ссылалась на последний созданный commit. Ветка всегда ссылается на последний коммит в ЭТОЙ ветке.
![[Pasted image 20241013204709.png]]
Когда мы работаем в рамках одной ветки, то эта ветка ссылается на самый последний commit. Когда мы добавляем новые коммиты, то ветка просто перемещается и начинает указывать на тот коммит, который мы добавили. HEAD же не перемещается, он как указывал на ветку, так и продолжает указывать, эта ветка стала указывать на другой коммит.

Мы можем создавать дополнительные ветки, создавать коммиты внутри них и переключаться между ними. Можем создавать 2 ветки:
![[Pasted image 20241020190849.png]]
Можем заметить, что у коммитов в ветках feature1 и feature2 есть родительский коммит, который находящийся внутри ветки main. Это, значит, что в момент, когда мы находились на этом коммите, то мы решили создать ветку, перешли в нее и дальше создавали коммиты внутри этой ветки. А потом мы могли обратно вернуться в ветку main и создавать коммиты уже внутри этой ветки.

Для перехода между ветками нужно перемещать указатель HEAD командой
`git checkout <название ветки>`. После того, как HEAD переместился, git смотрит на ветку, на которую указывает HEAD, потом на коммит, на который указывает ветка и потом перестраивает working directory на то состояние, которое хранит корневое дерево, которое хранит внутри себя commit.

[[Команды для работы с ветками Git]]