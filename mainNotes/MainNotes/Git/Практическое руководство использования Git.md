`git push -u origin master` - так мы и связываем нашу ветку master с удаленной веткой, но можно еще понимать это как создание удаленной ветки.
`git log ` - список коммитов в ветке.
.gitignore - нужен для того, чтобы файлы не попадаи в staged состояние. Внутри этого текстового файлика мы можем указывать как названия, так и типы файлов, так и названия директорий(например: hiden/)

Если мы хотим добавить пустую директорию в git, то, чтобы ее можно было добавить, можно создавать внутри нее файлик .gitkeep и тогда можно будет ее запушить(а так пустые директории пушить нельзя). После того, как в этой директории окажутся хоть какие-то файлы, то файлик .gitkeep можно удалить.

`git checkout -b <branch name>` - создать и перейти в ветку branch name. Далее мы можем в ней работать, но удаленно такой ветки еще нет. Поэтому, чтобы запушить изменения из этой ветки в удаленный репозиторий, т.е. по факту добавить в удаленном репозиторию такую ветку и ее коммиты, нужно использовать команду:
`git push --set-upstream origin <branch_name>`.  Так делаем только при первом пуше нашей новой локальной ветки, в дальнейшем, когда связь между ветками установилась, то уже просто git push.

`git merge <branch_name>` - мерджим текущую ветку с той, что указали в branch_name. После мерджа мы можем удалить ветку, которую мерджили.
`git branch -d branch_name` - для удаления локально. Но ветка все еще осталась на удаленном репозитории. Для удаления этой ветки и удаленно нужно использовать:
`git push --delete origin branch_name`

### Merge Conflicts 
При попытке слияния веток могут возникнуть конфликты. Это когда в двух ветках мог быть изменен один и тот же файл в одном и том же месте и тогда непонятно, какую версию файла выбрать при Merge.

Когда мы попробуем смерджить, то увидим, что произошел кофликт. Для его решения мы должны выбрать один из вариантов, либо средствами ide, либо просто в ручную в том файле, где произошел конфликт удалить тот вариант, который нам не нужен и выбрать тот, что нужен. В файле, в котором произошел конфликт появятся два варианта записи с вариантами из 2-х веток. Удалив вручную один из вариантов мы и решаем конфликт. А потом вызываем `git add .` и `git merge --continue`.

Вот, что появляется в файле при конфликтах:
![[Pasted image 20241020213734.png]]

### Merge/Pull Request
В большинстве случаев при командной разработке merge происходит не локально, а на удаленном репозитории, используя merge request или pull request. Под капотом будет происходить все тоже самое, но через веб-интерфейс.

Т.е. мы создаем локально какую-то ветку, работаем в ней, потом пушим ее на удаленный репозиторий командной `git push --set-upstream origin my_branch` и дальше, сам GitHub предлагает нам выполнить Pull Request, чтобы запросить слияние нашей удаленной ветки с удаленной веткой main.
![[Pasted image 20241020214054.png]]

После этого тот, у кого есть права может посмотреть на пул реквест и замерджить его. Т.е. изменения из нашей ветки замерджатся в основную ветку проекта.

При этом, если мы делали pull request через веб-интерфейс, то изменения выполнились на удаленном репозитории, а локально наша main ветка уже устарела. Для обновления нашей локальной ветки используем `git pull`. Также мы не должны забывать удалять ветки, которые мерджили в основную. Причем удаляем как локально, так и удаленно.

### cherry-pick
Команда нужна для того, чтобы скопировать один или несколько коммитов из одной ветки в другую. От merge отличается тем, что перенос более точечный. При merge в ветке окажут все коммиты(т.е. в истории они будут и вызвав `git log` мы увидим все коммиты той ветки, которую мерджили), а при cherry-pick только те, что мы укажем.

Для выполнения мы должны узнать hash коммита, который хотим перенести. Затем переходим в ветку, в которую хотим перенести коммит, например, в main и потом выполняем команду `git cherry-pick hash`. И тогда в ветку main в конец добавится еще один коммит, который мы и скопировали. Т.е. мы как будто сделали еще один commit в main ветке, но на самом деле мы скопировали этот коммит и вставили. 

Чтобы скопировать сразу несколько коммитов нужно передавать hash через пробел, причем в порядке от более старого коммита, к более новому.

### git stash
В stash можем добавлять изменения, которые мы не хотим коммитить, но можем хотеть сохранить, чтобы можно было вернуться. Он работает как стек. Например, мы можем добавить какую-то строчку, потом выполнить команду git stash, это строчка пропадет из нашего файла и добавится в stash. И потом мы в любой момент можем вернуть данные из stash, вызвав команду `git stash pop`

### reset
`git reset --hard` - удалит все не закомиченные данные. Т.е. мы могли работать, работать, но понять, что хотим откатиться обратно на начальный коммит, в котором начинали работу. Он откатывает, но при этом, если мы добавили какой-то файлик, который untracked, то `git reset` его не удалит. При этом, если мы добавим этот файлик в staged area командой `git add .`, то тогда уже командой `git reset --hard` данный файлик пропадет.

### revert
Позволяет откатить commit. По сути, команда создает новый commit, в котором откатываются предыдущие изменения. 
ё
`git revert hash` и в hash мы указываем тот commit, который мы хотим откатить. Т.е. после выполнения данной команды создается новый commit, который откатывает действия, которые произошли в коммисте с hash, который мы передали. Т.е. в новом коммите будет такое состояние, которое было перед коммитом, hash которого мы передали в git revert.

### rebase
Он интегрирует коммиты в текущую ветку, а не наложит их сверху как при merge. Он поменяет саму структуру ветки. 
Есть также `git rebase -i` в котором можно указать какой-то коммит и потом все коммиты, которые были от этого коммита и то HEAD решать, что будем с ними делать. Там можно удалить какой-то коммит(drop), замерджить два коммита в один(s) или просто выбрать коммит(pick). 

`git rebase` — это команда в Git, которая позволяет "переписывать" историю коммитов. Она используется для того, чтобы перемещать одну ветку на другую, применяя её коммиты по-новому. Основная цель `git rebase` — поддерживать историю проекта чистой и линейной, избегая большого количества слияний (`merge`) и сложной структуры дерева.

### Как это работает:
`git rebase` перемещает все коммиты с одной ветки и "присоединяет" их к основе другой ветки, как будто они были сделаны после неё.

### Пример:
У вас есть две ветки:
- `main` — основная ветка.
- `feature` — ваша рабочая ветка, в которой вы сделали несколько коммитов.

Предположим, вы хотите перенести изменения из `feature` на обновлённую версию `main`. Вы выполняете:
```bash
git checkout feature
git rebase main
```
Что происходит:
1. **Git запоминает ваши коммиты в ветке `feature`.**
2. **Git перемещает указатель `feature` на последний коммит из ветки `main`.**
3. **Git "поверх" коммитов из `main` применяет ваши коммиты, как если бы они изначально были сделаны после них.**

### Основные случаи использования:
- **Интеграция изменений из основной ветки в рабочую ветку**: Вместо `merge`, который создаёт дополнительные коммиты, `rebase` сохраняет историю линейной.
- **Чистая история**: После ребейса коммиты выглядят так, будто они были сделаны поверх самых последних изменений, что упрощает их понимание.

### Типы rebase:
1. **Интерактивный (`git rebase -i`)**: Позволяет вам не просто переписывать историю, но и редактировать, объединять или удалять коммиты. Полезно для очистки истории перед отправкой изменений.
2. **Автоматический (`git rebase`)**: Просто переносит изменения с одной ветки на другую.

### Пример работы с конфликтами:
Если в процессе `rebase` возникнет конфликт, Git остановится и попросит вас его разрешить. После решения конфликта нужно выполнить:
```bash
git add <файл>
git rebase --continue
```
Если вы хотите прервать ребейз, можно использовать:
```bash
git rebase --abort
```

### Когда использовать `git rebase`:
- **Для обновления вашей ветки** с последними изменениями из основной ветки без создания дополнительных merge-коммитов.
- **Перед отправкой изменений** в удалённый репозиторий, чтобы очистить и упростить историю коммитов.

### Важно:
- **Не выполняйте `rebase` на ветках, которые уже были отправлены в удалённый репозиторий и которые используются другими людьми**, так как это изменяет историю коммитов и может вызвать проблемы для других разработчиков.

### git commit --amend
Команда `git commit --amend` используется для изменения последнего коммита в репозитории. Она позволяет внести исправления в сам коммит (например, изменить сообщение коммита или добавить забытые изменения), не создавая нового коммита.

Когда вы используете `git commit --amend`:

1. Git откроет текстовый редактор, где вы сможете изменить сообщение последнего коммита.
2. Если у вас есть изменения в рабочей директории, которые вы забыли добавить в предыдущий коммит, вы можете добавить их с помощью `git add`, а затем выполнить `git commit --amend` для их включения в этот коммит.

Основные случаи использования:

- Изменение сообщения последнего коммита.
- Добавление забытых изменений в предыдущий коммит.

### git log --all --graph
Показывает историю коммитов
![[Pasted image 20241020221529.png]]
### tig
`sudo apt install tig` - утилита для удобное просмотра истории комитов.
![[Pasted image 20241020221616.png]]




